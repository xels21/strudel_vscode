{
  "functions": [
    {
      "name": "absoluteOrientationAlpha",
      "description": "<p>The device's absolute orientation alpha value ranges from 0 to 1.</p>",
      "params": [],
      "examples": [
        "n(absoluteOrientationAlpha.segment(4).range(0,7)).scale(\"C:minor\")"
      ],
      "synonyms": [
        "absOriA",
        "absOriZ",
        "absoluteOrientationZ"
      ],
      "originalName": "absoluteOrientationAlpha"
    },
    {
      "name": "absoluteOrientationBeta",
      "description": "<p>The device's absolute orientation beta value ranges from 0 to 1.</p>",
      "params": [],
      "examples": [
        "n(absoluteOrientationBeta.segment(4).range(0,7)).scale(\"C:minor\")"
      ],
      "synonyms": [
        "absOriB",
        "absOriX",
        "absoluteOrientationX"
      ],
      "originalName": "absoluteOrientationBeta"
    },
    {
      "name": "absoluteOrientationGamma",
      "description": "<p>The device's absolute orientation gamma value ranges from 0 to 1.</p>",
      "params": [],
      "examples": [
        "n(absoluteOrientationGamma.segment(4).range(0,7)).scale(\"C:minor\")"
      ],
      "synonyms": [
        "absOriG",
        "absOriY",
        "absoluteOrientationY"
      ],
      "originalName": "absoluteOrientationGamma"
    },
    {
      "name": "absoluteOrientationX",
      "description": "<p>The device's absolute orientation beta value ranges from 0 to 1.</p>",
      "params": [],
      "examples": [
        "n(absoluteOrientationBeta.segment(4).range(0,7)).scale(\"C:minor\")"
      ],
      "synonyms": [
        "absOriB",
        "absOriX",
        "absoluteOrientationX"
      ],
      "originalName": "absoluteOrientationBeta"
    },
    {
      "name": "absoluteOrientationY",
      "description": "<p>The device's absolute orientation gamma value ranges from 0 to 1.</p>",
      "params": [],
      "examples": [
        "n(absoluteOrientationGamma.segment(4).range(0,7)).scale(\"C:minor\")"
      ],
      "synonyms": [
        "absOriG",
        "absOriY",
        "absoluteOrientationY"
      ],
      "originalName": "absoluteOrientationGamma"
    },
    {
      "name": "absoluteOrientationZ",
      "description": "<p>The device's absolute orientation alpha value ranges from 0 to 1.</p>",
      "params": [],
      "examples": [
        "n(absoluteOrientationAlpha.segment(4).range(0,7)).scale(\"C:minor\")"
      ],
      "synonyms": [
        "absOriA",
        "absOriZ",
        "absoluteOrientationZ"
      ],
      "originalName": "absoluteOrientationAlpha"
    },
    {
      "name": "absOriA",
      "description": "<p>The device's absolute orientation alpha value ranges from 0 to 1.</p>",
      "params": [],
      "examples": [
        "n(absoluteOrientationAlpha.segment(4).range(0,7)).scale(\"C:minor\")"
      ],
      "synonyms": [
        "absOriA",
        "absOriZ",
        "absoluteOrientationZ"
      ],
      "originalName": "absoluteOrientationAlpha"
    },
    {
      "name": "absOriB",
      "description": "<p>The device's absolute orientation beta value ranges from 0 to 1.</p>",
      "params": [],
      "examples": [
        "n(absoluteOrientationBeta.segment(4).range(0,7)).scale(\"C:minor\")"
      ],
      "synonyms": [
        "absOriB",
        "absOriX",
        "absoluteOrientationX"
      ],
      "originalName": "absoluteOrientationBeta"
    },
    {
      "name": "absOriG",
      "description": "<p>The device's absolute orientation gamma value ranges from 0 to 1.</p>",
      "params": [],
      "examples": [
        "n(absoluteOrientationGamma.segment(4).range(0,7)).scale(\"C:minor\")"
      ],
      "synonyms": [
        "absOriG",
        "absOriY",
        "absoluteOrientationY"
      ],
      "originalName": "absoluteOrientationGamma"
    },
    {
      "name": "absOriX",
      "description": "<p>The device's absolute orientation beta value ranges from 0 to 1.</p>",
      "params": [],
      "examples": [
        "n(absoluteOrientationBeta.segment(4).range(0,7)).scale(\"C:minor\")"
      ],
      "synonyms": [
        "absOriB",
        "absOriX",
        "absoluteOrientationX"
      ],
      "originalName": "absoluteOrientationBeta"
    },
    {
      "name": "absOriY",
      "description": "<p>The device's absolute orientation gamma value ranges from 0 to 1.</p>",
      "params": [],
      "examples": [
        "n(absoluteOrientationGamma.segment(4).range(0,7)).scale(\"C:minor\")"
      ],
      "synonyms": [
        "absOriG",
        "absOriY",
        "absoluteOrientationY"
      ],
      "originalName": "absoluteOrientationGamma"
    },
    {
      "name": "absOriZ",
      "description": "<p>The device's absolute orientation alpha value ranges from 0 to 1.</p>",
      "params": [],
      "examples": [
        "n(absoluteOrientationAlpha.segment(4).range(0,7)).scale(\"C:minor\")"
      ],
      "synonyms": [
        "absOriA",
        "absOriZ",
        "absoluteOrientationZ"
      ],
      "originalName": "absoluteOrientationAlpha"
    },
    {
      "name": "accelerate",
      "description": "<p>A pattern of numbers that speed up (or slow down) samples while they play. Currently only supported by osc / superdirt.</p>",
      "params": [
        {
          "name": "amount",
          "type": "number | Pattern",
          "description": "<p>acceleration.</p>"
        }
      ],
      "examples": [
        "s(\"sax\").accelerate(\"<0 1 2 4 8 16>\").slow(2).osc()"
      ],
      "synonyms": [],
      "originalName": "accelerate"
    },
    {
      "name": "accelerationX",
      "description": "<p>The accelerometer's x-axis value ranges from 0 to 1.</p>",
      "params": [],
      "examples": [
        "n(accelerationX.segment(4).range(0,7)).scale(\"C:minor\")"
      ],
      "synonyms": [
        "accX"
      ],
      "originalName": "accelerationX"
    },
    {
      "name": "accelerationY",
      "description": "<p>The accelerometer's y-axis value ranges from 0 to 1.</p>",
      "params": [],
      "examples": [
        "n(accelerationY.segment(4).range(0,7)).scale(\"C:minor\")"
      ],
      "synonyms": [
        "accY"
      ],
      "originalName": "accelerationY"
    },
    {
      "name": "accelerationZ",
      "description": "<p>The accelerometer's z-axis value ranges from 0 to 1.</p>",
      "params": [],
      "examples": [
        "n(accelerationZ.segment(4).range(0,7)).scale(\"C:minor\")"
      ],
      "synonyms": [
        "accZ"
      ],
      "originalName": "accelerationZ"
    },
    {
      "name": "accX",
      "description": "<p>The accelerometer's x-axis value ranges from 0 to 1.</p>",
      "params": [],
      "examples": [
        "n(accelerationX.segment(4).range(0,7)).scale(\"C:minor\")"
      ],
      "synonyms": [
        "accX"
      ],
      "originalName": "accelerationX"
    },
    {
      "name": "accY",
      "description": "<p>The accelerometer's y-axis value ranges from 0 to 1.</p>",
      "params": [],
      "examples": [
        "n(accelerationY.segment(4).range(0,7)).scale(\"C:minor\")"
      ],
      "synonyms": [
        "accY"
      ],
      "originalName": "accelerationY"
    },
    {
      "name": "accZ",
      "description": "<p>The accelerometer's z-axis value ranges from 0 to 1.</p>",
      "params": [],
      "examples": [
        "n(accelerationZ.segment(4).range(0,7)).scale(\"C:minor\")"
      ],
      "synonyms": [
        "accZ"
      ],
      "originalName": "accelerationZ"
    },
    {
      "name": "add",
      "description": "<p>Assumes a pattern of numbers. Adds the given number to each item in the pattern.</p>",
      "params": [],
      "examples": [
        "// Here, the triad 0, 2, 4 is shifted by different amounts\rn(\"0 2 4\".add(\"<0 3 4 0>\")).scale(\"C:major\")\r// Without add, the equivalent would be:\r// n(\"<[0 2 4] [3 5 7] [4 6 8] [0 2 4]>\").scale(\"C:major\")",
        "// You can also use add with notes:\rnote(\"c3 e3 g3\".add(\"<0 5 7 0>\"))\r// Behind the scenes, the notes are converted to midi numbers:\r// note(\"48 52 55\".add(\"<0 5 7 0>\"))"
      ],
      "synonyms": [],
      "originalName": "add"
    },
    {
      "name": "addVoicings",
      "description": "<p>Adds a new custom voicing dictionary.</p>",
      "params": [
        {
          "name": "name",
          "type": "string",
          "description": "<p>identifier for the voicing dictionary</p>"
        },
        {
          "name": "dictionary",
          "type": "Object",
          "description": "<p>maps chord symbol to possible voicings</p>"
        },
        {
          "name": "range",
          "type": "Array",
          "description": "<p>min, max note</p>"
        }
      ],
      "examples": [
        "addVoicings('cookie', {\r  7: ['3M 7m 9M 12P 15P', '7m 10M 13M 16M 19P'],\r  '^7': ['3M 6M 9M 12P 14M', '7M 10M 13M 16M 19P'],\r  m7: ['8P 11P 14m 17m 19P', '5P 8P 11P 14m 17m'],\r  m7b5: ['3m 5d 8P 11P 14m', '5d 8P 11P 14m 17m'],\r  o7: ['3m 6M 9M 11A 15P'],\r  '7alt': ['3M 7m 10m 13m 15P'],\r  '7#11': ['7m 10m 13m 15P 17m'],\r}, ['C3', 'C6'])\r\"<C^7 A7 Dm7 G7>\".voicings('cookie').note()"
      ],
      "synonyms": [],
      "originalName": "addVoicings"
    },
    {
      "name": "adsr",
      "description": "<p>ADSR envelope: Combination of Attack, Decay, Sustain, and Release.</p>",
      "params": [
        {
          "name": "time",
          "type": "number | Pattern",
          "description": "<p>attack time in seconds</p>"
        },
        {
          "name": "time",
          "type": "number | Pattern",
          "description": "<p>decay time in seconds</p>"
        },
        {
          "name": "gain",
          "type": "number | Pattern",
          "description": "<p>sustain level (0 to 1)</p>"
        },
        {
          "name": "time",
          "type": "number | Pattern",
          "description": "<p>release time in seconds</p>"
        }
      ],
      "examples": [
        "note(\"[c3 bb2 f3 eb3]*2\").sound(\"sawtooth\").lpf(600).adsr(\".1:.1:.5:.2\")"
      ],
      "synonyms": [],
      "originalName": "adsr"
    },
    {
      "name": "aliasBank",
      "description": "<p>Register an alias for a bank of sounds.\nOptionally accepts a single argument map of bank aliases.\nOptionally accepts a single argument string of a path to a JSON file containing bank aliases.</p>",
      "params": [
        {
          "name": "bank",
          "type": "string",
          "description": "<p>The bank to alias</p>"
        },
        {
          "name": "alias",
          "type": "string",
          "description": "<p>The alias to use for the bank</p>"
        }
      ],
      "examples": [],
      "synonyms": [],
      "originalName": "aliasBank"
    },
    {
      "name": "allTransforms",
      "description": "<p>Applies a function to all the running patterns. Note that the patterns are groups together into a single <code>stack</code> before the function is applied. This is probably what you want, but see <code>each</code> for\na version that applies the function to each pattern separately.</p>\n<pre class=\"prettyprint source\"><code>$: sound(&quot;bd - cp sd&quot;)\n$: sound(&quot;hh*8&quot;)\nall(fast(&quot;&lt;2 3>&quot;))\n</code></pre>\n<pre class=\"prettyprint source\"><code>$: sound(&quot;bd - cp sd&quot;)\n$: sound(&quot;hh*8&quot;)\nall(x => x.pianoroll())\n</code></pre>",
      "params": [],
      "examples": [],
      "synonyms": [],
      "originalName": "allTransforms"
    },
    {
      "name": "almostAlways",
      "description": "<p>Shorthand for <code>.sometimesBy(0.9, fn)</code></p>",
      "params": [],
      "examples": [
        "s(\"hh*8\").almostAlways(x=>x.speed(\"0.5\"))"
      ],
      "synonyms": [],
      "originalName": "almostAlways"
    },
    {
      "name": "almostNever",
      "description": "<p>Shorthand for <code>.sometimesBy(0.1, fn)</code></p>",
      "params": [],
      "examples": [
        "s(\"hh*8\").almostNever(x=>x.speed(\"0.5\"))"
      ],
      "synonyms": [],
      "originalName": "almostNever"
    },
    {
      "name": "always",
      "description": "<p>Shorthand for <code>.sometimesBy(1, fn)</code> (always calls fn)</p>",
      "params": [],
      "examples": [
        "s(\"hh*8\").always(x=>x.speed(\"0.5\"))"
      ],
      "synonyms": [],
      "originalName": "always"
    },
    {
      "name": "amp",
      "description": "<p>Like <code>gain</code>, but linear.</p>",
      "params": [
        {
          "name": "amount",
          "type": "number | Pattern",
          "description": "<p>gain.</p>"
        }
      ],
      "examples": [
        "s(\"bd*8\").amp(\".1*2 .5 .1*2 .5 .1 .5\").osc()"
      ],
      "synonyms": [],
      "originalName": "amp"
    },
    {
      "name": "anchor",
      "description": "<p>The top note to align the voicing to. Defaults to c5</p>",
      "params": [
        {
          "name": "anchorNote",
          "type": "string | Pattern",
          "description": "<p>the note to align the voicings to</p>"
        }
      ],
      "examples": [
        "anchor(\"<c4 g4 c5 g5>\").chord(\"C\").voicing()"
      ],
      "synonyms": [],
      "originalName": "anchor"
    },
    {
      "name": "appBoth",
      "description": "<p>When this method is called on a pattern of functions, it matches its haps\nwith those in the given pattern of values.  A new pattern is returned, with\neach matching value applied to the corresponding function.</p>\n<p>In this <code>_appBoth</code> variant, where timespans of the function and value haps\nare not the same but do intersect, the resulting hap has a timespan of the\nintersection. This applies to both the part and the whole timespan.</p>",
      "params": [
        {
          "name": "pat_val",
          "type": "Pattern",
          "description": ""
        }
      ],
      "examples": [],
      "synonyms": [],
      "originalName": "appBoth"
    },
    {
      "name": "appLeft",
      "description": "<p>As with <code>appBoth</code>, but the <code>whole</code> timespan is not the intersection,\nbut the timespan from the function of patterns that this method is called\non. In practice, this means that the pattern structure, including onsets,\nare preserved from the pattern of functions (often referred to as the left\nhand or inner pattern).</p>",
      "params": [
        {
          "name": "pat_val",
          "type": "Pattern",
          "description": ""
        }
      ],
      "examples": [],
      "synonyms": [],
      "originalName": "appLeft"
    },
    {
      "name": "apply",
      "description": "<p>Layers the result of the given function(s). Like <code>superimpose</code>, but without the original pattern:</p>",
      "params": [],
      "examples": [
        "\"<0 2 4 6 ~ 4 ~ 2 0!3 ~!5>*8\"\r  .layer(x=>x.add(\"0,2\"))\r  .scale('C minor').note()"
      ],
      "synonyms": [
        "apply"
      ],
      "originalName": "layer"
    },
    {
      "name": "applyGradualLowpass",
      "description": "<p>Applies a constantly changing lowpass filter to the given sound.</p>",
      "params": [
        {
          "name": "input",
          "type": "AudioBuffer",
          "description": ""
        },
        {
          "name": "lpFreqStart",
          "type": "number",
          "description": ""
        },
        {
          "name": "lpFreqEnd",
          "type": "number",
          "description": ""
        },
        {
          "name": "lpFreqEndAt",
          "type": "number",
          "description": ""
        },
        {
          "name": "callback",
          "type": "function",
          "description": "<p>May be called\nimmediately within the current execution context, or later.</p>"
        }
      ],
      "examples": [],
      "synonyms": [],
      "originalName": "applyGradualLowpass"
    },
    {
      "name": "applyHannWindow",
      "description": "<p>Apply Hann window in-place</p>",
      "params": [],
      "examples": [],
      "synonyms": [],
      "originalName": "applyHannWindow"
    },
    {
      "name": "appRight",
      "description": "<p>As with <code>appLeft</code>, but <code>whole</code> timespans are instead taken from the\npattern of values, i.e. structure is preserved from the right hand/outer\npattern.</p>",
      "params": [
        {
          "name": "pat_val",
          "type": "Pattern",
          "description": ""
        }
      ],
      "examples": [],
      "synonyms": [],
      "originalName": "appRight"
    },
    {
      "name": "appWhole",
      "description": "<p>Assumes 'this' is a pattern of functions, and given a function to\nresolve wholes, applies a given pattern of values to that\npattern of functions.</p>",
      "params": [
        {
          "name": "whole_func",
          "type": "function",
          "description": ""
        },
        {
          "name": "func",
          "type": "function",
          "description": ""
        }
      ],
      "examples": [],
      "synonyms": [],
      "originalName": "appWhole"
    },
    {
      "name": "arp",
      "description": "<p>Selects indices in in stacked notes.</p>",
      "params": [],
      "examples": [
        "note(\"<[c,eb,g]!2 [c,f,ab] [d,f,ab]>\")\r.arp(\"0 [0,2] 1 [0,2]\")"
      ],
      "synonyms": [],
      "originalName": "arp"
    },
    {
      "name": "arpWith",
      "description": "<p>Selects indices in in stacked notes.</p>",
      "params": [],
      "examples": [
        "note(\"<[c,eb,g]!2 [c,f,ab] [d,f,ab]>\")\r.arpWith(haps => haps[2])"
      ],
      "synonyms": [],
      "originalName": "arpWith"
    },
    {
      "name": "arrange",
      "description": "<p>Allows to arrange multiple patterns together over multiple cycles.\nTakes a variable number of arrays with two elements specifying the number of cycles and the pattern to use.</p>",
      "params": [],
      "examples": [
        "arrange(\r  [4, \"<c a f e>(3,8)\"],\r  [2, \"<g a>(5,8)\"]\r).note()"
      ],
      "synonyms": [],
      "originalName": "arrange"
    },
    {
      "name": "as",
      "description": "<p>Sets properties in a batch.</p>",
      "params": [
        {
          "name": "mapping",
          "type": "String | Array",
          "description": "<p>the control names that are set</p>"
        }
      ],
      "examples": [
        "\"c:.5 a:1 f:.25 e:.8\".as(\"note:clip\")",
        "\"{0@2 0.25 0 0.5 .3 .5}%8\".as(\"begin\").s(\"sax_vib\").clip(1)"
      ],
      "synonyms": [],
      "originalName": "as"
    },
    {
      "name": "asym",
      "description": "<p>Asymmetrical diode distortion</p>",
      "params": [
        {
          "name": "distortion",
          "type": "number | Pattern",
          "description": "<p>amount of distortion to apply</p>"
        },
        {
          "name": "volume",
          "type": "number | Pattern",
          "description": "<p>linear postgain of the distortion</p>"
        }
      ],
      "examples": [],
      "synonyms": [],
      "originalName": "asym"
    },
    {
      "name": "att",
      "description": "<p>Amplitude envelope attack time: Specifies how long it takes for the sound to reach its peak value, relative to the onset.</p>",
      "params": [
        {
          "name": "attack",
          "type": "number | Pattern",
          "description": "<p>time in seconds.</p>"
        }
      ],
      "examples": [
        "note(\"c3 e3 f3 g3\").attack(\"<0 .1 .5>\")"
      ],
      "synonyms": [
        "att"
      ],
      "originalName": "attack"
    },
    {
      "name": "attack",
      "description": "<p>Amplitude envelope attack time: Specifies how long it takes for the sound to reach its peak value, relative to the onset.</p>",
      "params": [
        {
          "name": "attack",
          "type": "number | Pattern",
          "description": "<p>time in seconds.</p>"
        }
      ],
      "examples": [
        "note(\"c3 e3 f3 g3\").attack(\"<0 .1 .5>\")"
      ],
      "synonyms": [
        "att"
      ],
      "originalName": "attack"
    },
    {
      "name": "bandf",
      "description": "<p>Sets the center frequency of the <strong>b</strong>and-<strong>p</strong>ass <strong>f</strong>ilter. When using mininotation, you\ncan also optionally supply the 'bpq' parameter separated by ':'.</p>",
      "params": [
        {
          "name": "frequency",
          "type": "number | Pattern",
          "description": "<p>center frequency</p>"
        }
      ],
      "examples": [
        "s(\"bd sd [~ bd] sd,hh*6\").bpf(\"<1000 2000 4000 8000>\")"
      ],
      "synonyms": [
        "bandf",
        "bp"
      ],
      "originalName": "bpf"
    },
    {
      "name": "bandq",
      "description": "<p>Sets the <strong>b</strong>and-<strong>p</strong>ass <strong>q</strong>-factor (resonance).</p>",
      "params": [
        {
          "name": "q",
          "type": "number | Pattern",
          "description": "<p>q factor</p>"
        }
      ],
      "examples": [
        "s(\"bd sd [~ bd] sd\").bpf(500).bpq(\"<0 1 2 3>\")"
      ],
      "synonyms": [
        "bandq"
      ],
      "originalName": "bpq"
    },
    {
      "name": "bank",
      "description": "<p>Select the sound bank to use. To be used together with <code>s</code>. The bank name (+ &quot;_&quot;) will be prepended to the value of <code>s</code>.</p>",
      "params": [
        {
          "name": "bank",
          "type": "string | Pattern",
          "description": "<p>the name of the bank</p>"
        }
      ],
      "examples": [
        "s(\"bd sd [~ bd] sd\").bank('RolandTR909') // = s(\"RolandTR909_bd RolandTR909_sd\")"
      ],
      "synonyms": [],
      "originalName": "bank"
    },
    {
      "name": "bbexpr",
      "description": "<p>Create byte beats with custom expressions</p>",
      "params": [
        {
          "name": "byteBeatExpression",
          "type": "number | Pattern",
          "description": "<p>bitwise expression for creating bytebeat</p>"
        }
      ],
      "examples": [
        "s(\"bytebeat\").bbexpr('t*(t>>15^t>>66)')"
      ],
      "synonyms": [
        "bbexpr"
      ],
      "originalName": "byteBeatExpression"
    },
    {
      "name": "bbst",
      "description": "<p>Create byte beats with custom expressions</p>",
      "params": [
        {
          "name": "byteBeatStartTime",
          "type": "number | Pattern",
          "description": "<p>in samples (t)</p>"
        }
      ],
      "examples": [
        "note(\"c3!8\".add(\"{0 0 12 0 7 5 3}%8\")).s(\"bytebeat:5\").bbst(\"<3 1>\".mul(10000))._scope()"
      ],
      "synonyms": [
        "bbst"
      ],
      "originalName": "byteBeatStartTime"
    },
    {
      "name": "beat",
      "description": "<p>creates a structure pattern from divisions of a cycle\nespecially useful for creating rhythms</p>",
      "params": [],
      "examples": [
        "s(\"bd\").beat(\"0,7,10\", 16)",
        "s(\"sd\").beat(\"4,12\", 16)"
      ],
      "synonyms": [],
      "originalName": "beat"
    },
    {
      "name": "begin",
      "description": "<p>A pattern of numbers from 0 to 1. Skips the beginning of each sample, e.g. <code>0.25</code> to cut off the first quarter from each sample.</p>",
      "params": [
        {
          "name": "amount",
          "type": "number | Pattern",
          "description": "<p>between 0 and 1, where 1 is the length of the sample</p>"
        }
      ],
      "examples": [
        "samples({ rave: 'rave/AREUREADY.wav' }, 'github:tidalcycles/dirt-samples')\rs(\"rave\").begin(\"<0 .25 .5 .75>\").fast(2)"
      ],
      "synonyms": [],
      "originalName": "begin"
    },
    {
      "name": "berlin",
      "description": "<p>Generates a continuous pattern of [berlin noise](conceived by Jame Coyne and Jade Rowland as a joke but turned out to be surprisingly cool and useful,\nlike perlin noise but with sawtooth waves), in the range 0..1.</p>",
      "params": [],
      "examples": [
        "// ascending arpeggios\rn(\"0!16\".add(berlin.fast(4).mul(14))).scale(\"d:minor\")"
      ],
      "synonyms": [],
      "originalName": "berlin"
    },
    {
      "name": "binary",
      "description": "<p>Creates a pattern from a binary number.</p>",
      "params": [
        {
          "name": "n",
          "type": "number",
          "description": "<p>input number to convert to binary</p>"
        }
      ],
      "examples": [
        "\"hh\".s().struct(binary(5))\r// \"hh\".s().struct(\"1 0 1\")"
      ],
      "synonyms": [],
      "originalName": "binary"
    },
    {
      "name": "binaryN",
      "description": "<p>Creates a pattern from a binary number, padded to n bits long.</p>",
      "params": [
        {
          "name": "n",
          "type": "number",
          "description": "<p>input number to convert to binary</p>"
        },
        {
          "name": "nBits",
          "type": "number",
          "description": "<p>pattern length, defaults to 16</p>"
        }
      ],
      "examples": [
        "\"hh\".s().struct(binaryN(55532, 16))\r// \"hh\".s().struct(\"1 1 0 1 1 0 0 0 1 1 1 0 1 1 0 0\")"
      ],
      "synonyms": [],
      "originalName": "binaryN"
    },
    {
      "name": "bite",
      "description": "<p>Splits a pattern into the given number of slices, and plays them according to a pattern of slice numbers.\nSimilar to <code>slice</code>, but slices up patterns rather than sound samples.</p>",
      "params": [
        {
          "name": "number",
          "type": "number",
          "description": "<p>of slices</p>"
        },
        {
          "name": "slices",
          "type": "number",
          "description": "<p>to play</p>"
        }
      ],
      "examples": [
        "note(\"0 1 2 3 4 5 6 7\".scale('c:mixolydian'))\r.bite(4, \"3 2 1 0\")",
        "sound(\"bd - bd bd*2, - sd:6 - sd:5 sd:1 - [- sd:2] -, hh [- cp:7]\")\r\n  .bank(\"RolandTR909\").speed(1.2)\r\n  .bite(4, \"0 0 [1 2] <3 2> 0 0 [2 1] 3\")"
      ],
      "synonyms": [],
      "originalName": "bite"
    },
    {
      "name": "bp",
      "description": "<p>Sets the center frequency of the <strong>b</strong>and-<strong>p</strong>ass <strong>f</strong>ilter. When using mininotation, you\ncan also optionally supply the 'bpq' parameter separated by ':'.</p>",
      "params": [
        {
          "name": "frequency",
          "type": "number | Pattern",
          "description": "<p>center frequency</p>"
        }
      ],
      "examples": [
        "s(\"bd sd [~ bd] sd,hh*6\").bpf(\"<1000 2000 4000 8000>\")"
      ],
      "synonyms": [
        "bandf",
        "bp"
      ],
      "originalName": "bpf"
    },
    {
      "name": "bpa",
      "description": "<p>Sets the attack duration for the bandpass filter envelope.</p>",
      "params": [
        {
          "name": "attack",
          "type": "number | Pattern",
          "description": "<p>time of the bandpass filter envelope</p>"
        }
      ],
      "examples": [
        "note(\"c2 e2 f2 g2\")\r.sound('sawtooth')\r.bpf(500)\r.bpa(\"<.5 .25 .1 .01>/4\")\r.bpenv(4)"
      ],
      "synonyms": [
        "bpa"
      ],
      "originalName": "bpattack"
    },
    {
      "name": "bpattack",
      "description": "<p>Sets the attack duration for the bandpass filter envelope.</p>",
      "params": [
        {
          "name": "attack",
          "type": "number | Pattern",
          "description": "<p>time of the bandpass filter envelope</p>"
        }
      ],
      "examples": [
        "note(\"c2 e2 f2 g2\")\r.sound('sawtooth')\r.bpf(500)\r.bpa(\"<.5 .25 .1 .01>/4\")\r.bpenv(4)"
      ],
      "synonyms": [
        "bpa"
      ],
      "originalName": "bpattack"
    },
    {
      "name": "bpd",
      "description": "<p>Sets the decay duration for the bandpass filter envelope.</p>",
      "params": [
        {
          "name": "decay",
          "type": "number | Pattern",
          "description": "<p>time of the bandpass filter envelope</p>"
        }
      ],
      "examples": [
        "note(\"c2 e2 f2 g2\")\r.sound('sawtooth')\r.bpf(500)\r.bpd(\"<.5 .25 .1 0>/4\")\r.bps(0.2)\r.bpenv(4)"
      ],
      "synonyms": [
        "bpd"
      ],
      "originalName": "bpdecay"
    },
    {
      "name": "bpdecay",
      "description": "<p>Sets the decay duration for the bandpass filter envelope.</p>",
      "params": [
        {
          "name": "decay",
          "type": "number | Pattern",
          "description": "<p>time of the bandpass filter envelope</p>"
        }
      ],
      "examples": [
        "note(\"c2 e2 f2 g2\")\r.sound('sawtooth')\r.bpf(500)\r.bpd(\"<.5 .25 .1 0>/4\")\r.bps(0.2)\r.bpenv(4)"
      ],
      "synonyms": [
        "bpd"
      ],
      "originalName": "bpdecay"
    },
    {
      "name": "bpe",
      "description": "<p>Sets the bandpass filter envelope modulation depth.</p>",
      "params": [
        {
          "name": "modulation",
          "type": "number | Pattern",
          "description": "<p>depth of the bandpass filter envelope between 0 and <em>n</em></p>"
        }
      ],
      "examples": [
        "note(\"c2 e2 f2 g2\")\r.sound('sawtooth')\r.bpf(500)\r.bpa(.5)\r.bpenv(\"<4 2 1 0 -1 -2 -4>/4\")"
      ],
      "synonyms": [
        "bpe"
      ],
      "originalName": "bpenv"
    },
    {
      "name": "bpenv",
      "description": "<p>Sets the bandpass filter envelope modulation depth.</p>",
      "params": [
        {
          "name": "modulation",
          "type": "number | Pattern",
          "description": "<p>depth of the bandpass filter envelope between 0 and <em>n</em></p>"
        }
      ],
      "examples": [
        "note(\"c2 e2 f2 g2\")\r.sound('sawtooth')\r.bpf(500)\r.bpa(.5)\r.bpenv(\"<4 2 1 0 -1 -2 -4>/4\")"
      ],
      "synonyms": [
        "bpe"
      ],
      "originalName": "bpenv"
    },
    {
      "name": "bpf",
      "description": "<p>Sets the center frequency of the <strong>b</strong>and-<strong>p</strong>ass <strong>f</strong>ilter. When using mininotation, you\ncan also optionally supply the 'bpq' parameter separated by ':'.</p>",
      "params": [
        {
          "name": "frequency",
          "type": "number | Pattern",
          "description": "<p>center frequency</p>"
        }
      ],
      "examples": [
        "s(\"bd sd [~ bd] sd,hh*6\").bpf(\"<1000 2000 4000 8000>\")"
      ],
      "synonyms": [
        "bandf",
        "bp"
      ],
      "originalName": "bpf"
    },
    {
      "name": "bpq",
      "description": "<p>Sets the <strong>b</strong>and-<strong>p</strong>ass <strong>q</strong>-factor (resonance).</p>",
      "params": [
        {
          "name": "q",
          "type": "number | Pattern",
          "description": "<p>q factor</p>"
        }
      ],
      "examples": [
        "s(\"bd sd [~ bd] sd\").bpf(500).bpq(\"<0 1 2 3>\")"
      ],
      "synonyms": [
        "bandq"
      ],
      "originalName": "bpq"
    },
    {
      "name": "bpr",
      "description": "<p>Sets the release time for the bandpass filter envelope.</p>",
      "params": [
        {
          "name": "release",
          "type": "number | Pattern",
          "description": "<p>time of the bandpass filter envelope</p>"
        }
      ],
      "examples": [
        "note(\"c2 e2 f2 g2\")\r.sound('sawtooth')\r.clip(.5)\r.bpf(500)\r.bpenv(4)\r.bpr(\"<.5 .25 .1 0>/4\")\r.release(.5)"
      ],
      "synonyms": [
        "bpr"
      ],
      "originalName": "bprelease"
    },
    {
      "name": "bprelease",
      "description": "<p>Sets the release time for the bandpass filter envelope.</p>",
      "params": [
        {
          "name": "release",
          "type": "number | Pattern",
          "description": "<p>time of the bandpass filter envelope</p>"
        }
      ],
      "examples": [
        "note(\"c2 e2 f2 g2\")\r.sound('sawtooth')\r.clip(.5)\r.bpf(500)\r.bpenv(4)\r.bpr(\"<.5 .25 .1 0>/4\")\r.release(.5)"
      ],
      "synonyms": [
        "bpr"
      ],
      "originalName": "bprelease"
    },
    {
      "name": "bps",
      "description": "<p>Sets the sustain amplitude for the bandpass filter envelope.</p>",
      "params": [
        {
          "name": "sustain",
          "type": "number | Pattern",
          "description": "<p>amplitude of the bandpass filter envelope</p>"
        }
      ],
      "examples": [
        "note(\"c2 e2 f2 g2\")\r.sound('sawtooth')\r.bpf(500)\r.bpd(.5)\r.bps(\"<0 .25 .5 1>/4\")\r.bpenv(4)"
      ],
      "synonyms": [
        "bps"
      ],
      "originalName": "bpsustain"
    },
    {
      "name": "bpsustain",
      "description": "<p>Sets the sustain amplitude for the bandpass filter envelope.</p>",
      "params": [
        {
          "name": "sustain",
          "type": "number | Pattern",
          "description": "<p>amplitude of the bandpass filter envelope</p>"
        }
      ],
      "examples": [
        "note(\"c2 e2 f2 g2\")\r.sound('sawtooth')\r.bpf(500)\r.bpd(.5)\r.bps(\"<0 .25 .5 1>/4\")\r.bpenv(4)"
      ],
      "synonyms": [
        "bps"
      ],
      "originalName": "bpsustain"
    },
    {
      "name": "brak",
      "description": "<p>Returns a new pattern where every other cycle is played once, twice as\nfast, and offset in time by one quarter of a cycle. Creates a kind of\nbreakbeat feel.</p>",
      "params": [],
      "examples": [],
      "synonyms": [],
      "originalName": "brak"
    },
    {
      "name": "brand",
      "description": "<p>A continuous pattern of 0 or 1 (binary random)</p>",
      "params": [],
      "examples": [
        "s(\"hh*10\").pan(brand)"
      ],
      "synonyms": [],
      "originalName": "brand"
    },
    {
      "name": "brandBy",
      "description": "<p>A continuous pattern of 0 or 1 (binary random), with a probability for the value being 1</p>",
      "params": [
        {
          "name": "probability",
          "type": "number",
          "description": "<p>a number between 0 and 1</p>"
        }
      ],
      "examples": [
        "s(\"hh*10\").pan(brandBy(0.2))"
      ],
      "synonyms": [],
      "originalName": "brandBy"
    },
    {
      "name": "byteBeatExpression",
      "description": "<p>Create byte beats with custom expressions</p>",
      "params": [
        {
          "name": "byteBeatExpression",
          "type": "number | Pattern",
          "description": "<p>bitwise expression for creating bytebeat</p>"
        }
      ],
      "examples": [
        "s(\"bytebeat\").bbexpr('t*(t>>15^t>>66)')"
      ],
      "synonyms": [
        "bbexpr"
      ],
      "originalName": "byteBeatExpression"
    },
    {
      "name": "byteBeatStartTime",
      "description": "<p>Create byte beats with custom expressions</p>",
      "params": [
        {
          "name": "byteBeatStartTime",
          "type": "number | Pattern",
          "description": "<p>in samples (t)</p>"
        }
      ],
      "examples": [
        "note(\"c3!8\".add(\"{0 0 12 0 7 5 3}%8\")).s(\"bytebeat:5\").bbst(\"<3 1>\".mul(10000))._scope()"
      ],
      "synonyms": [
        "bbst"
      ],
      "originalName": "byteBeatStartTime"
    },
    {
      "name": "cat",
      "description": "<p>Concatenation: combines a list of patterns, switching between them successively, one per cycle.</p>",
      "params": [],
      "examples": [
        "slowcat(\"e5\", \"b4\", [\"d5\", \"c5\"])"
      ],
      "synonyms": [
        "cat"
      ],
      "originalName": "slowcat"
    },
    {
      "name": "ccn",
      "description": "<p>MIDI control number: Sends a MIDI control change message.</p>",
      "params": [
        {
          "name": "MIDI",
          "type": "number | Pattern",
          "description": "<p>control number (0-127)</p>"
        }
      ],
      "examples": [],
      "synonyms": [],
      "originalName": "ccn"
    },
    {
      "name": "ccv",
      "description": "<p>MIDI control value: Sends a MIDI control change message.</p>",
      "params": [
        {
          "name": "MIDI",
          "type": "number | Pattern",
          "description": "<p>control value (0-127)</p>"
        }
      ],
      "examples": [],
      "synonyms": [],
      "originalName": "ccv"
    },
    {
      "name": "ceil",
      "description": "<p>Assumes a numerical pattern. Returns a new pattern with all values set to\ntheir mathematical ceiling. E.g. <code>3.2</code> replaced with <code>4</code>, and <code>-4.2</code>\nreplaced with <code>-4</code>.</p>",
      "params": [],
      "examples": [
        "note(\"42 42.1 42.5 43\".ceil())"
      ],
      "synonyms": [],
      "originalName": "ceil"
    },
    {
      "name": "ch",
      "description": "<p>Allows you to set the output channels on the interface</p>",
      "params": [
        {
          "name": "channels",
          "type": "number | Pattern",
          "description": "<p>pattern the output channels</p>"
        }
      ],
      "examples": [
        "note(\"e a d b g\").channels(\"3:4\")"
      ],
      "synonyms": [
        "ch"
      ],
      "originalName": "channels"
    },
    {
      "name": "channel",
      "description": "<p>Choose the channel the pattern is sent to in superdirt</p>",
      "params": [
        {
          "name": "channel",
          "type": "number | Pattern",
          "description": "<p>channel number</p>"
        }
      ],
      "examples": [],
      "synonyms": [],
      "originalName": "channel"
    },
    {
      "name": "channels",
      "description": "<p>Allows you to set the output channels on the interface</p>",
      "params": [
        {
          "name": "channels",
          "type": "number | Pattern",
          "description": "<p>pattern the output channels</p>"
        }
      ],
      "examples": [
        "note(\"e a d b g\").channels(\"3:4\")"
      ],
      "synonyms": [
        "ch"
      ],
      "originalName": "channels"
    },
    {
      "name": "chebyshev",
      "description": "<p>Distortion via Chebyshev polynomials</p>",
      "params": [
        {
          "name": "distortion",
          "type": "number | Pattern",
          "description": "<p>amount of distortion to apply</p>"
        },
        {
          "name": "volume",
          "type": "number | Pattern",
          "description": "<p>linear postgain of the distortion</p>"
        }
      ],
      "examples": [],
      "synonyms": [],
      "originalName": "chebyshev"
    },
    {
      "name": "choose",
      "description": "<p>Chooses randomly from the given list of elements.</p>",
      "params": [
        {
          "name": "xs",
          "type": "any",
          "description": "<p>values / patterns to choose from.</p>"
        }
      ],
      "examples": [
        "note(\"c2 g2!2 d2 f1\").s(choose(\"sine\", \"triangle\", \"bd:6\"))"
      ],
      "synonyms": [],
      "originalName": "choose"
    },
    {
      "name": "choose2",
      "description": "<p>As with choose, but the pattern that this method is called on should be\nin the range -1 .. 1</p>",
      "params": [
        {
          "name": "xs",
          "type": "any",
          "description": ""
        }
      ],
      "examples": [],
      "synonyms": [],
      "originalName": "choose2"
    },
    {
      "name": "chooseCycles",
      "description": "<p>Picks one of the elements at random each cycle.</p>",
      "params": [],
      "examples": [
        "chooseCycles(\"bd\", \"hh\", \"sd\").s().fast(8)",
        "s(\"bd | hh | sd\").fast(8)"
      ],
      "synonyms": [
        "randcat"
      ],
      "originalName": "chooseCycles"
    },
    {
      "name": "chooseInWith",
      "description": "<p>As with {chooseWith}, but the structure comes from the chosen values, rather\nthan the pattern you're using to choose with.</p>",
      "params": [
        {
          "name": "pat",
          "type": "Pattern",
          "description": ""
        },
        {
          "name": "xs",
          "type": "*",
          "description": ""
        }
      ],
      "examples": [],
      "synonyms": [],
      "originalName": "chooseInWith"
    },
    {
      "name": "chooseWith",
      "description": "<p>Choose from the list of values (or patterns of values) using the given\npattern of numbers, which should be in the range of 0..1</p>",
      "params": [
        {
          "name": "pat",
          "type": "Pattern",
          "description": ""
        },
        {
          "name": "xs",
          "type": "*",
          "description": ""
        }
      ],
      "examples": [
        "note(\"c2 g2!2 d2 f1\").s(chooseWith(sine.fast(2), [\"sawtooth\", \"triangle\", \"bd:6\"]))"
      ],
      "synonyms": [],
      "originalName": "chooseWith"
    },
    {
      "name": "chop",
      "description": "<p>Cuts each sample into the given number of parts, allowing you to explore a technique known as 'granular synthesis'.\nIt turns a pattern of samples into a pattern of parts of samples.</p>",
      "params": [],
      "examples": [
        "samples({ rhodes: 'https://cdn.freesound.org/previews/132/132051_316502-lq.mp3' })\rs(\"rhodes\")\r .chop(4)\r .rev() // reverse order of chops\r .loopAt(2) // fit sample into 2 cycles"
      ],
      "synonyms": [],
      "originalName": "chop"
    },
    {
      "name": "chord",
      "description": "<p>The chord to voice</p>",
      "params": [
        {
          "name": "symbols",
          "type": "string | Pattern",
          "description": "<p>chord symbols to voice e.g., C, Eb, Fm7, G7. The symbols can be defined via addVoicings</p>"
        }
      ],
      "examples": [
        "chord(\"<Am C D F Am E Am E>\").voicing()"
      ],
      "synonyms": [],
      "originalName": "chord"
    },
    {
      "name": "chorus",
      "description": "<p>mix control for the chorus effect</p>",
      "params": [
        {
          "name": "chorus",
          "type": "string | Pattern",
          "description": "<p>mix amount between 0 and 1</p>"
        }
      ],
      "examples": [
        "note(\"d d a# a\").s(\"sawtooth\").chorus(.5)"
      ],
      "synonyms": [],
      "originalName": "chorus"
    },
    {
      "name": "chunk",
      "description": "<p>Divides a pattern into a given number of parts, then cycles through those parts in turn, applying the given function to each part in turn (one part per cycle).</p>",
      "params": [],
      "examples": [
        "\"0 1 2 3\".chunk(4, x=>x.add(7))\r.scale(\"A:minor\").note()"
      ],
      "synonyms": [
        "slowChunk",
        "slowchunk"
      ],
      "originalName": "chunk"
    },
    {
      "name": "chunkback",
      "description": "<p>Like <code>chunk</code>, but cycles through the parts in reverse order. Known as chunk' in tidalcycles</p>",
      "params": [],
      "examples": [
        "\"0 1 2 3\".chunkBack(4, x=>x.add(7))\r.scale(\"A:minor\").note()"
      ],
      "synonyms": [
        "chunkback"
      ],
      "originalName": "chunkBack"
    },
    {
      "name": "chunkBack",
      "description": "<p>Like <code>chunk</code>, but cycles through the parts in reverse order. Known as chunk' in tidalcycles</p>",
      "params": [],
      "examples": [
        "\"0 1 2 3\".chunkBack(4, x=>x.add(7))\r.scale(\"A:minor\").note()"
      ],
      "synonyms": [
        "chunkback"
      ],
      "originalName": "chunkBack"
    },
    {
      "name": "chunkbackinto",
      "description": "<p>Like <code>chunkInto</code>, but moves backwards through the chunks.</p>",
      "params": [],
      "examples": [
        "sound(\"bd sd ht lt bd - cp lt\").chunkInto(4, hurry(2))\r  .bank(\"tr909\")"
      ],
      "synonyms": [
        "chunkbackinto"
      ],
      "originalName": "chunkBackInto"
    },
    {
      "name": "chunkBackInto",
      "description": "<p>Like <code>chunkInto</code>, but moves backwards through the chunks.</p>",
      "params": [],
      "examples": [
        "sound(\"bd sd ht lt bd - cp lt\").chunkInto(4, hurry(2))\r  .bank(\"tr909\")"
      ],
      "synonyms": [
        "chunkbackinto"
      ],
      "originalName": "chunkBackInto"
    },
    {
      "name": "chunkinto",
      "description": "<p>Like <code>chunk</code>, but the function is applied to a looped subcycle of the source pattern.</p>",
      "params": [],
      "examples": [
        "sound(\"bd sd ht lt bd - cp lt\").chunkInto(4, hurry(2))\r  .bank(\"tr909\")"
      ],
      "synonyms": [
        "chunkinto"
      ],
      "originalName": "chunkInto"
    },
    {
      "name": "chunkInto",
      "description": "<p>Like <code>chunk</code>, but the function is applied to a looped subcycle of the source pattern.</p>",
      "params": [],
      "examples": [
        "sound(\"bd sd ht lt bd - cp lt\").chunkInto(4, hurry(2))\r  .bank(\"tr909\")"
      ],
      "synonyms": [
        "chunkinto"
      ],
      "originalName": "chunkInto"
    },
    {
      "name": "chyx",
      "description": "<p>BYTE BEATS</p>",
      "params": [],
      "examples": [],
      "synonyms": [],
      "originalName": "chyx"
    },
    {
      "name": "clip",
      "description": "<p>Multiplies the duration with the given number. Also cuts samples off at the end if they exceed the duration.</p>",
      "params": [
        {
          "name": "factor",
          "type": "number | Pattern",
          "description": "<blockquote>\n<p>= 0</p>\n</blockquote>"
        }
      ],
      "examples": [
        "note(\"c a f e\").s(\"piano\").clip(\"<.5 1 2>\")"
      ],
      "synonyms": [
        "legato"
      ],
      "originalName": "clip"
    },
    {
      "name": "coarse",
      "description": "<p>Fake-resampling for lowering the sample rate. Caution: This effect seems to only work in chromium based browsers</p>",
      "params": [
        {
          "name": "factor",
          "type": "number | Pattern",
          "description": "<p>1 for original 2 for half, 3 for a third and so on.</p>"
        }
      ],
      "examples": [
        "s(\"bd sd [~ bd] sd,hh*8\").coarse(\"<1 4 8 16 32>\")"
      ],
      "synonyms": [],
      "originalName": "coarse"
    },
    {
      "name": "color",
      "description": "<p>Sets the color of the hap in visualizations like pianoroll or highlighting.</p>",
      "params": [
        {
          "name": "color",
          "type": "string",
          "description": "<p>Hexadecimal or CSS color name</p>"
        }
      ],
      "examples": [],
      "synonyms": [
        "colour"
      ],
      "originalName": "color"
    },
    {
      "name": "colour",
      "description": "<p>Sets the color of the hap in visualizations like pianoroll or highlighting.</p>",
      "params": [
        {
          "name": "color",
          "type": "string",
          "description": "<p>Hexadecimal or CSS color name</p>"
        }
      ],
      "examples": [],
      "synonyms": [
        "colour"
      ],
      "originalName": "color"
    },
    {
      "name": "compress",
      "description": "<p>Compress each cycle into the given timespan, leaving a gap</p>",
      "params": [],
      "examples": [
        "cat(\r  s(\"bd sd\").compress(.25,.75),\r  s(\"~ bd sd ~\")\r)"
      ],
      "synonyms": [],
      "originalName": "compress"
    },
    {
      "name": "compressor",
      "description": "<p>Dynamics Compressor. The params are <code>compressor(&quot;threshold:ratio:knee:attack:release&quot;)</code>\nMore info <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/DynamicsCompressorNode?retiredLocale=de#instance_properties\">here</a></p>",
      "params": [],
      "examples": [
        "s(\"bd sd [~ bd] sd,hh*8\")\r.compressor(\"-20:20:10:.002:.02\")"
      ],
      "synonyms": [],
      "originalName": "compressor"
    },
    {
      "name": "computeMagnitudes",
      "description": "<p>Compute squared magnitudes for peak finding</p>",
      "params": [],
      "examples": [],
      "synonyms": [],
      "originalName": "computeMagnitudes"
    },
    {
      "name": "contract",
      "description": "<p><em>Experimental</em></p>\n<p>Contracts the step size of the pattern by the given factor. See also <code>expand</code>.</p>",
      "params": [],
      "examples": [
        "sound(\"tha dhi thom nam\").bank(\"mridangam\").contract(\"3 2 1 1 2 3\").pace(8)"
      ],
      "synonyms": [],
      "originalName": "contract"
    },
    {
      "name": "control",
      "description": "<p>MIDI control: Sends a MIDI control change message.</p>",
      "params": [
        {
          "name": "MIDI",
          "type": "number | Pattern",
          "description": "<p>control number (0-127)</p>"
        },
        {
          "name": "MIDI",
          "type": "number | Pattern",
          "description": "<p>controller value (0-127)</p>"
        }
      ],
      "examples": [],
      "synonyms": [],
      "originalName": "control"
    },
    {
      "name": "cosine",
      "description": "<p>A cosine signal between 0 and 1.</p>",
      "params": [],
      "examples": [
        "n(stack(sine,cosine).segment(16).range(0,15))\r.scale(\"C:minor\")"
      ],
      "synonyms": [],
      "originalName": "cosine"
    },
    {
      "name": "cosine2",
      "description": "<p>A cosine signal between -1 and 1 (like <code>cosine</code>, but bipolar).</p>",
      "params": [],
      "examples": [],
      "synonyms": [],
      "originalName": "cosine2"
    },
    {
      "name": "cpm",
      "description": "<p>Plays the pattern at the given cycles per minute.</p>",
      "params": [],
      "examples": [
        "s(\"<bd sd>,hh*2\").cpm(90) // = 90 bpm"
      ],
      "synonyms": [],
      "originalName": "cpm"
    },
    {
      "name": "crossfade",
      "description": "<p>Equal Power Crossfade function.\nSmoothly transitions between signals A and B, maintaining consistent perceived loudness.</p>",
      "params": [
        {
          "name": "a",
          "type": "number",
          "description": "<p>Signal A (can be a single value or an array value in buffer processing).</p>"
        },
        {
          "name": "b",
          "type": "number",
          "description": "<p>Signal B (can be a single value or an array value in buffer processing).</p>"
        },
        {
          "name": "m",
          "type": "number",
          "description": "<p>Crossfade parameter (0.0 = all A, 1.0 = all B, 0.5 = equal mix).</p>"
        }
      ],
      "examples": [],
      "synonyms": [],
      "originalName": "crossfade"
    },
    {
      "name": "crush",
      "description": "<p>Bit crusher effect.</p>",
      "params": [
        {
          "name": "depth",
          "type": "number | Pattern",
          "description": "<p>between 1 (for drastic reduction in bit-depth) to 16 (for barely no reduction).</p>"
        }
      ],
      "examples": [
        "s(\"<bd sd>,hh*3\").fast(2).crush(\"<16 8 7 6 5 4 3 2>\")"
      ],
      "synonyms": [],
      "originalName": "crush"
    },
    {
      "name": "csoundm",
      "description": "<p>Sends notes to Csound for rendering with MIDI semantics. The hap value is\ntranslated to these Csound pfields:</p>\n<p>p1 -- Csound instrument either as a number (1-based, can be a fraction),\nor as a string name.\np2 -- time in beats (usually seconds) from start of performance.\np3 -- duration in beats (usually seconds).\np4 -- MIDI key number (as a real number, not an integer but in [0, 127].\np5 -- MIDI velocity (as a real number, not an integer but in [0, 127].\np6 -- Strudel controls, as a string.</p>",
      "params": [],
      "examples": [],
      "synonyms": [],
      "originalName": "csoundm"
    },
    {
      "name": "ctf",
      "description": "<p>Applies the cutoff frequency of the <strong>l</strong>ow-<strong>p</strong>ass <strong>f</strong>ilter.</p>\n<p>When using mininotation, you can also optionally add the 'lpq' parameter, separated by ':'.</p>",
      "params": [
        {
          "name": "frequency",
          "type": "number | Pattern",
          "description": "<p>audible between 0 and 20000</p>"
        }
      ],
      "examples": [
        "s(\"bd sd [~ bd] sd,hh*6\").lpf(\"<4000 2000 1000 500 200 100>\")",
        "s(\"bd*16\").lpf(\"1000:0 1000:10 1000:20 1000:30\")"
      ],
      "synonyms": [
        "cutoff",
        "ctf",
        "lp"
      ],
      "originalName": "lpf"
    },
    {
      "name": "cubic",
      "description": "<p>Cubic polynomial distortion</p>",
      "params": [
        {
          "name": "distortion",
          "type": "number | Pattern",
          "description": "<p>amount of distortion to apply</p>"
        },
        {
          "name": "volume",
          "type": "number | Pattern",
          "description": "<p>linear postgain of the distortion</p>"
        }
      ],
      "examples": [],
      "synonyms": [],
      "originalName": "cubic"
    },
    {
      "name": "cut",
      "description": "<p>In the style of classic drum-machines, <code>cut</code> will stop a playing sample as soon as another samples with in same cutgroup is to be played. An example would be an open hi-hat followed by a closed one, essentially muting the open.</p>",
      "params": [
        {
          "name": "group",
          "type": "number | Pattern",
          "description": "<p>cut group number</p>"
        }
      ],
      "examples": [
        "s(\"[oh hh]*4\").cut(1)"
      ],
      "synonyms": [],
      "originalName": "cut"
    },
    {
      "name": "cutoff",
      "description": "<p>Applies the cutoff frequency of the <strong>l</strong>ow-<strong>p</strong>ass <strong>f</strong>ilter.</p>\n<p>When using mininotation, you can also optionally add the 'lpq' parameter, separated by ':'.</p>",
      "params": [
        {
          "name": "frequency",
          "type": "number | Pattern",
          "description": "<p>audible between 0 and 20000</p>"
        }
      ],
      "examples": [
        "s(\"bd sd [~ bd] sd,hh*6\").lpf(\"<4000 2000 1000 500 200 100>\")",
        "s(\"bd*16\").lpf(\"1000:0 1000:10 1000:20 1000:30\")"
      ],
      "synonyms": [
        "cutoff",
        "ctf",
        "lp"
      ],
      "originalName": "lpf"
    },
    {
      "name": "dec",
      "description": "<p>Amplitude envelope decay time: the time it takes after the attack time to reach the sustain level.\nNote that the decay is only audible if the sustain value is lower than 1.</p>",
      "params": [
        {
          "name": "time",
          "type": "number | Pattern",
          "description": "<p>decay time in seconds</p>"
        }
      ],
      "examples": [
        "note(\"c3 e3 f3 g3\").decay(\"<.1 .2 .3 .4>\").sustain(0)"
      ],
      "synonyms": [
        "dec"
      ],
      "originalName": "decay"
    },
    {
      "name": "decay",
      "description": "<p>Amplitude envelope decay time: the time it takes after the attack time to reach the sustain level.\nNote that the decay is only audible if the sustain value is lower than 1.</p>",
      "params": [
        {
          "name": "time",
          "type": "number | Pattern",
          "description": "<p>decay time in seconds</p>"
        }
      ],
      "examples": [
        "note(\"c3 e3 f3 g3\").decay(\"<.1 .2 .3 .4>\").sustain(0)"
      ],
      "synonyms": [
        "dec"
      ],
      "originalName": "decay"
    },
    {
      "name": "defaultmidimap",
      "description": "<p>configures the default midimap, which is used when no &quot;midimap&quot; port is set</p>",
      "params": [],
      "examples": [
        "defaultmidimap({ lpf: 74 })\r$: note(\"c a f e\").midi();\r$: lpf(sine.slow(4).segment(16)).midi();"
      ],
      "synonyms": [],
      "originalName": "defaultmidimap"
    },
    {
      "name": "defragmentHaps",
      "description": "<p>Combines adjacent haps with the same value and whole.  Only\nintended for use in tests.</p>",
      "params": [],
      "examples": [],
      "synonyms": [],
      "originalName": "defragmentHaps"
    },
    {
      "name": "degrade",
      "description": "<p>Randomly removes 50% of events from the pattern. Shorthand for <code>.degradeBy(0.5)</code></p>",
      "params": [],
      "examples": [
        "s(\"hh*8\").degrade()",
        "s(\"[hh?]*8\")"
      ],
      "synonyms": [],
      "originalName": "degrade"
    },
    {
      "name": "degradeBy",
      "description": "<p>Randomly removes events from the pattern by a given amount.\n0 = 0% chance of removal\n1 = 100% chance of removal</p>",
      "params": [
        {
          "name": "amount",
          "type": "number",
          "description": "<p>a number between 0 and 1</p>"
        }
      ],
      "examples": [
        "s(\"hh*8\").degradeBy(0.2)",
        "s(\"[hh?0.2]*8\")",
        "//beat generator\rs(\"bd\").segment(16).degradeBy(.5).ribbon(16,1)"
      ],
      "synonyms": [],
      "originalName": "degradeBy"
    },
    {
      "name": "delay",
      "description": "<p>Sets the level of the delay signal.</p>\n<p>When using mininotation, you can also optionally add the 'delaytime' and 'delayfeedback' parameter,\nseparated by ':'.</p>",
      "params": [
        {
          "name": "level",
          "type": "number | Pattern",
          "description": "<p>between 0 and 1</p>"
        }
      ],
      "examples": [
        "s(\"bd bd\").delay(\"<0 .25 .5 1>\")",
        "s(\"bd bd\").delay(\"0.65:0.25:0.9 0.65:0.125:0.7\")"
      ],
      "synonyms": [],
      "originalName": "delay"
    },
    {
      "name": "delayfb",
      "description": "<p>Sets the level of the signal that is fed back into the delay.\nCaution: Values &gt;= 1 will result in a signal that gets louder and louder! Don't do it</p>",
      "params": [
        {
          "name": "feedback",
          "type": "number | Pattern",
          "description": "<p>between 0 and 1</p>"
        }
      ],
      "examples": [
        "s(\"bd\").delay(.25).delayfeedback(\"<.25 .5 .75 1>\")"
      ],
      "synonyms": [
        "delayfb",
        "dfb"
      ],
      "originalName": "delayfeedback"
    },
    {
      "name": "delayfeedback",
      "description": "<p>Sets the level of the signal that is fed back into the delay.\nCaution: Values &gt;= 1 will result in a signal that gets louder and louder! Don't do it</p>",
      "params": [
        {
          "name": "feedback",
          "type": "number | Pattern",
          "description": "<p>between 0 and 1</p>"
        }
      ],
      "examples": [
        "s(\"bd\").delay(.25).delayfeedback(\"<.25 .5 .75 1>\")"
      ],
      "synonyms": [
        "delayfb",
        "dfb"
      ],
      "originalName": "delayfeedback"
    },
    {
      "name": "delayspeed",
      "description": "<p>Sets the time of the delay effect.</p>",
      "params": [
        {
          "name": "delayspeed",
          "type": "number | Pattern",
          "description": "<p>controls the pitch of the delay feedback</p>"
        }
      ],
      "examples": [
        "note(\"d d a# a\".fast(2)).s(\"sawtooth\").delay(.8).delaytime(1/2).delayspeed(\"<2 .5 -1 -2>\")"
      ],
      "synonyms": [
        "delayt",
        "dt"
      ],
      "originalName": "delayspeed"
    },
    {
      "name": "delaysync",
      "description": "<p>Sets the time of the delay effect in cycles.</p>",
      "params": [
        {
          "name": "cycles",
          "type": "number | Pattern",
          "description": "<p>delay length in cycles</p>"
        }
      ],
      "examples": [
        "s(\"bd bd\").delay(.25).delaysync(\"<1 2 3 5>\".div(8))"
      ],
      "synonyms": [
        "delayt",
        "dt"
      ],
      "originalName": "delaysync"
    },
    {
      "name": "delayt",
      "description": "<p>Sets the time of the delay effect.</p>",
      "params": [
        {
          "name": "delayspeed",
          "type": "number | Pattern",
          "description": "<p>controls the pitch of the delay feedback</p>"
        }
      ],
      "examples": [
        "note(\"d d a# a\".fast(2)).s(\"sawtooth\").delay(.8).delaytime(1/2).delayspeed(\"<2 .5 -1 -2>\")"
      ],
      "synonyms": [
        "delayt",
        "dt"
      ],
      "originalName": "delayspeed"
    },
    {
      "name": "density",
      "description": "<p>Noise crackle density</p>",
      "params": [
        {
          "name": "density",
          "type": "number | Pattern",
          "description": "<p>between 0 and x</p>"
        }
      ],
      "examples": [
        "s(\"crackle*4\").density(\"<0.01 0.04 0.2 0.5>\".slow(4))"
      ],
      "synonyms": [],
      "originalName": "density"
    },
    {
      "name": "det",
      "description": "<p>Set detune for stacked voices of supported oscillators</p>",
      "params": [
        {
          "name": "amount",
          "type": "number | Pattern",
          "description": ""
        }
      ],
      "examples": [
        "note(\"d f a a# a d3\").fast(2).s(\"supersaw\").detune(\"<.1 .2 .5 24.1>\")"
      ],
      "synonyms": [
        "det"
      ],
      "originalName": "detune"
    },
    {
      "name": "detune",
      "description": "<p>Set detune for stacked voices of supported oscillators</p>",
      "params": [
        {
          "name": "amount",
          "type": "number | Pattern",
          "description": ""
        }
      ],
      "examples": [
        "note(\"d f a a# a d3\").fast(2).s(\"supersaw\").detune(\"<.1 .2 .5 24.1>\")"
      ],
      "synonyms": [
        "det"
      ],
      "originalName": "detune"
    },
    {
      "name": "dfb",
      "description": "<p>Sets the level of the signal that is fed back into the delay.\nCaution: Values &gt;= 1 will result in a signal that gets louder and louder! Don't do it</p>",
      "params": [
        {
          "name": "feedback",
          "type": "number | Pattern",
          "description": "<p>between 0 and 1</p>"
        }
      ],
      "examples": [
        "s(\"bd\").delay(.25).delayfeedback(\"<.25 .5 .75 1>\")"
      ],
      "synonyms": [
        "delayfb",
        "dfb"
      ],
      "originalName": "delayfeedback"
    },
    {
      "name": "dictionary",
      "description": "<p>Which dictionary to use for the voicings. This falls back to the default dictionary if not provided</p>",
      "params": [
        {
          "name": "dictionaryName",
          "type": "string",
          "description": "<p>which dictionary (having been defined with <code>addVoicings</code>) to use</p>"
        }
      ],
      "examples": [
        "addVoicings('house', {\r\n'': ['7 12 16', '0 7 16', '4 7 12'],\r\n'm': ['0 3 7']\r\n})\r\nchord(\"<Am C D F Am E Am E>\")\r\n.dict('house').anchor(66)\r\n.voicing().room(.5)"
      ],
      "synonyms": [],
      "originalName": "dictionary"
    },
    {
      "name": "diode",
      "description": "<p>Diode-emulating distortion</p>",
      "params": [
        {
          "name": "distortion",
          "type": "number | Pattern",
          "description": "<p>amount of distortion to apply</p>"
        },
        {
          "name": "volume",
          "type": "number | Pattern",
          "description": "<p>linear postgain of the distortion</p>"
        }
      ],
      "examples": [],
      "synonyms": [],
      "originalName": "diode"
    },
    {
      "name": "discreteOnly",
      "description": "<p>Returns a new pattern, with 'continuous' haps (those without 'whole'\ntimespans) removed from query results.</p>",
      "params": [],
      "examples": [],
      "synonyms": [],
      "originalName": "discreteOnly"
    },
    {
      "name": "dist",
      "description": "<p>Wave shaping distortion. CAUTION: it can get loud.\nSecond option in optional array syntax (ex: &quot;.9:.5&quot;) applies a postgain to the output. Third option sets the waveshaping type.\nMost useful values are usually between 0 and 10 (depending on source gain). If you are feeling adventurous, you can turn it up to 11 and beyond ;)</p>",
      "params": [
        {
          "name": "distortion",
          "type": "number | Pattern",
          "description": "<p>amount of distortion to apply</p>"
        },
        {
          "name": "volume",
          "type": "number | Pattern",
          "description": "<p>linear postgain of the distortion</p>"
        },
        {
          "name": "type",
          "type": "number | string | Pattern",
          "description": "<p>type of distortion to apply</p>"
        }
      ],
      "examples": [
        "s(\"bd sd [~ bd] sd,hh*8\").distort(\"<0 2 3 10:.5>\")",
        "note(\"d1!8\").s(\"sine\").penv(36).pdecay(.12).decay(.23).distort(\"8:.4\")",
        "s(\"bd:4*4\").bank(\"tr808\").distort(\"3:0.5:diode\")"
      ],
      "synonyms": [
        "dist"
      ],
      "originalName": "distort"
    },
    {
      "name": "distort",
      "description": "<p>Wave shaping distortion. CAUTION: it can get loud.\nSecond option in optional array syntax (ex: &quot;.9:.5&quot;) applies a postgain to the output. Third option sets the waveshaping type.\nMost useful values are usually between 0 and 10 (depending on source gain). If you are feeling adventurous, you can turn it up to 11 and beyond ;)</p>",
      "params": [
        {
          "name": "distortion",
          "type": "number | Pattern",
          "description": "<p>amount of distortion to apply</p>"
        },
        {
          "name": "volume",
          "type": "number | Pattern",
          "description": "<p>linear postgain of the distortion</p>"
        },
        {
          "name": "type",
          "type": "number | string | Pattern",
          "description": "<p>type of distortion to apply</p>"
        }
      ],
      "examples": [
        "s(\"bd sd [~ bd] sd,hh*8\").distort(\"<0 2 3 10:.5>\")",
        "note(\"d1!8\").s(\"sine\").penv(36).pdecay(.12).decay(.23).distort(\"8:.4\")",
        "s(\"bd:4*4\").bank(\"tr808\").distort(\"3:0.5:diode\")"
      ],
      "synonyms": [
        "dist"
      ],
      "originalName": "distort"
    },
    {
      "name": "distorttype",
      "description": "<p>Type of waveshaping distortion to apply.</p>",
      "params": [
        {
          "name": "type",
          "type": "number | string | Pattern",
          "description": "<p>type of distortion to apply</p>"
        }
      ],
      "examples": [
        "s(\"bd*4\").bank(\"tr909\").distort(2).distorttype(\"<0 1 2>\")",
        "s(\"sine\").note(\"F1*2\").release(1)\r  .penv(24).pdecay(0.05)\r  .distort(rand.range(1, 8))\r  .distorttype(\"<fold chebyshev scurve diode asym sinefold>\")"
      ],
      "synonyms": [
        "disttype"
      ],
      "originalName": "distorttype"
    },
    {
      "name": "distortvol",
      "description": "<p>Postgain for waveshaping distortion.</p>",
      "params": [
        {
          "name": "volume",
          "type": "number | Pattern",
          "description": "<p>linear postgain of the distortion</p>"
        }
      ],
      "examples": [
        "s(\"bd*4\").bank(\"tr909\").distort(2).distortvol(0.8)"
      ],
      "synonyms": [
        "distvol"
      ],
      "originalName": "distortvol"
    },
    {
      "name": "disttype",
      "description": "<p>Type of waveshaping distortion to apply.</p>",
      "params": [
        {
          "name": "type",
          "type": "number | string | Pattern",
          "description": "<p>type of distortion to apply</p>"
        }
      ],
      "examples": [
        "s(\"bd*4\").bank(\"tr909\").distort(2).distorttype(\"<0 1 2>\")",
        "s(\"sine\").note(\"F1*2\").release(1)\r  .penv(24).pdecay(0.05)\r  .distort(rand.range(1, 8))\r  .distorttype(\"<fold chebyshev scurve diode asym sinefold>\")"
      ],
      "synonyms": [
        "disttype"
      ],
      "originalName": "distorttype"
    },
    {
      "name": "distvol",
      "description": "<p>Postgain for waveshaping distortion.</p>",
      "params": [
        {
          "name": "volume",
          "type": "number | Pattern",
          "description": "<p>linear postgain of the distortion</p>"
        }
      ],
      "examples": [
        "s(\"bd*4\").bank(\"tr909\").distort(2).distortvol(0.8)"
      ],
      "synonyms": [
        "distvol"
      ],
      "originalName": "distortvol"
    },
    {
      "name": "div",
      "description": "<p>Divides each number by the given factor.</p>",
      "params": [],
      "examples": [],
      "synonyms": [],
      "originalName": "div"
    },
    {
      "name": "djf",
      "description": "<p>DJ filter, below 0.5 is low pass filter, above is high pass filter.</p>",
      "params": [
        {
          "name": "cutoff",
          "type": "number | Pattern",
          "description": "<p>below 0.5 is low pass filter, above is high pass filter</p>"
        }
      ],
      "examples": [
        "n(irand(16).seg(8)).scale(\"d:phrygian\").s(\"supersaw\").djf(\"<.5 .3 .2 .75>\")"
      ],
      "synonyms": [],
      "originalName": "djf"
    },
    {
      "name": "DoughVoice",
      "description": "",
      "params": [
        {
          "name": "value",
          "type": "DoughVoice",
          "description": ""
        }
      ],
      "examples": [],
      "synonyms": [],
      "originalName": "DoughVoice"
    },
    {
      "name": "drawLine",
      "description": "<p>Intended for a debugging, drawLine renders the pattern as a string, where each character represents the same time span.\nShould only be used with single characters as values, otherwise the character slots will be messed up.\nCharacter legend:</p>\n<ul>\n<li>&quot;|&quot; cycle separator</li>\n<li>&quot;-&quot; hold previous value</li>\n<li>&quot;.&quot; silence</li>\n</ul>",
      "params": [
        {
          "name": "pattern",
          "type": "Pattern",
          "description": "<p>the pattern to use</p>"
        },
        {
          "name": "chars",
          "type": "number",
          "description": "<p>max number of characters (approximately)</p>"
        }
      ],
      "examples": [
        "const line = drawLine(\"0 [1 2 3]\", 10); // |0--123|0--123\rconsole.log(line);\rsilence;"
      ],
      "synonyms": [],
      "originalName": "drawLine"
    },
    {
      "name": "drive",
      "description": "<p>Filter overdrive for supported filter types</p>",
      "params": [
        {
          "name": "amount",
          "type": "number | Pattern",
          "description": ""
        }
      ],
      "examples": [
        "note(\"{f g g c d a a#}%16\".sub(17)).s(\"supersaw\").lpenv(8).lpf(150).lpq(.8).ftype('ladder').drive(\"<.5 4>\")"
      ],
      "synonyms": [],
      "originalName": "drive"
    },
    {
      "name": "drop",
      "description": "<p><em>Experimental</em></p>\n<p>Drops the given number of steps from a pattern.\nA positive number will drop steps from the start of a pattern, and a negative number from the end.</p>",
      "params": [],
      "examples": [
        "\"tha dhi thom nam\".drop(\"1\").sound().bank(\"mridangam\")",
        "\"tha dhi thom nam\".drop(\"-1\").sound().bank(\"mridangam\")",
        "\"tha dhi thom nam\".drop(\"0 1 2 3\").sound().bank(\"mridangam\")",
        "\"tha dhi thom nam\".drop(\"0 -1 -2 -3\").sound().bank(\"mridangam\")"
      ],
      "synonyms": [],
      "originalName": "drop"
    },
    {
      "name": "dry",
      "description": "<p>Set dryness of reverb. See <code>room</code> and <code>size</code> for more information about reverb.</p>",
      "params": [
        {
          "name": "dry",
          "type": "number | Pattern",
          "description": "<p>0 = wet, 1 = dry</p>"
        }
      ],
      "examples": [
        "n(\"[0,3,7](3,8)\").s(\"superpiano\").room(.7).dry(\"<0 .5 .75 1>\").osc()"
      ],
      "synonyms": [],
      "originalName": "dry"
    },
    {
      "name": "dt",
      "description": "<p>Sets the time of the delay effect.</p>",
      "params": [
        {
          "name": "delayspeed",
          "type": "number | Pattern",
          "description": "<p>controls the pitch of the delay feedback</p>"
        }
      ],
      "examples": [
        "note(\"d d a# a\".fast(2)).s(\"sawtooth\").delay(.8).delaytime(1/2).delayspeed(\"<2 .5 -1 -2>\")"
      ],
      "synonyms": [
        "delayt",
        "dt"
      ],
      "originalName": "delayspeed"
    },
    {
      "name": "duck",
      "description": "<p>Modulate the amplitude of an orbit to create a &quot;sidechain&quot; like effect.</p>\n<p>Can be applied to multiple orbits with the ':' mininotation, e.g. <code>duckorbit(&quot;2:3&quot;)</code></p>",
      "params": [
        {
          "name": "orbit",
          "type": "number | Pattern",
          "description": "<p>target orbit</p>"
        }
      ],
      "examples": [
        "$: n(run(16)).scale(\"c:minor:pentatonic\").s(\"sawtooth\").delay(.7).orbit(2)\r$: s(\"bd:4!4\").beat(\"0,4,8,11,14\",16).duckorbit(2).duckattack(0.2).duckdepth(1)",
        "$: n(run(16)).scale(\"c:minor:pentatonic\").s(\"sawtooth\").delay(.7).orbit(2)\r$: s(\"hh*16\").orbit(3)\r$: s(\"bd:4!4\").beat(\"0,4,8,11,14\",16).duckorbit(\"2:3\").duckattack(0.2).duckdepth(1)"
      ],
      "synonyms": [
        "duck"
      ],
      "originalName": "duckorbit"
    },
    {
      "name": "duckatt",
      "description": "<p>The time required for the ducked signal(s) to return to their normal volume.</p>\n<p>Can vary across orbits with the ':' mininotation, e.g. <code>duckonset(&quot;0:0.003&quot;)</code>.\nNote: this requires first applying the effect to multiple orbits with e.g. <code>duckorbit(&quot;2:3&quot;)</code>.</p>",
      "params": [
        {
          "name": "time",
          "type": "number | Pattern",
          "description": "<p>The attack time in seconds</p>"
        }
      ],
      "examples": [
        "sound: n(run(8)).scale(\"c:minor\").s(\"sawtooth\").delay(.7).orbit(2)\rducker: s(\"bd:4!4\").beat(\"0,4,8,11,14\",16).duckorbit(2).duckattack(\"<0.2 0 0.4>\").duckdepth(1)",
        "moreduck: n(run(8)).scale(\"c:minor\").s(\"sawtooth\").delay(.7).orbit(2)\rlessduck: s(\"hh*16\").orbit(5)\rducker: s(\"bd:4!4\").beat(\"0,4,8,11,14\",16).duckorbit(\"2:5\").duckattack(\"0.4:0.1\")"
      ],
      "synonyms": [
        "duckatt"
      ],
      "originalName": "duckattack"
    },
    {
      "name": "duckattack",
      "description": "<p>The time required for the ducked signal(s) to return to their normal volume.</p>\n<p>Can vary across orbits with the ':' mininotation, e.g. <code>duckonset(&quot;0:0.003&quot;)</code>.\nNote: this requires first applying the effect to multiple orbits with e.g. <code>duckorbit(&quot;2:3&quot;)</code>.</p>",
      "params": [
        {
          "name": "time",
          "type": "number | Pattern",
          "description": "<p>The attack time in seconds</p>"
        }
      ],
      "examples": [
        "sound: n(run(8)).scale(\"c:minor\").s(\"sawtooth\").delay(.7).orbit(2)\rducker: s(\"bd:4!4\").beat(\"0,4,8,11,14\",16).duckorbit(2).duckattack(\"<0.2 0 0.4>\").duckdepth(1)",
        "moreduck: n(run(8)).scale(\"c:minor\").s(\"sawtooth\").delay(.7).orbit(2)\rlessduck: s(\"hh*16\").orbit(5)\rducker: s(\"bd:4!4\").beat(\"0,4,8,11,14\",16).duckorbit(\"2:5\").duckattack(\"0.4:0.1\")"
      ],
      "synonyms": [
        "duckatt"
      ],
      "originalName": "duckattack"
    },
    {
      "name": "duckdepth",
      "description": "<p>The amount of ducking applied to target orbit</p>\n<p>Can vary across orbits with the ':' mininotation, e.g. <code>duckdepth(&quot;0.3:0.1&quot;)</code>.\nNote: this requires first applying the effect to multiple orbits with e.g. <code>duckorbit(&quot;2:3&quot;)</code>.</p>",
      "params": [
        {
          "name": "depth",
          "type": "number | Pattern",
          "description": "<p>depth of modulation from 0 to 1</p>"
        }
      ],
      "examples": [
        "stack( n(run(8)).scale(\"c:minor\").s(\"sawtooth\").delay(.7).orbit(2), s(\"bd:4!4\").beat(\"0,4,8,11,14\",16).duckorbit(2).duckattack(0.2).duckdepth(\"<1 .9 .6 0>\"))",
        "$: n(run(16)).scale(\"c:minor:pentatonic\").s(\"sawtooth\").delay(.7).orbit(2)\r$: s(\"hh*16\").orbit(3)\r$: s(\"bd:4!4\").beat(\"0,4,8,11,14\",16).duckorbit(\"2:3\").duckattack(0.2).duckdepth(\"1:0.5\")"
      ],
      "synonyms": [],
      "originalName": "duckdepth"
    },
    {
      "name": "duckons",
      "description": "<p>The time required for the ducked signal(s) to reach their lowest volume.\nCan be used to prevent clicking or for creative rhythmic effects.</p>\n<p>Can vary across orbits with the ':' mininotation, e.g. <code>duckonset(&quot;0:0.003&quot;)</code>.\nNote: this requires first applying the effect to multiple orbits with e.g. <code>duckorbit(&quot;2:3&quot;)</code>.</p>",
      "params": [
        {
          "name": "time",
          "type": "number | Pattern",
          "description": "<p>The onset time in seconds</p>"
        }
      ],
      "examples": [
        "// Clicks\rsound: freq(\"63.2388\").s(\"sine\").orbit(2).gain(4)\rduckerWithClick: s(\"bd*4\").duckorbit(2).duckattack(0.3).duckonset(0).postgain(0)",
        "// No clicks\rsound: freq(\"63.2388\").s(\"sine\").orbit(2).gain(4)\rduckerWithoutClick: s(\"bd*4\").duckorbit(2).duckattack(0.3).duckonset(0.01).postgain(0)",
        "// Rhythmic\rnoise: s(\"pink\").distort(\"2:1\").orbit(4) // used rhythmically with 0.3 onset below\rhhat: s(\"hh*16\").orbit(7)\rducker: s(\"bd*4\").bank(\"tr909\").duckorbit(\"4:7\").duckonset(\"0.3:0.003\").duckattack(0.25)"
      ],
      "synonyms": [
        "duckons"
      ],
      "originalName": "duckonset"
    },
    {
      "name": "duckonset",
      "description": "<p>The time required for the ducked signal(s) to reach their lowest volume.\nCan be used to prevent clicking or for creative rhythmic effects.</p>\n<p>Can vary across orbits with the ':' mininotation, e.g. <code>duckonset(&quot;0:0.003&quot;)</code>.\nNote: this requires first applying the effect to multiple orbits with e.g. <code>duckorbit(&quot;2:3&quot;)</code>.</p>",
      "params": [
        {
          "name": "time",
          "type": "number | Pattern",
          "description": "<p>The onset time in seconds</p>"
        }
      ],
      "examples": [
        "// Clicks\rsound: freq(\"63.2388\").s(\"sine\").orbit(2).gain(4)\rduckerWithClick: s(\"bd*4\").duckorbit(2).duckattack(0.3).duckonset(0).postgain(0)",
        "// No clicks\rsound: freq(\"63.2388\").s(\"sine\").orbit(2).gain(4)\rduckerWithoutClick: s(\"bd*4\").duckorbit(2).duckattack(0.3).duckonset(0.01).postgain(0)",
        "// Rhythmic\rnoise: s(\"pink\").distort(\"2:1\").orbit(4) // used rhythmically with 0.3 onset below\rhhat: s(\"hh*16\").orbit(7)\rducker: s(\"bd*4\").bank(\"tr909\").duckorbit(\"4:7\").duckonset(\"0.3:0.003\").duckattack(0.25)"
      ],
      "synonyms": [
        "duckons"
      ],
      "originalName": "duckonset"
    },
    {
      "name": "duckorbit",
      "description": "<p>Modulate the amplitude of an orbit to create a &quot;sidechain&quot; like effect.</p>\n<p>Can be applied to multiple orbits with the ':' mininotation, e.g. <code>duckorbit(&quot;2:3&quot;)</code></p>",
      "params": [
        {
          "name": "orbit",
          "type": "number | Pattern",
          "description": "<p>target orbit</p>"
        }
      ],
      "examples": [
        "$: n(run(16)).scale(\"c:minor:pentatonic\").s(\"sawtooth\").delay(.7).orbit(2)\r$: s(\"bd:4!4\").beat(\"0,4,8,11,14\",16).duckorbit(2).duckattack(0.2).duckdepth(1)",
        "$: n(run(16)).scale(\"c:minor:pentatonic\").s(\"sawtooth\").delay(.7).orbit(2)\r$: s(\"hh*16\").orbit(3)\r$: s(\"bd:4!4\").beat(\"0,4,8,11,14\",16).duckorbit(\"2:3\").duckattack(0.2).duckdepth(1)"
      ],
      "synonyms": [
        "duck"
      ],
      "originalName": "duckorbit"
    },
    {
      "name": "dur",
      "description": "<p>Sets the duration of the event in cycles. Similar to clip / legato, it also cuts samples off at the end if they exceed the duration.</p>",
      "params": [
        {
          "name": "seconds",
          "type": "number | Pattern",
          "description": "<blockquote>\n<p>= 0</p>\n</blockquote>"
        }
      ],
      "examples": [
        "note(\"c a f e\").s(\"piano\").dur(\"<.5 1 2>\")"
      ],
      "synonyms": [
        "dur"
      ],
      "originalName": "duration"
    },
    {
      "name": "duration",
      "description": "<p>Sets the duration of the event in cycles. Similar to clip / legato, it also cuts samples off at the end if they exceed the duration.</p>",
      "params": [
        {
          "name": "seconds",
          "type": "number | Pattern",
          "description": "<blockquote>\n<p>= 0</p>\n</blockquote>"
        }
      ],
      "examples": [
        "note(\"c a f e\").s(\"piano\").dur(\"<.5 1 2>\")"
      ],
      "synonyms": [
        "dur"
      ],
      "originalName": "duration"
    },
    {
      "name": "each",
      "description": "<p>Applies a function to each of the running patterns separately. This is intended for future use with upcoming 'stepwise' features. See <code>all</code> for a version that applies the function to all the patterns stacked together into a single pattern.</p>\n<pre class=\"prettyprint source\"><code>$: sound(&quot;bd - cp sd&quot;)\n$: sound(&quot;hh*8&quot;)\neach(fast(&quot;&lt;2 3>&quot;))\n</code></pre>",
      "params": [],
      "examples": [],
      "synonyms": [],
      "originalName": "each"
    },
    {
      "name": "early",
      "description": "<p>Nudge a pattern to start earlier in time. Equivalent of Tidal's &lt;~ operator</p>",
      "params": [
        {
          "name": "cycles",
          "type": "number | Pattern",
          "description": "<p>number of cycles to nudge left</p>"
        }
      ],
      "examples": [
        "\"bd ~\".stack(\"hh ~\".early(.1)).s()"
      ],
      "synonyms": [],
      "originalName": "early"
    },
    {
      "name": "echo",
      "description": "<p>Superimpose and offset multiple times, gradually decreasing the velocity</p>",
      "params": [
        {
          "name": "times",
          "type": "number",
          "description": "<p>how many times to repeat</p>"
        },
        {
          "name": "time",
          "type": "number",
          "description": "<p>cycle offset between iterations</p>"
        },
        {
          "name": "feedback",
          "type": "number",
          "description": "<p>velocity multiplicator for each iteration</p>"
        }
      ],
      "examples": [
        "s(\"bd sd\").echo(3, 1/6, .8)"
      ],
      "synonyms": [],
      "originalName": "echo"
    },
    {
      "name": "echowith",
      "description": "<p>Superimpose and offset multiple times, applying the given function each time.</p>",
      "params": [
        {
          "name": "times",
          "type": "number",
          "description": "<p>how many times to repeat</p>"
        },
        {
          "name": "time",
          "type": "number",
          "description": "<p>cycle offset between iterations</p>"
        },
        {
          "name": "func",
          "type": "function",
          "description": "<p>function to apply, given the pattern and the iteration index</p>"
        }
      ],
      "examples": [
        "\"<0 [2 4]>\"\r.echoWith(4, 1/8, (p,n) => p.add(n*2))\r.scale(\"C:minor\").note()"
      ],
      "synonyms": [
        "echowith",
        "stutWith",
        "stutwith"
      ],
      "originalName": "echoWith"
    },
    {
      "name": "echoWith",
      "description": "<p>Superimpose and offset multiple times, applying the given function each time.</p>",
      "params": [
        {
          "name": "times",
          "type": "number",
          "description": "<p>how many times to repeat</p>"
        },
        {
          "name": "time",
          "type": "number",
          "description": "<p>cycle offset between iterations</p>"
        },
        {
          "name": "func",
          "type": "function",
          "description": "<p>function to apply, given the pattern and the iteration index</p>"
        }
      ],
      "examples": [
        "\"<0 [2 4]>\"\r.echoWith(4, 1/8, (p,n) => p.add(n*2))\r.scale(\"C:minor\").note()"
      ],
      "synonyms": [
        "echowith",
        "stutWith",
        "stutwith"
      ],
      "originalName": "echoWith"
    },
    {
      "name": "eish",
      "description": "<p>A 'euclid' variant with an additional parameter that morphs the resulting\nrhythm from 0 (no morphing) to 1 (completely 'even'). For example\n<code>sound(&quot;bd&quot;).euclidish(3,8,0)</code> would be the same as\n<code>sound(&quot;bd&quot;).euclid(3,8)</code>, and <code>sound(&quot;bd&quot;).euclidish(3,8,1)</code> would be the\nsame as <code>sound(&quot;bd bd bd&quot;)</code>. <code>sound(&quot;bd&quot;).euclidish(3,8,0.5)</code> would have a\ngroove somewhere between.\nInspired by the work of Malcom Braff.</p>",
      "params": [
        {
          "name": "pulses",
          "type": "number",
          "description": "<p>the number of onsets</p>"
        },
        {
          "name": "steps",
          "type": "number",
          "description": "<p>the number of steps to fill</p>"
        },
        {
          "name": "groove",
          "type": "number",
          "description": "<p>exists between the extremes of 0 (straight euclidian) and 1 (straight pulse)</p>"
        }
      ],
      "examples": [
        "sound(\"hh\").euclidish(7,12,sine.slow(8))\r.pan(sine.slow(8))"
      ],
      "synonyms": [
        "eish"
      ],
      "originalName": "euclidish"
    },
    {
      "name": "end",
      "description": "<p>The same as .begin, but cuts off the end off each sample.</p>",
      "params": [
        {
          "name": "length",
          "type": "number | Pattern",
          "description": "<p>1 = whole sample, .5 = half sample, .25 = quarter sample etc..</p>"
        }
      ],
      "examples": [
        "s(\"bd*2,oh*4\").end(\"<.1 .2 .5 1>\").fast(2)"
      ],
      "synonyms": [],
      "originalName": "end"
    },
    {
      "name": "euclid",
      "description": "<p>Changes the structure of the pattern to form an Euclidean rhythm.\nEuclidean rhythms are rhythms obtained using the greatest common\ndivisor of two numbers.  They were described in 2004 by Godfried\nToussaint, a Canadian computer scientist.  Euclidean rhythms are\nreally useful for computer/algorithmic music because they can\ndescribe a large number of rhythms with a couple of numbers.</p>",
      "params": [
        {
          "name": "pulses",
          "type": "number",
          "description": "<p>the number of onsets/beats</p>"
        },
        {
          "name": "steps",
          "type": "number",
          "description": "<p>the number of steps to fill</p>"
        }
      ],
      "examples": [
        "// The Cuban tresillo pattern.\rnote(\"c3\").euclid(3,8)"
      ],
      "synonyms": [],
      "originalName": "euclid"
    },
    {
      "name": "euclidish",
      "description": "<p>A 'euclid' variant with an additional parameter that morphs the resulting\nrhythm from 0 (no morphing) to 1 (completely 'even'). For example\n<code>sound(&quot;bd&quot;).euclidish(3,8,0)</code> would be the same as\n<code>sound(&quot;bd&quot;).euclid(3,8)</code>, and <code>sound(&quot;bd&quot;).euclidish(3,8,1)</code> would be the\nsame as <code>sound(&quot;bd bd bd&quot;)</code>. <code>sound(&quot;bd&quot;).euclidish(3,8,0.5)</code> would have a\ngroove somewhere between.\nInspired by the work of Malcom Braff.</p>",
      "params": [
        {
          "name": "pulses",
          "type": "number",
          "description": "<p>the number of onsets</p>"
        },
        {
          "name": "steps",
          "type": "number",
          "description": "<p>the number of steps to fill</p>"
        },
        {
          "name": "groove",
          "type": "number",
          "description": "<p>exists between the extremes of 0 (straight euclidian) and 1 (straight pulse)</p>"
        }
      ],
      "examples": [
        "sound(\"hh\").euclidish(7,12,sine.slow(8))\r.pan(sine.slow(8))"
      ],
      "synonyms": [
        "eish"
      ],
      "originalName": "euclidish"
    },
    {
      "name": "euclidLegato",
      "description": "<p>Similar to <code>euclid</code>, but each pulse is held until the next pulse,\nso there will be no gaps.</p>",
      "params": [
        {
          "name": "pulses",
          "type": "number",
          "description": "<p>the number of onsets/beats</p>"
        },
        {
          "name": "steps",
          "type": "number",
          "description": "<p>the number of steps to fill</p>"
        },
        {
          "name": "rotation",
          "type": "any",
          "description": "<p>offset in steps</p>"
        },
        {
          "name": "pat",
          "type": "any",
          "description": ""
        }
      ],
      "examples": [
        "note(\"c3\").euclidLegato(3,8)"
      ],
      "synonyms": [],
      "originalName": "euclidLegato"
    },
    {
      "name": "euclidLegatoRot",
      "description": "<p>Similar to <code>euclid</code>, but each pulse is held until the next pulse,\nso there will be no gaps, and has an additional parameter for 'rotating'\nthe resulting sequence</p>",
      "params": [
        {
          "name": "pulses",
          "type": "number",
          "description": "<p>the number of onsets/beats</p>"
        },
        {
          "name": "steps",
          "type": "number",
          "description": "<p>the number of steps to fill</p>"
        },
        {
          "name": "rotation",
          "type": "number",
          "description": "<p>offset in steps</p>"
        }
      ],
      "examples": [
        "note(\"c3\").euclidLegatoRot(3,5,2)"
      ],
      "synonyms": [],
      "originalName": "euclidLegatoRot"
    },
    {
      "name": "euclidRot",
      "description": "<p>Like <code>euclid</code>, but has an additional parameter for 'rotating' the resulting sequence.</p>",
      "params": [
        {
          "name": "pulses",
          "type": "number",
          "description": "<p>the number of onsets/beats</p>"
        },
        {
          "name": "steps",
          "type": "number",
          "description": "<p>the number of steps to fill</p>"
        },
        {
          "name": "rotation",
          "type": "number",
          "description": "<p>offset in steps</p>"
        }
      ],
      "examples": [
        "// A Samba rhythm necklace from Brazil\rnote(\"c3\").euclidRot(3,16,14)"
      ],
      "synonyms": [],
      "originalName": "euclidRot"
    },
    {
      "name": "every",
      "description": "<p>An alias for <code>firstOf</code></p>",
      "params": [
        {
          "name": "n",
          "type": "number",
          "description": "<p>how many cycles</p>"
        },
        {
          "name": "func",
          "type": "function",
          "description": "<p>function to apply</p>"
        }
      ],
      "examples": [
        "note(\"c3 d3 e3 g3\").every(4, x=>x.rev())"
      ],
      "synonyms": [],
      "originalName": "every"
    },
    {
      "name": "expand",
      "description": "<p><em>Experimental</em></p>\n<p>Expands the step size of the pattern by the given factor.</p>",
      "params": [],
      "examples": [
        "sound(\"tha dhi thom nam\").bank(\"mridangam\").expand(\"3 2 1 1 2 3\").pace(8)"
      ],
      "synonyms": [],
      "originalName": "expand"
    },
    {
      "name": "extend",
      "description": "<p><em>Experimental</em></p>\n<p><code>extend</code> is similar to <code>fast</code> in that it increases its density, but it also increases the step count\naccordingly. So <code>stepcat(&quot;a b&quot;.extend(2), &quot;c d&quot;)</code> would be the same as <code>&quot;a b a b c d&quot;</code>, whereas\n<code>stepcat(&quot;a b&quot;.fast(2), &quot;c d&quot;)</code> would be the same as <code>&quot;[a b] [a b] c d&quot;</code>.</p>",
      "params": [],
      "examples": [
        "stepcat(\r  sound(\"bd bd - cp\").extend(2),\r  sound(\"bd - sd -\")\r).pace(8)"
      ],
      "synonyms": [],
      "originalName": "extend"
    },
    {
      "name": "fanchor",
      "description": "<p>controls the center of the filter envelope. 0 is unipolar positive, .5 is bipolar, 1 is unipolar negative</p>",
      "params": [
        {
          "name": "center",
          "type": "number | Pattern",
          "description": "<p>0 to 1</p>"
        }
      ],
      "examples": [
        "note(\"{f g g c d a a#}%8\").s(\"sawtooth\").lpf(\"{1000}%2\")\r.lpenv(8).fanchor(\"<0 .5 1>\")"
      ],
      "synonyms": [],
      "originalName": "fanchor"
    },
    {
      "name": "fast",
      "description": "<p>Speed up a pattern by the given factor. Used by &quot;*&quot; in mini notation.</p>",
      "params": [
        {
          "name": "factor",
          "type": "number | Pattern",
          "description": "<p>speed up factor</p>"
        }
      ],
      "examples": [
        "s(\"bd hh sd hh\").fast(2) // s(\"[bd hh sd hh]*2\")"
      ],
      "synonyms": [
        "density"
      ],
      "originalName": "fast"
    },
    {
      "name": "fastcat",
      "description": "<p>Like <strong>cat</strong>, but the items are crammed into one cycle.</p>",
      "params": [],
      "examples": [
        "seq(\"e5\", \"b4\", [\"d5\", \"c5\"]).note()\r// \"e5 b4 [d5 c5]\".note()",
        "// As a chained function:\rs(\"hh*4\").seq(\r  note(\"c4(5,8)\")\r)"
      ],
      "synonyms": [
        "sequence",
        "fastcat"
      ],
      "originalName": "seq"
    },
    {
      "name": "fastchunk",
      "description": "<p>Like <code>chunk</code>, but the cycles of the source pattern aren't repeated\nfor each set of chunks.</p>",
      "params": [],
      "examples": [
        "\"<0 8> 1 2 3 4 5 6 7\"\r.scale(\"C2:major\").note()\r.fastChunk(4, x => x.color('red')).slow(2)"
      ],
      "synonyms": [
        "fastchunk"
      ],
      "originalName": "fastChunk"
    },
    {
      "name": "fastChunk",
      "description": "<p>Like <code>chunk</code>, but the cycles of the source pattern aren't repeated\nfor each set of chunks.</p>",
      "params": [],
      "examples": [
        "\"<0 8> 1 2 3 4 5 6 7\"\r.scale(\"C2:major\").note()\r.fastChunk(4, x => x.color('red')).slow(2)"
      ],
      "synonyms": [
        "fastchunk"
      ],
      "originalName": "fastChunk"
    },
    {
      "name": "fastgap",
      "description": "<p>speeds up a pattern like fast, but rather than it playing multiple times as fast would it instead leaves a gap in the remaining space of the cycle. For example, the following will play the sound pattern &quot;bd sn&quot; only once but compressed into the first half of the cycle, i.e. twice as fast.</p>",
      "params": [],
      "examples": [
        "s(\"bd sd\").fastGap(2)"
      ],
      "synonyms": [
        "fastgap"
      ],
      "originalName": "fastGap"
    },
    {
      "name": "fastGap",
      "description": "<p>speeds up a pattern like fast, but rather than it playing multiple times as fast would it instead leaves a gap in the remaining space of the cycle. For example, the following will play the sound pattern &quot;bd sn&quot; only once but compressed into the first half of the cycle, i.e. twice as fast.</p>",
      "params": [],
      "examples": [
        "s(\"bd sd\").fastGap(2)"
      ],
      "synonyms": [
        "fastgap"
      ],
      "originalName": "fastGap"
    },
    {
      "name": "filter",
      "description": "<p>Filters haps using the given function</p>",
      "params": [
        {
          "name": "test",
          "type": "function",
          "description": "<p>function to test Hap</p>"
        }
      ],
      "examples": [
        "s(\"hh!7 oh\").filter(hap => hap.value.s==='hh')"
      ],
      "synonyms": [],
      "originalName": "filter"
    },
    {
      "name": "filterHaps",
      "description": "<p>Returns a new Pattern, which only returns haps that meet the given test.</p>",
      "params": [
        {
          "name": "hap_test",
          "type": "function",
          "description": "<p>a function which returns false for haps to be removed from the pattern</p>"
        }
      ],
      "examples": [],
      "synonyms": [],
      "originalName": "filterHaps"
    },
    {
      "name": "filterValues",
      "description": "<p>As with <code>filterHaps</code>, but the function is applied to values\ninside haps.</p>",
      "params": [
        {
          "name": "value_test",
          "type": "function",
          "description": ""
        }
      ],
      "examples": [],
      "synonyms": [],
      "originalName": "filterValues"
    },
    {
      "name": "filterWhen",
      "description": "<p>Filters haps by their begin time</p>",
      "params": [
        {
          "name": "test",
          "type": "function",
          "description": "<p>function to test Hap.whole.begin</p>"
        }
      ],
      "examples": [],
      "synonyms": [],
      "originalName": "filterWhen"
    },
    {
      "name": "findPeaks",
      "description": "<p>Find peaks in spectrum magnitudes</p>",
      "params": [],
      "examples": [],
      "synonyms": [],
      "originalName": "findPeaks"
    },
    {
      "name": "firstCycle",
      "description": "<p>Queries the pattern for the first cycle, returning Haps. Mainly of use when\ndebugging a pattern.</p>",
      "params": [
        {
          "name": "with_context",
          "type": "Boolean",
          "description": "<p>set to true, otherwise the context field\nwill be stripped from the resulting haps.</p>"
        }
      ],
      "examples": [],
      "synonyms": [],
      "originalName": "firstCycle"
    },
    {
      "name": "firstCycleValues",
      "description": "<p>Accessor for a list of values returned by querying the first cycle.</p>",
      "params": [],
      "examples": [],
      "synonyms": [],
      "originalName": "firstCycleValues"
    },
    {
      "name": "firstOf",
      "description": "<p>Applies the given function every n cycles, starting from the first cycle.</p>",
      "params": [
        {
          "name": "n",
          "type": "number",
          "description": "<p>how many cycles</p>"
        },
        {
          "name": "func",
          "type": "function",
          "description": "<p>function to apply</p>"
        }
      ],
      "examples": [
        "note(\"c3 d3 e3 g3\").firstOf(4, x=>x.rev())"
      ],
      "synonyms": [],
      "originalName": "firstOf"
    },
    {
      "name": "fit",
      "description": "<p>Makes the sample fit its event duration. Good for rhythmical loops like drum breaks.\nSimilar to <code>loopAt</code>.</p>",
      "params": [],
      "examples": [
        "samples({ rhodes: 'https://cdn.freesound.org/previews/132/132051_316502-lq.mp3' })\rs(\"rhodes/2\").fit()"
      ],
      "synonyms": [],
      "originalName": "fit"
    },
    {
      "name": "floor",
      "description": "<p>Assumes a numerical pattern. Returns a new pattern with all values set to\ntheir mathematical floor. E.g. <code>3.7</code> replaced with to <code>3</code>, and <code>-4.2</code>\nreplaced with <code>-5</code>.</p>",
      "params": [],
      "examples": [
        "note(\"42 42.1 42.5 43\".floor())"
      ],
      "synonyms": [],
      "originalName": "floor"
    },
    {
      "name": "fm",
      "description": "<p>Sets the Frequency Modulation of the synth.\nControls the modulation index, which defines the brightness of the sound.</p>",
      "params": [
        {
          "name": "brightness",
          "type": "number | Pattern",
          "description": "<p>modulation index</p>"
        }
      ],
      "examples": [
        "note(\"c e g b g e\")\r.fm(\"<0 1 2 8 32>\")\r._scope()"
      ],
      "synonyms": [
        "fmi"
      ],
      "originalName": "fm"
    },
    {
      "name": "fmap",
      "description": "<p>Returns a new pattern, with the function applied to the value of\neach hap. It has the alias <code>fmap</code>.</p>",
      "params": [
        {
          "name": "func",
          "type": "function",
          "description": "<p>to to apply to the value</p>"
        }
      ],
      "examples": [
        "\"0 1 2\".withValue(v => v + 10).log()"
      ],
      "synonyms": [
        "fmap"
      ],
      "originalName": "withValue"
    },
    {
      "name": "fmattack",
      "description": "<p>Attack time for the FM envelope: time it takes to reach maximum modulation</p>",
      "params": [
        {
          "name": "time",
          "type": "number | Pattern",
          "description": "<p>attack time</p>"
        }
      ],
      "examples": [
        "note(\"c e g b g e\")\r.fm(4)\r.fmattack(\"<0 .05 .1 .2>\")\r._scope()"
      ],
      "synonyms": [],
      "originalName": "fmattack"
    },
    {
      "name": "fmdecay",
      "description": "<p>Decay time for the FM envelope: seconds until the sustain level is reached after the attack phase.</p>",
      "params": [
        {
          "name": "time",
          "type": "number | Pattern",
          "description": "<p>decay time</p>"
        }
      ],
      "examples": [
        "note(\"c e g b g e\")\r.fm(4)\r.fmdecay(\"<.01 .05 .1 .2>\")\r.fmsustain(.4)\r._scope()"
      ],
      "synonyms": [],
      "originalName": "fmdecay"
    },
    {
      "name": "fmenv",
      "description": "<p>Ramp type of fm envelope. Exp might be a bit broken..</p>",
      "params": [
        {
          "name": "type",
          "type": "number | Pattern",
          "description": "<p>lin | exp</p>"
        }
      ],
      "examples": [
        "note(\"c e g b g e\")\r.fm(4)\r.fmdecay(.2)\r.fmsustain(0)\r.fmenv(\"<exp lin>\")\r._scope()"
      ],
      "synonyms": [],
      "originalName": "fmenv"
    },
    {
      "name": "fmh",
      "description": "<p>Sets the Frequency Modulation Harmonicity Ratio.\nControls the timbre of the sound.\nWhole numbers and simple ratios sound more natural,\nwhile decimal numbers and complex ratios sound metallic.</p>",
      "params": [
        {
          "name": "harmonicity",
          "type": "number | Pattern",
          "description": ""
        }
      ],
      "examples": [
        "note(\"c e g b g e\")\r.fm(4)\r.fmh(\"<1 2 1.5 1.61>\")\r._scope()"
      ],
      "synonyms": [],
      "originalName": "fmh"
    },
    {
      "name": "fmi",
      "description": "<p>Sets the Frequency Modulation of the synth.\nControls the modulation index, which defines the brightness of the sound.</p>",
      "params": [
        {
          "name": "brightness",
          "type": "number | Pattern",
          "description": "<p>modulation index</p>"
        }
      ],
      "examples": [
        "note(\"c e g b g e\")\r.fm(\"<0 1 2 8 32>\")\r._scope()"
      ],
      "synonyms": [
        "fmi"
      ],
      "originalName": "fm"
    },
    {
      "name": "fmrelease",
      "description": "",
      "params": [],
      "examples": [],
      "synonyms": [],
      "originalName": "fmrelease"
    },
    {
      "name": "fmsustain",
      "description": "<p>Sustain level for the FM envelope: how much modulation is applied after the decay phase</p>",
      "params": [
        {
          "name": "level",
          "type": "number | Pattern",
          "description": "<p>sustain level</p>"
        }
      ],
      "examples": [
        "note(\"c e g b g e\")\r.fm(4)\r.fmdecay(.1)\r.fmsustain(\"<1 .75 .5 0>\")\r._scope()"
      ],
      "synonyms": [],
      "originalName": "fmsustain"
    },
    {
      "name": "fmwave",
      "description": "<p>Waveform of the fm modulator</p>",
      "params": [
        {
          "name": "wave",
          "type": "number | Pattern",
          "description": "<p>waveform</p>"
        }
      ],
      "examples": [
        "n(\"0 1 2 3\".fast(4)).scale(\"d:minor\").s(\"sine\").fmwave(\"<sine square sawtooth crackle>\").fm(4).fmh(2.01)",
        "n(\"0 1 2 3\".fast(4)).chord(\"<Dm Am F G>\").voicing().s(\"sawtooth\").fmwave(\"brown\").fm(.6)"
      ],
      "synonyms": [],
      "originalName": "fmwave"
    },
    {
      "name": "focus",
      "description": "<p>Similar to <code>compress</code>, but doesn't leave gaps, and the 'focus' can be bigger than a cycle</p>",
      "params": [],
      "examples": [
        "s(\"bd hh sd hh\").focus(1/4, 3/4)"
      ],
      "synonyms": [],
      "originalName": "focus"
    },
    {
      "name": "fold",
      "description": "<p>Wavefolding distortion</p>",
      "params": [
        {
          "name": "distortion",
          "type": "number | Pattern",
          "description": "<p>amount of distortion to apply</p>"
        },
        {
          "name": "volume",
          "type": "number | Pattern",
          "description": "<p>linear postgain of the distortion</p>"
        }
      ],
      "examples": [],
      "synonyms": [],
      "originalName": "fold"
    },
    {
      "name": "freq",
      "description": "<p>Set frequency of sound.</p>",
      "params": [
        {
          "name": "frequency",
          "type": "number | Pattern",
          "description": "<p>in Hz. the audible range is between 20 and 20000 Hz</p>"
        }
      ],
      "examples": [
        "freq(\"220 110 440 110\").s(\"superzow\").osc()",
        "freq(\"110\".mul.out(\".5 1.5 .6 [2 3]\")).s(\"superzow\").osc()"
      ],
      "synonyms": [],
      "originalName": "freq"
    },
    {
      "name": "fromBipolar",
      "description": "<p>Assumes a numerical pattern, containing bipolar values in the range -1 .. 1\nReturns a new pattern with values scaled to the unipolar range 0 .. 1</p>",
      "params": [],
      "examples": [],
      "synonyms": [],
      "originalName": "fromBipolar"
    },
    {
      "name": "fscope",
      "description": "<p>Renders an oscilloscope for the frequency domain of the audio signal.</p>",
      "params": [
        {
          "name": "color",
          "type": "string",
          "description": "<p>line color as hex or color name. defaults to white.</p>"
        },
        {
          "name": "scale",
          "type": "number",
          "description": "<p>scales the y-axis. Defaults to 0.25</p>"
        },
        {
          "name": "pos",
          "type": "number",
          "description": "<p>y-position relative to screen height. 0 = top, 1 = bottom of screen</p>"
        },
        {
          "name": "lean",
          "type": "number",
          "description": "<p>y-axis alignment where 0 = top and 1 = bottom</p>"
        },
        {
          "name": "min",
          "type": "number",
          "description": "<p>min value</p>"
        },
        {
          "name": "max",
          "type": "number",
          "description": "<p>max value</p>"
        }
      ],
      "examples": [
        "s(\"sawtooth\").fscope()"
      ],
      "synonyms": [],
      "originalName": "fscope"
    },
    {
      "name": "ftype",
      "description": "<p>Sets the filter type. The ladder filter is more aggressive. More types might be added in the future.</p>",
      "params": [
        {
          "name": "type",
          "type": "number | Pattern",
          "description": "<p>12db (0), ladder (1), or 24db (2)</p>"
        }
      ],
      "examples": [
        "note(\"{f g g c d a a#}%8\").s(\"sawtooth\").lpenv(4).lpf(500).ftype(\"<0 1 2>\").lpq(1)",
        "note(\"c f g g a c d4\").fast(2)\r.sound('sawtooth')\r.lpf(200).fanchor(0)\r.lpenv(3).lpq(1)\r.ftype(\"<ladder 12db 24db>\")"
      ],
      "synonyms": [],
      "originalName": "ftype"
    },
    {
      "name": "gain",
      "description": "<p>Controls the gain by an exponential amount.</p>",
      "params": [
        {
          "name": "amount",
          "type": "number | Pattern",
          "description": "<p>gain.</p>"
        }
      ],
      "examples": [
        "s(\"hh*8\").gain(\".4!2 1 .4!2 1 .4 1\").fast(2)"
      ],
      "synonyms": [],
      "originalName": "gain"
    },
    {
      "name": "gap",
      "description": "<p>Does absolutely nothing, but with a given metrical 'steps'</p>",
      "params": [
        {
          "name": "steps",
          "type": "number",
          "description": ""
        }
      ],
      "examples": [
        "gap(3) // \"~@3\""
      ],
      "synonyms": [],
      "originalName": "gap"
    },
    {
      "name": "generateGraph",
      "description": "<p>Creates a canvas element showing a graph of the given data.</p>",
      "params": [
        {
          "name": "data",
          "type": "Float32Array",
          "description": "<p>An array of numbers, or a Float32Array.</p>"
        },
        {
          "name": "width",
          "type": "number",
          "description": "<p>Width in pixels of the canvas.</p>"
        },
        {
          "name": "height",
          "type": "number",
          "description": "<p>Height in pixels of the canvas.</p>"
        },
        {
          "name": "min",
          "type": "number",
          "description": "<p>Minimum value of data for the graph (lower edge).</p>"
        },
        {
          "name": "max",
          "type": "number",
          "description": "<p>Maximum value of data in the graph (upper edge).</p>"
        }
      ],
      "examples": [],
      "synonyms": [],
      "originalName": "generateGraph"
    },
    {
      "name": "generateReverb",
      "description": "<p>Generates a reverb impulse response.</p>",
      "params": [
        {
          "name": "params",
          "type": "Object",
          "description": "<p>TODO: Document the properties.</p>"
        },
        {
          "name": "callback",
          "type": "function",
          "description": "<p>Function to call when\nthe impulse response has been generated. The impulse response\nis passed to this function as its parameter. May be called\nimmediately within the current execution context, or later.</p>"
        }
      ],
      "examples": [],
      "synonyms": [],
      "originalName": "generateReverb"
    },
    {
      "name": "getAllChannelData",
      "description": "",
      "params": [
        {
          "name": "buffer",
          "type": "AudioBuffer",
          "description": ""
        }
      ],
      "examples": [],
      "synonyms": [],
      "originalName": "getAllChannelData"
    },
    {
      "name": "getFreq",
      "description": "",
      "params": [],
      "examples": [],
      "synonyms": [],
      "originalName": "getFreq"
    },
    {
      "name": "gravityX",
      "description": "<p>The device's gravity x-axis value ranges from 0 to 1.</p>",
      "params": [],
      "examples": [
        "n(gravityX.segment(4).range(0,7)).scale(\"C:minor\")"
      ],
      "synonyms": [
        "gravX"
      ],
      "originalName": "gravityX"
    },
    {
      "name": "gravityY",
      "description": "<p>The device's gravity y-axis value ranges from 0 to 1.</p>",
      "params": [],
      "examples": [
        "n(gravityY.segment(4).range(0,7)).scale(\"C:minor\")"
      ],
      "synonyms": [
        "gravY"
      ],
      "originalName": "gravityY"
    },
    {
      "name": "gravityZ",
      "description": "<p>The device's gravity z-axis value ranges from 0 to 1.</p>",
      "params": [],
      "examples": [
        "n(gravityZ.segment(4).range(0,7)).scale(\"C:minor\")"
      ],
      "synonyms": [
        "gravZ"
      ],
      "originalName": "gravityZ"
    },
    {
      "name": "gravX",
      "description": "<p>The device's gravity x-axis value ranges from 0 to 1.</p>",
      "params": [],
      "examples": [
        "n(gravityX.segment(4).range(0,7)).scale(\"C:minor\")"
      ],
      "synonyms": [
        "gravX"
      ],
      "originalName": "gravityX"
    },
    {
      "name": "gravY",
      "description": "<p>The device's gravity y-axis value ranges from 0 to 1.</p>",
      "params": [],
      "examples": [
        "n(gravityY.segment(4).range(0,7)).scale(\"C:minor\")"
      ],
      "synonyms": [
        "gravY"
      ],
      "originalName": "gravityY"
    },
    {
      "name": "gravZ",
      "description": "<p>The device's gravity z-axis value ranges from 0 to 1.</p>",
      "params": [],
      "examples": [
        "n(gravityZ.segment(4).range(0,7)).scale(\"C:minor\")"
      ],
      "synonyms": [
        "gravZ"
      ],
      "originalName": "gravityZ"
    },
    {
      "name": "grow",
      "description": "<p><em>Experimental</em></p>\n<p>Progressively grows the pattern by 'n' steps until the full pattern is played, or if a second value is given (using mininotation list syntax with <code>:</code>),\nthat number of times.\nA positive number will progressively grow steps from the start of a pattern, and a negative number from the end.</p>",
      "params": [],
      "examples": [
        "\"tha dhi thom nam\".grow(\"1\").sound()\r.bank(\"mridangam\")",
        "\"tha dhi thom nam\".grow(\"-1\").sound()\r.bank(\"mridangam\")",
        "\"tha dhi thom nam\".grow(\"1 -1\").sound().bank(\"mridangam\").pace(4)",
        "note(\"0 1 2 3 4 5 6 7\".scale(\"C:ritusen\")).sound(\"folkharp\")\r\n   .grow(\"1 -1\").pace(8)"
      ],
      "synonyms": [],
      "originalName": "grow"
    },
    {
      "name": "handleOutputBuffersToRetrieve",
      "description": "<p>Add contents of output buffers just processed to output buffers</p>",
      "params": [],
      "examples": [],
      "synonyms": [],
      "originalName": "handleOutputBuffersToRetrieve"
    },
    {
      "name": "hard",
      "description": "<p>Hard-clipping distortion</p>",
      "params": [
        {
          "name": "distortion",
          "type": "number | Pattern",
          "description": "<p>amount of distortion to apply</p>"
        },
        {
          "name": "volume",
          "type": "number | Pattern",
          "description": "<p>linear postgain of the distortion</p>"
        }
      ],
      "examples": [],
      "synonyms": [],
      "originalName": "hard"
    },
    {
      "name": "hcutoff",
      "description": "<p>Applies the cutoff frequency of the <strong>h</strong>igh-<strong>p</strong>ass <strong>f</strong>ilter.</p>\n<p>When using mininotation, you can also optionally add the 'hpq' parameter, separated by ':'.</p>",
      "params": [
        {
          "name": "frequency",
          "type": "number | Pattern",
          "description": "<p>audible between 0 and 20000</p>"
        }
      ],
      "examples": [
        "s(\"bd sd [~ bd] sd,hh*8\").hpf(\"<4000 2000 1000 500 200 100>\")",
        "s(\"bd sd [~ bd] sd,hh*8\").hpf(\"<2000 2000:25>\")"
      ],
      "synonyms": [
        "hp",
        "hcutoff"
      ],
      "originalName": "hpf"
    },
    {
      "name": "hp",
      "description": "<p>Applies the cutoff frequency of the <strong>h</strong>igh-<strong>p</strong>ass <strong>f</strong>ilter.</p>\n<p>When using mininotation, you can also optionally add the 'hpq' parameter, separated by ':'.</p>",
      "params": [
        {
          "name": "frequency",
          "type": "number | Pattern",
          "description": "<p>audible between 0 and 20000</p>"
        }
      ],
      "examples": [
        "s(\"bd sd [~ bd] sd,hh*8\").hpf(\"<4000 2000 1000 500 200 100>\")",
        "s(\"bd sd [~ bd] sd,hh*8\").hpf(\"<2000 2000:25>\")"
      ],
      "synonyms": [
        "hp",
        "hcutoff"
      ],
      "originalName": "hpf"
    },
    {
      "name": "hpa",
      "description": "<p>Sets the attack duration for the highpass filter envelope.</p>",
      "params": [
        {
          "name": "attack",
          "type": "number | Pattern",
          "description": "<p>time of the highpass filter envelope</p>"
        }
      ],
      "examples": [
        "note(\"c2 e2 f2 g2\")\r.sound('sawtooth')\r.hpf(500)\r.hpa(\"<.5 .25 .1 .01>/4\")\r.hpenv(4)"
      ],
      "synonyms": [
        "hpa"
      ],
      "originalName": "hpattack"
    },
    {
      "name": "hpattack",
      "description": "<p>Sets the attack duration for the highpass filter envelope.</p>",
      "params": [
        {
          "name": "attack",
          "type": "number | Pattern",
          "description": "<p>time of the highpass filter envelope</p>"
        }
      ],
      "examples": [
        "note(\"c2 e2 f2 g2\")\r.sound('sawtooth')\r.hpf(500)\r.hpa(\"<.5 .25 .1 .01>/4\")\r.hpenv(4)"
      ],
      "synonyms": [
        "hpa"
      ],
      "originalName": "hpattack"
    },
    {
      "name": "hpd",
      "description": "<p>Sets the decay duration for the highpass filter envelope.</p>",
      "params": [
        {
          "name": "decay",
          "type": "number | Pattern",
          "description": "<p>time of the highpass filter envelope</p>"
        }
      ],
      "examples": [
        "note(\"c2 e2 f2 g2\")\r.sound('sawtooth')\r.hpf(500)\r.hpd(\"<.5 .25 .1 0>/4\")\r.hps(0.2)\r.hpenv(4)"
      ],
      "synonyms": [
        "hpd"
      ],
      "originalName": "hpdecay"
    },
    {
      "name": "hpdecay",
      "description": "<p>Sets the decay duration for the highpass filter envelope.</p>",
      "params": [
        {
          "name": "decay",
          "type": "number | Pattern",
          "description": "<p>time of the highpass filter envelope</p>"
        }
      ],
      "examples": [
        "note(\"c2 e2 f2 g2\")\r.sound('sawtooth')\r.hpf(500)\r.hpd(\"<.5 .25 .1 0>/4\")\r.hps(0.2)\r.hpenv(4)"
      ],
      "synonyms": [
        "hpd"
      ],
      "originalName": "hpdecay"
    },
    {
      "name": "hpe",
      "description": "<p>Sets the highpass filter envelope modulation depth.</p>",
      "params": [
        {
          "name": "modulation",
          "type": "number | Pattern",
          "description": "<p>depth of the highpass filter envelope between 0 and <em>n</em></p>"
        }
      ],
      "examples": [
        "note(\"c2 e2 f2 g2\")\r.sound('sawtooth')\r.hpf(500)\r.hpa(.5)\r.hpenv(\"<4 2 1 0 -1 -2 -4>/4\")"
      ],
      "synonyms": [
        "hpe"
      ],
      "originalName": "hpenv"
    },
    {
      "name": "hpenv",
      "description": "<p>Sets the highpass filter envelope modulation depth.</p>",
      "params": [
        {
          "name": "modulation",
          "type": "number | Pattern",
          "description": "<p>depth of the highpass filter envelope between 0 and <em>n</em></p>"
        }
      ],
      "examples": [
        "note(\"c2 e2 f2 g2\")\r.sound('sawtooth')\r.hpf(500)\r.hpa(.5)\r.hpenv(\"<4 2 1 0 -1 -2 -4>/4\")"
      ],
      "synonyms": [
        "hpe"
      ],
      "originalName": "hpenv"
    },
    {
      "name": "hpf",
      "description": "<p>Applies the cutoff frequency of the <strong>h</strong>igh-<strong>p</strong>ass <strong>f</strong>ilter.</p>\n<p>When using mininotation, you can also optionally add the 'hpq' parameter, separated by ':'.</p>",
      "params": [
        {
          "name": "frequency",
          "type": "number | Pattern",
          "description": "<p>audible between 0 and 20000</p>"
        }
      ],
      "examples": [
        "s(\"bd sd [~ bd] sd,hh*8\").hpf(\"<4000 2000 1000 500 200 100>\")",
        "s(\"bd sd [~ bd] sd,hh*8\").hpf(\"<2000 2000:25>\")"
      ],
      "synonyms": [
        "hp",
        "hcutoff"
      ],
      "originalName": "hpf"
    },
    {
      "name": "hpq",
      "description": "<p>Controls the <strong>h</strong>igh-<strong>p</strong>ass <strong>q</strong>-value.</p>",
      "params": [
        {
          "name": "q",
          "type": "number | Pattern",
          "description": "<p>resonance factor between 0 and 50</p>"
        }
      ],
      "examples": [
        "s(\"bd sd [~ bd] sd,hh*8\").hpf(2000).hpq(\"<0 10 20 30>\")"
      ],
      "synonyms": [
        "hresonance"
      ],
      "originalName": "hpq"
    },
    {
      "name": "hpr",
      "description": "<p>Sets the release time for the highpass filter envelope.</p>",
      "params": [
        {
          "name": "release",
          "type": "number | Pattern",
          "description": "<p>time of the highpass filter envelope</p>"
        }
      ],
      "examples": [
        "note(\"c2 e2 f2 g2\")\r.sound('sawtooth')\r.clip(.5)\r.hpf(500)\r.hpenv(4)\r.hpr(\"<.5 .25 .1 0>/4\")\r.release(.5)"
      ],
      "synonyms": [
        "hpr"
      ],
      "originalName": "hprelease"
    },
    {
      "name": "hprelease",
      "description": "<p>Sets the release time for the highpass filter envelope.</p>",
      "params": [
        {
          "name": "release",
          "type": "number | Pattern",
          "description": "<p>time of the highpass filter envelope</p>"
        }
      ],
      "examples": [
        "note(\"c2 e2 f2 g2\")\r.sound('sawtooth')\r.clip(.5)\r.hpf(500)\r.hpenv(4)\r.hpr(\"<.5 .25 .1 0>/4\")\r.release(.5)"
      ],
      "synonyms": [
        "hpr"
      ],
      "originalName": "hprelease"
    },
    {
      "name": "hps",
      "description": "<p>Sets the sustain amplitude for the highpass filter envelope.</p>",
      "params": [
        {
          "name": "sustain",
          "type": "number | Pattern",
          "description": "<p>amplitude of the highpass filter envelope</p>"
        }
      ],
      "examples": [
        "note(\"c2 e2 f2 g2\")\r.sound('sawtooth')\r.hpf(500)\r.hpd(.5)\r.hps(\"<0 .25 .5 1>/4\")\r.hpenv(4)"
      ],
      "synonyms": [
        "hps"
      ],
      "originalName": "hpsustain"
    },
    {
      "name": "hpsustain",
      "description": "<p>Sets the sustain amplitude for the highpass filter envelope.</p>",
      "params": [
        {
          "name": "sustain",
          "type": "number | Pattern",
          "description": "<p>amplitude of the highpass filter envelope</p>"
        }
      ],
      "examples": [
        "note(\"c2 e2 f2 g2\")\r.sound('sawtooth')\r.hpf(500)\r.hpd(.5)\r.hps(\"<0 .25 .5 1>/4\")\r.hpenv(4)"
      ],
      "synonyms": [
        "hps"
      ],
      "originalName": "hpsustain"
    },
    {
      "name": "hresonance",
      "description": "<p>Controls the <strong>h</strong>igh-<strong>p</strong>ass <strong>q</strong>-value.</p>",
      "params": [
        {
          "name": "q",
          "type": "number | Pattern",
          "description": "<p>resonance factor between 0 and 50</p>"
        }
      ],
      "examples": [
        "s(\"bd sd [~ bd] sd,hh*8\").hpf(2000).hpq(\"<0 10 20 30>\")"
      ],
      "synonyms": [
        "hresonance"
      ],
      "originalName": "hpq"
    },
    {
      "name": "hurry",
      "description": "<p>Both speeds up the pattern (like 'fast') and the sample playback (like 'speed').</p>",
      "params": [],
      "examples": [
        "s(\"bd sd:2\").hurry(\"<1 2 4 3>\").slow(1.5)"
      ],
      "synonyms": [],
      "originalName": "hurry"
    },
    {
      "name": "hush",
      "description": "<p>Silences a pattern.</p>",
      "params": [],
      "examples": [
        "stack(\r  s(\"bd\").hush(),\r  s(\"hh*3\")\r)"
      ],
      "synonyms": [],
      "originalName": "hush"
    },
    {
      "name": "id",
      "description": "",
      "params": [],
      "examples": [],
      "synonyms": [],
      "originalName": "id"
    },
    {
      "name": "inhabit",
      "description": "<p>Picks patterns (or plain values) either from a list (by index) or a lookup table (by name).\nSimilar to <code>pick</code>, but cycles are squeezed into the target ('inhabited') pattern.</p>",
      "params": [
        {
          "name": "pat",
          "type": "Pattern",
          "description": ""
        },
        {
          "name": "xs",
          "type": "*",
          "description": ""
        }
      ],
      "examples": [
        "\"<a b [a,b]>\".inhabit({a: s(\"bd(3,8)\"),\r\n                            b: s(\"cp sd\")\r\n                           })",
        "s(\"a@2 [a b] a\".inhabit({a: \"bd(3,8)\", b: \"sd sd\"})).slow(4)"
      ],
      "synonyms": [
        "pickSqueeze"
      ],
      "originalName": "inhabit"
    },
    {
      "name": "inhabitmod",
      "description": "<p>The same as <code>inhabit</code>, but if you pick a number greater than the size of the list,\nit wraps around, rather than sticking at the maximum value.\nFor example, if you pick the fifth pattern of a list of three, you'll get the\nsecond one.</p>",
      "params": [
        {
          "name": "pat",
          "type": "Pattern",
          "description": ""
        },
        {
          "name": "xs",
          "type": "*",
          "description": ""
        }
      ],
      "examples": [],
      "synonyms": [
        "pickmodSqueeze"
      ],
      "originalName": "inhabitmod"
    },
    {
      "name": "inside",
      "description": "<p>Carries out an operation 'inside' a cycle.</p>",
      "params": [],
      "examples": [
        "\"0 1 2 3 4 3 2 1\".inside(4, rev).scale('C major').note()\r// \"0 1 2 3 4 3 2 1\".slow(4).rev().fast(4).scale('C major').note()"
      ],
      "synonyms": [],
      "originalName": "inside"
    },
    {
      "name": "into",
      "description": "<p>Breaks a pattern into pieces according to the structure of a given pattern.\nTrue values in the given pattern cause the corresponding subcycle of the\nsource pattern to be looped, and for an (optional) given function to be\napplied. False values result in the corresponding part of the source pattern\nto be played unchanged.</p>",
      "params": [],
      "examples": [
        "sound(\"bd sd ht lt\").into(\"1 0\", hurry(2))"
      ],
      "synonyms": [],
      "originalName": "into"
    },
    {
      "name": "inv",
      "description": "<p>Swaps 1s and 0s in a binary pattern.</p>",
      "params": [],
      "examples": [
        "s(\"bd\").struct(\"1 0 0 1 0 0 1 0\".lastOf(4, invert))"
      ],
      "synonyms": [
        "inv"
      ],
      "originalName": "invert"
    },
    {
      "name": "invert",
      "description": "<p>Swaps 1s and 0s in a binary pattern.</p>",
      "params": [],
      "examples": [
        "s(\"bd\").struct(\"1 0 0 1 0 0 1 0\".lastOf(4, invert))"
      ],
      "synonyms": [
        "inv"
      ],
      "originalName": "invert"
    },
    {
      "name": "ir",
      "description": "<p>Sets the sample to use as an impulse response for the reverb.</p>",
      "params": [
        {
          "name": "sample",
          "type": "string | Pattern",
          "description": "<p>to use as an impulse response</p>"
        }
      ],
      "examples": [
        "s(\"bd sd [~ bd] sd\").room(.8).ir(\"<shaker_large:0 shaker_large:2>\")"
      ],
      "synonyms": [
        "ir"
      ],
      "originalName": "iresponse"
    },
    {
      "name": "irand",
      "description": "<p>A continuous pattern of random integers, between 0 and n-1.</p>",
      "params": [
        {
          "name": "n",
          "type": "number",
          "description": "<p>max value (exclusive)</p>"
        }
      ],
      "examples": [
        "// randomly select scale notes from 0 - 7 (= C to C)\rn(irand(8)).struct(\"x x*2 x x*3\").scale(\"C:minor\")"
      ],
      "synonyms": [],
      "originalName": "irand"
    },
    {
      "name": "irbegin",
      "description": "<p>Sets the beginning of the IR response sample</p>",
      "params": [
        {
          "name": "begin",
          "type": "string | Pattern",
          "description": "<p>between 0 and 1</p>"
        }
      ],
      "examples": [
        "samples('github:switchangel/pad')\r$: s(\"brk/2\").fit().scrub(irand(16).div(16).seg(8)).ir(\"swpad:4\").room(.65).irspeed(\"-2\").irbegin(\"<0 .5 .75>/2\").roomsize(.6)"
      ],
      "synonyms": [
        "ir"
      ],
      "originalName": "irbegin"
    },
    {
      "name": "iresponse",
      "description": "<p>Sets the sample to use as an impulse response for the reverb.</p>",
      "params": [
        {
          "name": "sample",
          "type": "string | Pattern",
          "description": "<p>to use as an impulse response</p>"
        }
      ],
      "examples": [
        "s(\"bd sd [~ bd] sd\").room(.8).ir(\"<shaker_large:0 shaker_large:2>\")"
      ],
      "synonyms": [
        "ir"
      ],
      "originalName": "iresponse"
    },
    {
      "name": "irspeed",
      "description": "<p>Sets speed of the sample for the impulse response.</p>",
      "params": [
        {
          "name": "speed",
          "type": "string | Pattern",
          "description": ""
        }
      ],
      "examples": [
        "samples('github:switchangel/pad')\r$: s(\"brk/2\").fit().scrub(irand(16).div(16).seg(8)).ir(\"swpad:4\").room(.2).irspeed(\"<2 1 .5>/2\").irbegin(.5).roomsize(.5)"
      ],
      "synonyms": [],
      "originalName": "irspeed"
    },
    {
      "name": "isaw",
      "description": "<p>A sawtooth signal between 1 and 0 (like <code>saw</code>, but flipped).</p>",
      "params": [],
      "examples": [
        "note(\"<c3 [eb3,g3] g2 [g3,bb3]>*8\")\r.clip(isaw.slow(2))",
        "n(isaw.range(0,8).segment(8))\r.scale('C major')"
      ],
      "synonyms": [],
      "originalName": "isaw"
    },
    {
      "name": "isaw2",
      "description": "<p>A sawtooth signal between 1 and -1 (like <code>saw2</code>, but flipped).</p>",
      "params": [],
      "examples": [],
      "synonyms": [],
      "originalName": "isaw2"
    },
    {
      "name": "iter",
      "description": "<p>Divides a pattern into a given number of subdivisions, plays the subdivisions in order, but increments the starting subdivision each cycle. The pattern wraps to the first subdivision after the last subdivision is played.</p>",
      "params": [],
      "examples": [
        "note(\"0 1 2 3\".scale('A minor')).iter(4)"
      ],
      "synonyms": [],
      "originalName": "iter"
    },
    {
      "name": "iterback",
      "description": "<p>Like <code>iter</code>, but plays the subdivisions in reverse order. Known as iter' in tidalcycles</p>",
      "params": [],
      "examples": [
        "note(\"0 1 2 3\".scale('A minor')).iterBack(4)"
      ],
      "synonyms": [
        "iterback"
      ],
      "originalName": "iterBack"
    },
    {
      "name": "iterBack",
      "description": "<p>Like <code>iter</code>, but plays the subdivisions in reverse order. Known as iter' in tidalcycles</p>",
      "params": [],
      "examples": [
        "note(\"0 1 2 3\".scale('A minor')).iterBack(4)"
      ],
      "synonyms": [
        "iterback"
      ],
      "originalName": "iterBack"
    },
    {
      "name": "itri",
      "description": "<p>An inverted triangle signal between 1 and 0 (like <code>tri</code>, but flipped).</p>",
      "params": [],
      "examples": [
        "n(itri.segment(8).range(0,7)).scale(\"C:minor\")"
      ],
      "synonyms": [],
      "originalName": "itri"
    },
    {
      "name": "itri2",
      "description": "<p>An inverted triangle signal between -1 and 1 (like <code>itri</code>, but bipolar).</p>",
      "params": [],
      "examples": [],
      "synonyms": [],
      "originalName": "itri2"
    },
    {
      "name": "jux",
      "description": "<p>The jux function creates strange stereo effects, by applying a function to a pattern, but only in the right-hand channel.</p>",
      "params": [],
      "examples": [
        "s(\"bd lt [~ ht] mt cp ~ bd hh\").jux(rev)",
        "s(\"bd lt [~ ht] mt cp ~ bd hh\").jux(press)",
        "s(\"bd lt [~ ht] mt cp ~ bd hh\").jux(iter(4))"
      ],
      "synonyms": [],
      "originalName": "jux"
    },
    {
      "name": "juxby",
      "description": "<p>Jux with adjustable stereo width. 0 = mono, 1 = full stereo.</p>",
      "params": [],
      "examples": [
        "s(\"bd lt [~ ht] mt cp ~ bd hh\").juxBy(\"<0 .5 1>/2\", rev)"
      ],
      "synonyms": [
        "juxby"
      ],
      "originalName": "juxBy"
    },
    {
      "name": "juxBy",
      "description": "<p>Jux with adjustable stereo width. 0 = mono, 1 = full stereo.</p>",
      "params": [],
      "examples": [
        "s(\"bd lt [~ ht] mt cp ~ bd hh\").juxBy(\"<0 .5 1>/2\", rev)"
      ],
      "synonyms": [
        "juxby"
      ],
      "originalName": "juxBy"
    },
    {
      "name": "keyDown",
      "description": "<p>returns true when a key or array of keys is held\n<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/UI_Events/Keyboard_event_key_values\">Key name reference</a></p>",
      "params": [],
      "examples": [
        "keyDown(\"Control:j\").pick([s(\"bd(5,8)\"), s(\"cp(3,8)\")])"
      ],
      "synonyms": [],
      "originalName": "keyDown"
    },
    {
      "name": "label",
      "description": "<p>Sets the displayed text for an event on the pianoroll</p>",
      "params": [
        {
          "name": "label",
          "type": "string",
          "description": "<p>text to display</p>"
        }
      ],
      "examples": [],
      "synonyms": [],
      "originalName": "label"
    },
    {
      "name": "lastOf",
      "description": "<p>Applies the given function every n cycles, starting from the last cycle.</p>",
      "params": [
        {
          "name": "n",
          "type": "number",
          "description": "<p>how many cycles</p>"
        },
        {
          "name": "func",
          "type": "function",
          "description": "<p>function to apply</p>"
        }
      ],
      "examples": [
        "note(\"c3 d3 e3 g3\").lastOf(4, x=>x.rev())"
      ],
      "synonyms": [],
      "originalName": "lastOf"
    },
    {
      "name": "late",
      "description": "<p>Nudge a pattern to start later in time. Equivalent of Tidal's ~&gt; operator</p>",
      "params": [
        {
          "name": "cycles",
          "type": "number | Pattern",
          "description": "<p>number of cycles to nudge right</p>"
        }
      ],
      "examples": [
        "\"bd ~\".stack(\"hh ~\".late(.1)).s()"
      ],
      "synonyms": [],
      "originalName": "late"
    },
    {
      "name": "layer",
      "description": "<p>Layers the result of the given function(s). Like <code>superimpose</code>, but without the original pattern:</p>",
      "params": [],
      "examples": [
        "\"<0 2 4 6 ~ 4 ~ 2 0!3 ~!5>*8\"\r  .layer(x=>x.add(\"0,2\"))\r  .scale('C minor').note()"
      ],
      "synonyms": [
        "apply"
      ],
      "originalName": "layer"
    },
    {
      "name": "legato",
      "description": "<p>Multiplies the duration with the given number. Also cuts samples off at the end if they exceed the duration.</p>",
      "params": [
        {
          "name": "factor",
          "type": "number | Pattern",
          "description": "<blockquote>\n<p>= 0</p>\n</blockquote>"
        }
      ],
      "examples": [
        "note(\"c a f e\").s(\"piano\").clip(\"<.5 1 2>\")"
      ],
      "synonyms": [
        "legato"
      ],
      "originalName": "clip"
    },
    {
      "name": "leslie",
      "description": "<p>Emulation of a Leslie speaker: speakers rotating in a wooden amplified cabinet.</p>",
      "params": [
        {
          "name": "wet",
          "type": "number | Pattern",
          "description": "<p>between 0 and 1</p>"
        }
      ],
      "examples": [
        "n(\"0,4,7\").s(\"supersquare\").leslie(\"<0 .4 .6 1>\").osc()"
      ],
      "synonyms": [],
      "originalName": "leslie"
    },
    {
      "name": "linger",
      "description": "<p>Selects the given fraction of the pattern and repeats that part to fill the remainder of the cycle.</p>",
      "params": [
        {
          "name": "fraction",
          "type": "number",
          "description": "<p>fraction to select</p>"
        }
      ],
      "examples": [
        "s(\"lt ht mt cp, [hh oh]*2\").linger(\"<1 .5 .25 .125>\")"
      ],
      "synonyms": [],
      "originalName": "linger"
    },
    {
      "name": "lock",
      "description": "<p>Specifies whether delaytime is calculated relative to cps.</p>",
      "params": [
        {
          "name": "enable",
          "type": "number | Pattern",
          "description": "<p>When set to 1, delaytime is a direct multiple of a cycle.</p>"
        }
      ],
      "examples": [
        "s(\"sd\").delay().lock(1).osc()"
      ],
      "synonyms": [],
      "originalName": "lock"
    },
    {
      "name": "log",
      "description": "<p>Writes the content of the current event to the console (visible in the side menu).</p>",
      "params": [],
      "examples": [
        "s(\"bd sd\").log()"
      ],
      "synonyms": [],
      "originalName": "log"
    },
    {
      "name": "logValues",
      "description": "<p>A simplified version of <code>log</code> which writes all &quot;values&quot; (various configurable parameters)\nwithin the event to the console (visible in the side menu).</p>",
      "params": [],
      "examples": [
        "s(\"bd sd\").gain(\"0.25 0.5 1\").n(\"2 1 0\").logValues()"
      ],
      "synonyms": [],
      "originalName": "logValues"
    },
    {
      "name": "loop",
      "description": "<p>Loops the sample.\nNote that the tempo of the loop is not synced with the cycle tempo.\nTo change the loop region, use loopBegin / loopEnd.</p>",
      "params": [
        {
          "name": "on",
          "type": "number | Pattern",
          "description": "<p>If 1, the sample is looped</p>"
        }
      ],
      "examples": [
        "s(\"casio\").loop(1)"
      ],
      "synonyms": [],
      "originalName": "loop"
    },
    {
      "name": "loopAt",
      "description": "<p>Makes the sample fit the given number of cycles by changing the speed.</p>",
      "params": [],
      "examples": [
        "samples({ rhodes: 'https://cdn.freesound.org/previews/132/132051_316502-lq.mp3' })\rs(\"rhodes\").loopAt(2)"
      ],
      "synonyms": [],
      "originalName": "loopAt"
    },
    {
      "name": "loopAtCps",
      "description": "<p>Makes the sample fit the given number of cycles and cps value, by\nchanging the speed. Please note that at some point cps will be\ngiven by a global clock and this function will be\ndeprecated/removed.</p>",
      "params": [],
      "examples": [
        "samples({ rhodes: 'https://cdn.freesound.org/previews/132/132051_316502-lq.mp3' })\rs(\"rhodes\").loopAtCps(4,1.5).cps(1.5)"
      ],
      "synonyms": [],
      "originalName": "loopAtCps"
    },
    {
      "name": "loopb",
      "description": "<p>Begin to loop at a specific point in the sample (inbetween <code>begin</code> and <code>end</code>).\nNote that the loop point must be inbetween <code>begin</code> and <code>end</code>, and before <code>loopEnd</code>!\nNote: Samples starting with wt_ will automatically loop! (wt = wavetable)</p>",
      "params": [
        {
          "name": "time",
          "type": "number | Pattern",
          "description": "<p>between 0 and 1, where 1 is the length of the sample</p>"
        }
      ],
      "examples": [
        "s(\"space\").loop(1)\r.loopBegin(\"<0 .125 .25>\")._scope()"
      ],
      "synonyms": [
        "loopb"
      ],
      "originalName": "loopBegin"
    },
    {
      "name": "loopBegin",
      "description": "<p>Begin to loop at a specific point in the sample (inbetween <code>begin</code> and <code>end</code>).\nNote that the loop point must be inbetween <code>begin</code> and <code>end</code>, and before <code>loopEnd</code>!\nNote: Samples starting with wt_ will automatically loop! (wt = wavetable)</p>",
      "params": [
        {
          "name": "time",
          "type": "number | Pattern",
          "description": "<p>between 0 and 1, where 1 is the length of the sample</p>"
        }
      ],
      "examples": [
        "s(\"space\").loop(1)\r.loopBegin(\"<0 .125 .25>\")._scope()"
      ],
      "synonyms": [
        "loopb"
      ],
      "originalName": "loopBegin"
    },
    {
      "name": "loope",
      "description": "<p>End the looping section at a specific point in the sample (inbetween <code>begin</code> and <code>end</code>).\nNote that the loop point must be inbetween <code>begin</code> and <code>end</code>, and after <code>loopBegin</code>!</p>",
      "params": [
        {
          "name": "time",
          "type": "number | Pattern",
          "description": "<p>between 0 and 1, where 1 is the length of the sample</p>"
        }
      ],
      "examples": [
        "s(\"space\").loop(1)\r.loopEnd(\"<1 .75 .5 .25>\")._scope()"
      ],
      "synonyms": [
        "loope"
      ],
      "originalName": "loopEnd"
    },
    {
      "name": "loopEnd",
      "description": "<p>End the looping section at a specific point in the sample (inbetween <code>begin</code> and <code>end</code>).\nNote that the loop point must be inbetween <code>begin</code> and <code>end</code>, and after <code>loopBegin</code>!</p>",
      "params": [
        {
          "name": "time",
          "type": "number | Pattern",
          "description": "<p>between 0 and 1, where 1 is the length of the sample</p>"
        }
      ],
      "examples": [
        "s(\"space\").loop(1)\r.loopEnd(\"<1 .75 .5 .25>\")._scope()"
      ],
      "synonyms": [
        "loope"
      ],
      "originalName": "loopEnd"
    },
    {
      "name": "lp",
      "description": "<p>Applies the cutoff frequency of the <strong>l</strong>ow-<strong>p</strong>ass <strong>f</strong>ilter.</p>\n<p>When using mininotation, you can also optionally add the 'lpq' parameter, separated by ':'.</p>",
      "params": [
        {
          "name": "frequency",
          "type": "number | Pattern",
          "description": "<p>audible between 0 and 20000</p>"
        }
      ],
      "examples": [
        "s(\"bd sd [~ bd] sd,hh*6\").lpf(\"<4000 2000 1000 500 200 100>\")",
        "s(\"bd*16\").lpf(\"1000:0 1000:10 1000:20 1000:30\")"
      ],
      "synonyms": [
        "cutoff",
        "ctf",
        "lp"
      ],
      "originalName": "lpf"
    },
    {
      "name": "lpa",
      "description": "<p>Sets the attack duration for the lowpass filter envelope.</p>",
      "params": [
        {
          "name": "attack",
          "type": "number | Pattern",
          "description": "<p>time of the filter envelope</p>"
        }
      ],
      "examples": [
        "note(\"c2 e2 f2 g2\")\r.sound('sawtooth')\r.lpf(300)\r.lpa(\"<.5 .25 .1 .01>/4\")\r.lpenv(4)"
      ],
      "synonyms": [
        "lpa"
      ],
      "originalName": "lpattack"
    },
    {
      "name": "lpattack",
      "description": "<p>Sets the attack duration for the lowpass filter envelope.</p>",
      "params": [
        {
          "name": "attack",
          "type": "number | Pattern",
          "description": "<p>time of the filter envelope</p>"
        }
      ],
      "examples": [
        "note(\"c2 e2 f2 g2\")\r.sound('sawtooth')\r.lpf(300)\r.lpa(\"<.5 .25 .1 .01>/4\")\r.lpenv(4)"
      ],
      "synonyms": [
        "lpa"
      ],
      "originalName": "lpattack"
    },
    {
      "name": "lpd",
      "description": "<p>Sets the decay duration for the lowpass filter envelope.</p>",
      "params": [
        {
          "name": "decay",
          "type": "number | Pattern",
          "description": "<p>time of the filter envelope</p>"
        }
      ],
      "examples": [
        "note(\"c2 e2 f2 g2\")\r.sound('sawtooth')\r.lpf(300)\r.lpd(\"<.5 .25 .1 0>/4\")\r.lpenv(4)"
      ],
      "synonyms": [
        "lpd"
      ],
      "originalName": "lpdecay"
    },
    {
      "name": "lpdecay",
      "description": "<p>Sets the decay duration for the lowpass filter envelope.</p>",
      "params": [
        {
          "name": "decay",
          "type": "number | Pattern",
          "description": "<p>time of the filter envelope</p>"
        }
      ],
      "examples": [
        "note(\"c2 e2 f2 g2\")\r.sound('sawtooth')\r.lpf(300)\r.lpd(\"<.5 .25 .1 0>/4\")\r.lpenv(4)"
      ],
      "synonyms": [
        "lpd"
      ],
      "originalName": "lpdecay"
    },
    {
      "name": "lpe",
      "description": "<p>Sets the lowpass filter envelope modulation depth.</p>",
      "params": [
        {
          "name": "modulation",
          "type": "number | Pattern",
          "description": "<p>depth of the lowpass filter envelope between 0 and <em>n</em></p>"
        }
      ],
      "examples": [
        "note(\"c2 e2 f2 g2\")\r.sound('sawtooth')\r.lpf(300)\r.lpa(.5)\r.lpenv(\"<4 2 1 0 -1 -2 -4>/4\")"
      ],
      "synonyms": [
        "lpe"
      ],
      "originalName": "lpenv"
    },
    {
      "name": "lpenv",
      "description": "<p>Sets the lowpass filter envelope modulation depth.</p>",
      "params": [
        {
          "name": "modulation",
          "type": "number | Pattern",
          "description": "<p>depth of the lowpass filter envelope between 0 and <em>n</em></p>"
        }
      ],
      "examples": [
        "note(\"c2 e2 f2 g2\")\r.sound('sawtooth')\r.lpf(300)\r.lpa(.5)\r.lpenv(\"<4 2 1 0 -1 -2 -4>/4\")"
      ],
      "synonyms": [
        "lpe"
      ],
      "originalName": "lpenv"
    },
    {
      "name": "lpf",
      "description": "<p>Applies the cutoff frequency of the <strong>l</strong>ow-<strong>p</strong>ass <strong>f</strong>ilter.</p>\n<p>When using mininotation, you can also optionally add the 'lpq' parameter, separated by ':'.</p>",
      "params": [
        {
          "name": "frequency",
          "type": "number | Pattern",
          "description": "<p>audible between 0 and 20000</p>"
        }
      ],
      "examples": [
        "s(\"bd sd [~ bd] sd,hh*6\").lpf(\"<4000 2000 1000 500 200 100>\")",
        "s(\"bd*16\").lpf(\"1000:0 1000:10 1000:20 1000:30\")"
      ],
      "synonyms": [
        "cutoff",
        "ctf",
        "lp"
      ],
      "originalName": "lpf"
    },
    {
      "name": "lpq",
      "description": "<p>Controls the <strong>l</strong>ow-<strong>p</strong>ass <strong>q</strong>-value.</p>",
      "params": [
        {
          "name": "q",
          "type": "number | Pattern",
          "description": "<p>resonance factor between 0 and 50</p>"
        }
      ],
      "examples": [
        "s(\"bd sd [~ bd] sd,hh*8\").lpf(2000).lpq(\"<0 10 20 30>\")"
      ],
      "synonyms": [
        "resonance"
      ],
      "originalName": "lpq"
    },
    {
      "name": "lpr",
      "description": "<p>Sets the release time for the lowpass filter envelope.</p>",
      "params": [
        {
          "name": "release",
          "type": "number | Pattern",
          "description": "<p>time of the filter envelope</p>"
        }
      ],
      "examples": [
        "note(\"c2 e2 f2 g2\")\r.sound('sawtooth')\r.clip(.5)\r.lpf(300)\r.lpenv(4)\r.lpr(\"<.5 .25 .1 0>/4\")\r.release(.5)"
      ],
      "synonyms": [
        "lpr"
      ],
      "originalName": "lprelease"
    },
    {
      "name": "lprelease",
      "description": "<p>Sets the release time for the lowpass filter envelope.</p>",
      "params": [
        {
          "name": "release",
          "type": "number | Pattern",
          "description": "<p>time of the filter envelope</p>"
        }
      ],
      "examples": [
        "note(\"c2 e2 f2 g2\")\r.sound('sawtooth')\r.clip(.5)\r.lpf(300)\r.lpenv(4)\r.lpr(\"<.5 .25 .1 0>/4\")\r.release(.5)"
      ],
      "synonyms": [
        "lpr"
      ],
      "originalName": "lprelease"
    },
    {
      "name": "lps",
      "description": "<p>Sets the sustain amplitude for the lowpass filter envelope.</p>",
      "params": [
        {
          "name": "sustain",
          "type": "number | Pattern",
          "description": "<p>amplitude of the lowpass filter envelope</p>"
        }
      ],
      "examples": [
        "note(\"c2 e2 f2 g2\")\r.sound('sawtooth')\r.lpf(300)\r.lpd(.5)\r.lps(\"<0 .25 .5 1>/4\")\r.lpenv(4)"
      ],
      "synonyms": [
        "lps"
      ],
      "originalName": "lpsustain"
    },
    {
      "name": "lpsustain",
      "description": "<p>Sets the sustain amplitude for the lowpass filter envelope.</p>",
      "params": [
        {
          "name": "sustain",
          "type": "number | Pattern",
          "description": "<p>amplitude of the lowpass filter envelope</p>"
        }
      ],
      "examples": [
        "note(\"c2 e2 f2 g2\")\r.sound('sawtooth')\r.lpf(300)\r.lpd(.5)\r.lps(\"<0 .25 .5 1>/4\")\r.lpenv(4)"
      ],
      "synonyms": [
        "lps"
      ],
      "originalName": "lpsustain"
    },
    {
      "name": "lrate",
      "description": "<p>Rate of modulation / rotation for leslie effect</p>",
      "params": [
        {
          "name": "rate",
          "type": "number | Pattern",
          "description": "<p>6.7 for fast, 0.7 for slow</p>"
        }
      ],
      "examples": [
        "n(\"0,4,7\").s(\"supersquare\").leslie(1).lrate(\"<1 2 4 8>\").osc()"
      ],
      "synonyms": [],
      "originalName": "lrate"
    },
    {
      "name": "lsize",
      "description": "<p>Physical size of the cabinet in meters. Be careful, it might be slightly larger than your computer. Affects the Doppler amount (pitch warble)</p>",
      "params": [
        {
          "name": "meters",
          "type": "number | Pattern",
          "description": "<p>somewhere between 0 and 1</p>"
        }
      ],
      "examples": [
        "n(\"0,4,7\").s(\"supersquare\").leslie(1).lrate(2).lsize(\"<.1 .5 1>\").osc()"
      ],
      "synonyms": [],
      "originalName": "lsize"
    },
    {
      "name": "markcss",
      "description": "<p>Overrides the css of highlighted events. Make sure to use single quotes!</p>",
      "params": [],
      "examples": [
        "note(\"c a f e\")\r.markcss('text-decoration:underline')"
      ],
      "synonyms": [],
      "originalName": "markcss"
    },
    {
      "name": "mask",
      "description": "<p>Returns silence when mask is 0 or &quot;~&quot;</p>",
      "params": [],
      "examples": [
        "note(\"c [eb,g] d [eb,g]\").mask(\"<1 [0 1]>\")"
      ],
      "synonyms": [],
      "originalName": "mask"
    },
    {
      "name": "midi",
      "description": "<p>MIDI output: Opens a MIDI output port.</p>",
      "params": [
        {
          "name": "midiport",
          "type": "string | number",
          "description": "<p>MIDI device name or index defaulting to 0</p>"
        },
        {
          "name": "options",
          "type": "object",
          "description": "<p>Additional MIDI configuration options</p>"
        }
      ],
      "examples": [
        "note(\"c4\").midichan(1).midi('IAC Driver Bus 1')",
        "note(\"c4\").midichan(1).midi('IAC Driver Bus 1', { controller: true, latency: 50 })"
      ],
      "synonyms": [],
      "originalName": "midi"
    },
    {
      "name": "midi2note",
      "description": "",
      "params": [],
      "examples": [],
      "synonyms": [],
      "originalName": "midi2note"
    },
    {
      "name": "midibend",
      "description": "<p>MIDI pitch bend: Sends a MIDI pitch bend message.</p>",
      "params": [
        {
          "name": "midibend",
          "type": "number | Pattern",
          "description": "<p>MIDI pitch bend (-1 - 1)</p>"
        }
      ],
      "examples": [
        "note(\"c4\").midibend(sine.slow(4).range(-0.4,0.4)).midi()"
      ],
      "synonyms": [],
      "originalName": "midibend"
    },
    {
      "name": "midichan",
      "description": "<p>MIDI channel: Sets the MIDI channel for the event.</p>",
      "params": [
        {
          "name": "channel",
          "type": "number | Pattern",
          "description": "<p>MIDI channel number (0-15)</p>"
        }
      ],
      "examples": [
        "note(\"c4\").midichan(1).midi()"
      ],
      "synonyms": [],
      "originalName": "midichan"
    },
    {
      "name": "midicmd",
      "description": "<p>MIDI command: Sends a MIDI command message.</p>",
      "params": [
        {
          "name": "command",
          "type": "number | Pattern",
          "description": "<p>MIDI command</p>"
        }
      ],
      "examples": [
        "midicmd(\"clock*48,<start stop>/2\").midi()"
      ],
      "synonyms": [],
      "originalName": "midicmd"
    },
    {
      "name": "midimaps",
      "description": "<p>Adds midimaps to the registry. Inside each midimap, control names (e.g. lpf) are mapped to cc numbers.</p>",
      "params": [],
      "examples": [
        "midimaps({ mymap: { lpf: 74 } })\r$: note(\"c a f e\")\r.lpf(sine.slow(4))\r.midimap('mymap')\r.midi()",
        "midimaps({ mymap: {\r  lpf: { ccn: 74, min: 0, max: 20000, exp: 0.5 }\r}})\r$: note(\"c a f e\")\r.lpf(sine.slow(2).range(400,2000))\r.midimap('mymap')\r.midi()"
      ],
      "synonyms": [],
      "originalName": "midimaps"
    },
    {
      "name": "midin",
      "description": "<p>MIDI input: Opens a MIDI input port to receive MIDI control change messages.</p>",
      "params": [
        {
          "name": "input",
          "type": "string | number",
          "description": "<p>MIDI device name or index defaulting to 0</p>"
        }
      ],
      "examples": [
        "let cc = await midin('IAC Driver Bus 1')\rnote(\"c a f e\").lpf(cc(0).range(0, 1000)).lpq(cc(1).range(0, 10)).sound(\"sawtooth\")"
      ],
      "synonyms": [],
      "originalName": "midin"
    },
    {
      "name": "midiport",
      "description": "<p>MIDI port: Sets the MIDI port for the event.</p>",
      "params": [
        {
          "name": "port",
          "type": "number | Pattern",
          "description": "<p>MIDI port</p>"
        }
      ],
      "examples": [
        "note(\"c a f e\").midiport(\"<0 1 2 3>\").midi()"
      ],
      "synonyms": [],
      "originalName": "midiport"
    },
    {
      "name": "miditouch",
      "description": "<p>MIDI key after touch: Sends a MIDI key after touch message.</p>",
      "params": [
        {
          "name": "miditouch",
          "type": "number | Pattern",
          "description": "<p>MIDI key after touch (0-1)</p>"
        }
      ],
      "examples": [
        "note(\"c4\").miditouch(sine.slow(4).range(0,1)).midi()"
      ],
      "synonyms": [],
      "originalName": "miditouch"
    },
    {
      "name": "mode",
      "description": "<p>Remove anchor note from the voicing. Useful for melody harmonization</p>",
      "params": [
        {
          "name": "modeName",
          "type": "string | Pattern",
          "description": "<p>one of {below | above | duck | root}</p>"
        }
      ],
      "examples": [
        "mode(\"<below above duck root>\").chord(\"C\").voicing()"
      ],
      "synonyms": [],
      "originalName": "mode"
    },
    {
      "name": "morph",
      "description": "<p>Takes two binary rhythms represented as lists of 1s and 0s, and a number\nbetween 0 and 1 that morphs between them. The two lists should contain the same\nnumber of true values.</p>",
      "params": [],
      "examples": [
        "sound(\"hh\").struct(morph([1,0,1,0,1,0,1,0], // straight rhythm\r                         [1,1,0,1,0,1,0], // wonky rhythm\r                         0.25 // creates a slightly wonky rhythm\r                        )\r                  )",
        "sound(\"hh\").struct(morph(\"1:0:1:0:1:0:1:0\", // straight rhythm\r                         \"1:1:0:1:0:1:0\", // wonky rhythm\r                         sine.slow(8) // slowly morph between the rhythms\r                        )\r                  )"
      ],
      "synonyms": [],
      "originalName": "morph"
    },
    {
      "name": "mousex",
      "description": "<p>The mouse's x position value ranges from 0 to 1.</p>",
      "params": [],
      "examples": [
        "n(mousex.segment(4).range(0,7)).scale(\"C:minor\")"
      ],
      "synonyms": [],
      "originalName": "mousex"
    },
    {
      "name": "mousey",
      "description": "<p>The mouse's y position value ranges from 0 to 1.</p>",
      "params": [],
      "examples": [
        "n(mousey.segment(4).range(0,7)).scale(\"C:minor\")"
      ],
      "synonyms": [],
      "originalName": "mousey"
    },
    {
      "name": "mul",
      "description": "<p>Multiplies each number by the given factor.</p>",
      "params": [],
      "examples": [
        "\"<1 1.5 [1.66, <2 2.33>]>*4\".mul(150).freq()"
      ],
      "synonyms": [],
      "originalName": "mul"
    },
    {
      "name": "n",
      "description": "<p>Selects the given index from the sample map.\nNumbers too high will wrap around.\n<code>n</code> can also be used to play midi numbers, but it is recommended to use <code>note</code> instead.</p>",
      "params": [
        {
          "name": "value",
          "type": "number | Pattern",
          "description": "<p>sample index starting from 0</p>"
        }
      ],
      "examples": [
        "s(\"bd sd [~ bd] sd,hh*6\").n(\"<0 1>\")"
      ],
      "synonyms": [],
      "originalName": "n"
    },
    {
      "name": "never",
      "description": "<p>Shorthand for <code>.sometimesBy(0, fn)</code> (never calls fn)</p>",
      "params": [],
      "examples": [
        "s(\"hh*8\").never(x=>x.speed(\"0.5\"))"
      ],
      "synonyms": [],
      "originalName": "never"
    },
    {
      "name": "noise",
      "description": "<p>Adds pink noise to the mix</p>",
      "params": [
        {
          "name": "wet",
          "type": "number | Pattern",
          "description": "<p>wet amount</p>"
        }
      ],
      "examples": [
        "sound(\"<white pink brown>/2\")"
      ],
      "synonyms": [],
      "originalName": "noise"
    },
    {
      "name": "note",
      "description": "<p>Plays the given note name or midi number. A note name consists of</p>\n<ul>\n<li>a letter (a-g or A-G)</li>\n<li>optional accidentals (b or #)</li>\n<li>optional (possibly negative) octave number (0-9). Defaults to 3</li>\n</ul>\n<p>Examples of valid note names: <code>c</code>, <code>bb</code>, <code>Bb</code>, <code>f#</code>, <code>c3</code>, <code>A4</code>, <code>Eb2</code>, <code>c#5</code></p>\n<p>You can also use midi numbers instead of note names, where 69 is mapped to A4 440Hz in 12EDO.</p>",
      "params": [],
      "examples": [
        "note(\"c a f e\")",
        "note(\"c4 a4 f4 e4\")",
        "note(\"60 69 65 64\")",
        "note(\"fbb1 a#0 cbbb-1 e##-2\").sound(\"saw\")"
      ],
      "synonyms": [],
      "originalName": "note"
    },
    {
      "name": "nrpnn",
      "description": "<p>MIDI NRPN non-registered parameter number: Sends a MIDI NRPN non-registered parameter number message.</p>",
      "params": [
        {
          "name": "nrpnn",
          "type": "number | Pattern",
          "description": "<p>MIDI NRPN non-registered parameter number (0-127)</p>"
        }
      ],
      "examples": [
        "note(\"c4\").nrpnn(\"1:8\").nrpv(\"123\").midichan(1).midi()"
      ],
      "synonyms": [],
      "originalName": "nrpnn"
    },
    {
      "name": "nrpv",
      "description": "<p>MIDI NRPN non-registered parameter value: Sends a MIDI NRPN non-registered parameter value message.</p>",
      "params": [
        {
          "name": "nrpv",
          "type": "number | Pattern",
          "description": "<p>MIDI NRPN non-registered parameter value (0-127)</p>"
        }
      ],
      "examples": [
        "note(\"c4\").nrpnn(\"1:8\").nrpv(\"123\").midichan(1).midi()"
      ],
      "synonyms": [],
      "originalName": "nrpv"
    },
    {
      "name": "octave",
      "description": "<p>Sets the default octave of a synth.</p>",
      "params": [
        {
          "name": "octave",
          "type": "number | Pattern",
          "description": "<p>octave number</p>"
        }
      ],
      "examples": [
        "n(\"0,4,7\").s('supersquare').octave(\"<3 4 5 6>\").osc()"
      ],
      "synonyms": [],
      "originalName": "octave"
    },
    {
      "name": "octaves",
      "description": "<p>How many octaves are voicing steps spread apart, defaults to 1</p>",
      "params": [
        {
          "name": "count",
          "type": "number | Pattern",
          "description": "<p>the number of octaves</p>"
        }
      ],
      "examples": [
        "chord(\"<Am C D F Am E Am E>\").octaves(\"<2 4>\").voicing()"
      ],
      "synonyms": [],
      "originalName": "octaves"
    },
    {
      "name": "off",
      "description": "<p>Superimposes the function result on top of the original pattern, delayed by the given time.</p>",
      "params": [
        {
          "name": "time",
          "type": "Pattern | number",
          "description": "<p>offset time</p>"
        },
        {
          "name": "func",
          "type": "function",
          "description": "<p>function to apply</p>"
        }
      ],
      "examples": [
        "\"c3 eb3 g3\".off(1/8, x=>x.add(7)).note()"
      ],
      "synonyms": [],
      "originalName": "off"
    },
    {
      "name": "offset",
      "description": "<p>Sets how the voicing is offset from the anchored position</p>",
      "params": [
        {
          "name": "shift",
          "type": "number | Pattern",
          "description": "<p>the amount to shift the voicing up or down</p>"
        }
      ],
      "examples": [
        "chord(\"<Am C D F Am E Am E>\").offset(\"<0 1 2 3 4 5>\") // alter the voicing each time"
      ],
      "synonyms": [],
      "originalName": "offset"
    },
    {
      "name": "often",
      "description": "<p>Shorthand for <code>.sometimesBy(0.75, fn)</code></p>",
      "params": [],
      "examples": [
        "s(\"hh*8\").often(x=>x.speed(\"0.5\"))"
      ],
      "synonyms": [],
      "originalName": "often"
    },
    {
      "name": "OLAProcessor",
      "description": "",
      "params": [],
      "examples": [],
      "synonyms": [],
      "originalName": "OLAProcessor"
    },
    {
      "name": "onsetsOnly",
      "description": "<p>Returns a new pattern, with all haps without onsets filtered out. A hap\nwith an onset is one with a <code>whole</code> timespan that begins at the same time\nas its <code>part</code> timespan.</p>",
      "params": [],
      "examples": [],
      "synonyms": [],
      "originalName": "onsetsOnly"
    },
    {
      "name": "onTriggerTime",
      "description": "<p>make something happen on event time\nuses browser timeout which is innacurate for audio tasks</p>",
      "params": [],
      "examples": [
        "s(\"bd!8\").onTriggerTime((hap) => {console.log(hap)})"
      ],
      "synonyms": [],
      "originalName": "onTriggerTime"
    },
    {
      "name": "orbit",
      "description": "<p>An <code>orbit</code> is a global parameter context for patterns. Patterns with the same orbit will share the same global effects.</p>",
      "params": [
        {
          "name": "number",
          "type": "number | Pattern",
          "description": ""
        }
      ],
      "examples": [
        "stack(\r  s(\"hh*6\").delay(.5).delaytime(.25).orbit(1),\r  s(\"~ sd ~ sd\").delay(.5).delaytime(.125).orbit(2)\r)"
      ],
      "synonyms": [],
      "originalName": "orbit"
    },
    {
      "name": "oriA",
      "description": "<p>The device's orientation alpha value ranges from 0 to 1.</p>",
      "params": [],
      "examples": [
        "n(orientationAlpha.segment(4).range(0,7)).scale(\"C:minor\")"
      ],
      "synonyms": [
        "oriA",
        "oriZ",
        "orientationZ"
      ],
      "originalName": "orientationAlpha"
    },
    {
      "name": "oriB",
      "description": "<p>The device's orientation beta value ranges from 0 to 1.</p>",
      "params": [],
      "examples": [
        "n(orientationBeta.segment(4).range(0,7)).scale(\"C:minor\")"
      ],
      "synonyms": [
        "oriB",
        "oriX",
        "orientationX"
      ],
      "originalName": "orientationBeta"
    },
    {
      "name": "orientationAlpha",
      "description": "<p>The device's orientation alpha value ranges from 0 to 1.</p>",
      "params": [],
      "examples": [
        "n(orientationAlpha.segment(4).range(0,7)).scale(\"C:minor\")"
      ],
      "synonyms": [
        "oriA",
        "oriZ",
        "orientationZ"
      ],
      "originalName": "orientationAlpha"
    },
    {
      "name": "orientationBeta",
      "description": "<p>The device's orientation beta value ranges from 0 to 1.</p>",
      "params": [],
      "examples": [
        "n(orientationBeta.segment(4).range(0,7)).scale(\"C:minor\")"
      ],
      "synonyms": [
        "oriB",
        "oriX",
        "orientationX"
      ],
      "originalName": "orientationBeta"
    },
    {
      "name": "orientationGamma",
      "description": "<p>The device's orientation gamma value ranges from 0 to 1.</p>",
      "params": [],
      "examples": [
        "n(orientationGamma.segment(4).range(0,7)).scale(\"C:minor\")"
      ],
      "synonyms": [
        "oriG",
        "oriY",
        "orientationY"
      ],
      "originalName": "orientationGamma"
    },
    {
      "name": "orientationX",
      "description": "<p>The device's orientation beta value ranges from 0 to 1.</p>",
      "params": [],
      "examples": [
        "n(orientationBeta.segment(4).range(0,7)).scale(\"C:minor\")"
      ],
      "synonyms": [
        "oriB",
        "oriX",
        "orientationX"
      ],
      "originalName": "orientationBeta"
    },
    {
      "name": "orientationY",
      "description": "<p>The device's orientation gamma value ranges from 0 to 1.</p>",
      "params": [],
      "examples": [
        "n(orientationGamma.segment(4).range(0,7)).scale(\"C:minor\")"
      ],
      "synonyms": [
        "oriG",
        "oriY",
        "orientationY"
      ],
      "originalName": "orientationGamma"
    },
    {
      "name": "orientationZ",
      "description": "<p>The device's orientation alpha value ranges from 0 to 1.</p>",
      "params": [],
      "examples": [
        "n(orientationAlpha.segment(4).range(0,7)).scale(\"C:minor\")"
      ],
      "synonyms": [
        "oriA",
        "oriZ",
        "orientationZ"
      ],
      "originalName": "orientationAlpha"
    },
    {
      "name": "oriG",
      "description": "<p>The device's orientation gamma value ranges from 0 to 1.</p>",
      "params": [],
      "examples": [
        "n(orientationGamma.segment(4).range(0,7)).scale(\"C:minor\")"
      ],
      "synonyms": [
        "oriG",
        "oriY",
        "orientationY"
      ],
      "originalName": "orientationGamma"
    },
    {
      "name": "oriX",
      "description": "<p>The device's orientation beta value ranges from 0 to 1.</p>",
      "params": [],
      "examples": [
        "n(orientationBeta.segment(4).range(0,7)).scale(\"C:minor\")"
      ],
      "synonyms": [
        "oriB",
        "oriX",
        "orientationX"
      ],
      "originalName": "orientationBeta"
    },
    {
      "name": "oriY",
      "description": "<p>The device's orientation gamma value ranges from 0 to 1.</p>",
      "params": [],
      "examples": [
        "n(orientationGamma.segment(4).range(0,7)).scale(\"C:minor\")"
      ],
      "synonyms": [
        "oriG",
        "oriY",
        "orientationY"
      ],
      "originalName": "orientationGamma"
    },
    {
      "name": "oriZ",
      "description": "<p>The device's orientation alpha value ranges from 0 to 1.</p>",
      "params": [],
      "examples": [
        "n(orientationAlpha.segment(4).range(0,7)).scale(\"C:minor\")"
      ],
      "synonyms": [
        "oriA",
        "oriZ",
        "orientationZ"
      ],
      "originalName": "orientationAlpha"
    },
    {
      "name": "osc",
      "description": "<p>Sends each hap as an OSC message, which can be picked up by SuperCollider or any other OSC-enabled software.\nFor more info, read <a href=\"https://strudel.cc/learn/input-output/\">MIDI &amp; OSC in the docs</a></p>",
      "params": [],
      "examples": [],
      "synonyms": [],
      "originalName": "osc"
    },
    {
      "name": "oschost",
      "description": "<p>The host to send open sound control messages to. Requires running the OSC bridge.</p>",
      "params": [
        {
          "name": "oschost",
          "type": "string | Pattern",
          "description": "<p>e.g. 'localhost'</p>"
        }
      ],
      "examples": [
        "note(\"c4\").oschost('127.0.0.1').oscport(57120).osc();"
      ],
      "synonyms": [],
      "originalName": "oschost"
    },
    {
      "name": "oscport",
      "description": "<p>The port to send open sound control messages to. Requires running the OSC bridge.</p>",
      "params": [
        {
          "name": "oscport",
          "type": "number | Pattern",
          "description": "<p>e.g. 57120</p>"
        }
      ],
      "examples": [
        "note(\"c4\").oschost('127.0.0.1').oscport(57120).osc();"
      ],
      "synonyms": [],
      "originalName": "oscport"
    },
    {
      "name": "out",
      "description": "",
      "params": [],
      "examples": [],
      "synonyms": [],
      "originalName": "out"
    },
    {
      "name": "outside",
      "description": "<p>Carries out an operation 'outside' a cycle.</p>",
      "params": [],
      "examples": [
        "\"<[0 1] 2 [3 4] 5>\".outside(4, rev).scale('C major').note()\r// \"<[0 1] 2 [3 4] 5>\".fast(4).rev().slow(4).scale('C major').note()"
      ],
      "synonyms": [],
      "originalName": "outside"
    },
    {
      "name": "pace",
      "description": "<p><em>Experimental</em></p>\n<p>Speeds a pattern up or down, to fit to the given number of steps per cycle.</p>",
      "params": [],
      "examples": [
        "sound(\"bd sd cp\").pace(4)\r// The same as sound(\"{bd sd cp}%4\") or sound(\"<bd sd cp>*4\")"
      ],
      "synonyms": [],
      "originalName": "pace"
    },
    {
      "name": "palindrome",
      "description": "<p>Applies <code>rev</code> to a pattern every other cycle, so that the pattern alternates between forwards and backwards.</p>",
      "params": [],
      "examples": [
        "note(\"c d e g\").palindrome()"
      ],
      "synonyms": [],
      "originalName": "palindrome"
    },
    {
      "name": "pan",
      "description": "<p>Sets position in stereo.</p>",
      "params": [
        {
          "name": "pan",
          "type": "number | Pattern",
          "description": "<p>between 0 and 1, from left to right (assuming stereo), once round a circle (assuming multichannel)</p>"
        }
      ],
      "examples": [
        "s(\"[bd hh]*2\").pan(\"<.5 1 .5 0>\")",
        "s(\"bd rim sd rim bd ~ cp rim\").pan(sine.slow(2))"
      ],
      "synonyms": [],
      "originalName": "pan"
    },
    {
      "name": "panchor",
      "description": "<p>Sets the range anchor of the envelope:</p>\n<ul>\n<li>anchor 0: range = [note, note + penv]</li>\n<li>anchor 1: range = [note - penv, note]\nIf you don't set an anchor, the value will default to the psustain value.</li>\n</ul>",
      "params": [
        {
          "name": "anchor",
          "type": "number | Pattern",
          "description": "<p>anchor offset</p>"
        }
      ],
      "examples": [
        "note(\"c c4\").penv(12).panchor(\"<0 .5 1 .5>\")"
      ],
      "synonyms": [],
      "originalName": "panchor"
    },
    {
      "name": "patt",
      "description": "<p>Attack time of pitch envelope.</p>",
      "params": [
        {
          "name": "time",
          "type": "number | Pattern",
          "description": "<p>time in seconds</p>"
        }
      ],
      "examples": [
        "note(\"c eb g bb\").pattack(\"0 .1 .25 .5\").slow(2)"
      ],
      "synonyms": [
        "patt"
      ],
      "originalName": "pattack"
    },
    {
      "name": "pattack",
      "description": "<p>Attack time of pitch envelope.</p>",
      "params": [
        {
          "name": "time",
          "type": "number | Pattern",
          "description": "<p>time in seconds</p>"
        }
      ],
      "examples": [
        "note(\"c eb g bb\").pattack(\"0 .1 .25 .5\").slow(2)"
      ],
      "synonyms": [
        "patt"
      ],
      "originalName": "pattack"
    },
    {
      "name": "Pattern",
      "description": "<p>Create a pattern. As an end user, you will most likely not create a Pattern directly.</p>",
      "params": [
        {
          "name": "query",
          "type": "function",
          "description": "<p>The function that maps a <code>State</code> to an array of <code>Hap</code>.</p>"
        }
      ],
      "examples": [],
      "synonyms": [],
      "originalName": "Pattern"
    },
    {
      "name": "pcurve",
      "description": "<p>Curve of envelope. Defaults to linear. exponential is good for kicks</p>",
      "params": [
        {
          "name": "type",
          "type": "number | Pattern",
          "description": "<p>0 = linear, 1 = exponential</p>"
        }
      ],
      "examples": [
        "note(\"g1*4\")\r.s(\"sine\").pdec(.5)\r.penv(32)\r.pcurve(\"<0 1>\")"
      ],
      "synonyms": [],
      "originalName": "pcurve"
    },
    {
      "name": "pdec",
      "description": "<p>Decay time of pitch envelope.</p>",
      "params": [
        {
          "name": "time",
          "type": "number | Pattern",
          "description": "<p>time in seconds</p>"
        }
      ],
      "examples": [
        "note(\"<c eb g bb>\").pdecay(\"<0 .1 .25 .5>\")"
      ],
      "synonyms": [
        "pdec"
      ],
      "originalName": "pdecay"
    },
    {
      "name": "pdecay",
      "description": "<p>Decay time of pitch envelope.</p>",
      "params": [
        {
          "name": "time",
          "type": "number | Pattern",
          "description": "<p>time in seconds</p>"
        }
      ],
      "examples": [
        "note(\"<c eb g bb>\").pdecay(\"<0 .1 .25 .5>\")"
      ],
      "synonyms": [
        "pdec"
      ],
      "originalName": "pdecay"
    },
    {
      "name": "penv",
      "description": "<p>Amount of pitch envelope. Negative values will flip the envelope.\nIf you don't set other pitch envelope controls, <code>pattack:.2</code> will be the default.</p>",
      "params": [
        {
          "name": "semitones",
          "type": "number | Pattern",
          "description": "<p>change in semitones</p>"
        }
      ],
      "examples": [
        "note(\"c\")\r.penv(\"<12 7 1 .5 0 -1 -7 -12>\")"
      ],
      "synonyms": [],
      "originalName": "penv"
    },
    {
      "name": "perlin",
      "description": "<p>Generates a continuous pattern of <a href=\"https://en.wikipedia.org/wiki/Perlin_noise\">perlin noise</a>, in the range 0..1.</p>",
      "params": [],
      "examples": [
        "// randomly change the cutoff\rs(\"bd*4,hh*8\").cutoff(perlin.range(500,8000))"
      ],
      "synonyms": [],
      "originalName": "perlin"
    },
    {
      "name": "ph",
      "description": "<p>Phaser audio effect that approximates popular guitar pedals.</p>",
      "params": [
        {
          "name": "speed",
          "type": "number | Pattern",
          "description": "<p>speed of modulation</p>"
        }
      ],
      "examples": [
        "n(run(8)).scale(\"D:pentatonic\").s(\"sawtooth\").release(0.5)\r.phaser(\"<1 2 4 8>\")"
      ],
      "synonyms": [
        "ph"
      ],
      "originalName": "phaser"
    },
    {
      "name": "phasdp",
      "description": "<p>The amount the signal is affected by the phaser effect. Defaults to 0.75</p>",
      "params": [
        {
          "name": "depth",
          "type": "number | Pattern",
          "description": "<p>number between 0 and 1</p>"
        }
      ],
      "examples": [
        "n(run(8)).scale(\"D:pentatonic\").s(\"sawtooth\").release(0.5)\r.phaser(2).phaserdepth(\"<0 .5 .75 1>\")"
      ],
      "synonyms": [
        "phd",
        "phasdp"
      ],
      "originalName": "phaserdepth"
    },
    {
      "name": "phaser",
      "description": "<p>Phaser audio effect that approximates popular guitar pedals.</p>",
      "params": [
        {
          "name": "speed",
          "type": "number | Pattern",
          "description": "<p>speed of modulation</p>"
        }
      ],
      "examples": [
        "n(run(8)).scale(\"D:pentatonic\").s(\"sawtooth\").release(0.5)\r.phaser(\"<1 2 4 8>\")"
      ],
      "synonyms": [
        "ph"
      ],
      "originalName": "phaser"
    },
    {
      "name": "phasercenter",
      "description": "<p>The center frequency of the phaser in HZ. Defaults to 1000</p>",
      "params": [
        {
          "name": "centerfrequency",
          "type": "number | Pattern",
          "description": "<p>in HZ</p>"
        }
      ],
      "examples": [
        "n(run(8)).scale(\"D:pentatonic\").s(\"sawtooth\").release(0.5)\r.phaser(2).phasercenter(\"<800 2000 4000>\")"
      ],
      "synonyms": [
        "phc"
      ],
      "originalName": "phasercenter"
    },
    {
      "name": "phaserdepth",
      "description": "<p>The amount the signal is affected by the phaser effect. Defaults to 0.75</p>",
      "params": [
        {
          "name": "depth",
          "type": "number | Pattern",
          "description": "<p>number between 0 and 1</p>"
        }
      ],
      "examples": [
        "n(run(8)).scale(\"D:pentatonic\").s(\"sawtooth\").release(0.5)\r.phaser(2).phaserdepth(\"<0 .5 .75 1>\")"
      ],
      "synonyms": [
        "phd",
        "phasdp"
      ],
      "originalName": "phaserdepth"
    },
    {
      "name": "phasersweep",
      "description": "<p>The frequency sweep range of the lfo for the phaser effect. Defaults to 2000</p>",
      "params": [
        {
          "name": "phasersweep",
          "type": "number | Pattern",
          "description": "<p>most useful values are between 0 and 4000</p>"
        }
      ],
      "examples": [
        "n(run(8)).scale(\"D:pentatonic\").s(\"sawtooth\").release(0.5)\r.phaser(2).phasersweep(\"<800 2000 4000>\")"
      ],
      "synonyms": [
        "phs"
      ],
      "originalName": "phasersweep"
    },
    {
      "name": "phc",
      "description": "<p>The center frequency of the phaser in HZ. Defaults to 1000</p>",
      "params": [
        {
          "name": "centerfrequency",
          "type": "number | Pattern",
          "description": "<p>in HZ</p>"
        }
      ],
      "examples": [
        "n(run(8)).scale(\"D:pentatonic\").s(\"sawtooth\").release(0.5)\r.phaser(2).phasercenter(\"<800 2000 4000>\")"
      ],
      "synonyms": [
        "phc"
      ],
      "originalName": "phasercenter"
    },
    {
      "name": "phd",
      "description": "<p>The amount the signal is affected by the phaser effect. Defaults to 0.75</p>",
      "params": [
        {
          "name": "depth",
          "type": "number | Pattern",
          "description": "<p>number between 0 and 1</p>"
        }
      ],
      "examples": [
        "n(run(8)).scale(\"D:pentatonic\").s(\"sawtooth\").release(0.5)\r.phaser(2).phaserdepth(\"<0 .5 .75 1>\")"
      ],
      "synonyms": [
        "phd",
        "phasdp"
      ],
      "originalName": "phaserdepth"
    },
    {
      "name": "phs",
      "description": "<p>The frequency sweep range of the lfo for the phaser effect. Defaults to 2000</p>",
      "params": [
        {
          "name": "phasersweep",
          "type": "number | Pattern",
          "description": "<p>most useful values are between 0 and 4000</p>"
        }
      ],
      "examples": [
        "n(run(8)).scale(\"D:pentatonic\").s(\"sawtooth\").release(0.5)\r.phaser(2).phasersweep(\"<800 2000 4000>\")"
      ],
      "synonyms": [
        "phs"
      ],
      "originalName": "phasersweep"
    },
    {
      "name": "pianoroll",
      "description": "<p>Visualises a pattern as a scrolling 'pianoroll', displayed in the background of the editor. To show a pianoroll for all running patterns, use <code>all(pianoroll)</code>. To have a pianoroll appear below\na pattern instead, prefix with <code>_</code>, e.g.: <code>sound(&quot;bd sd&quot;)._pianoroll()</code>.</p>",
      "params": [
        {
          "name": "options",
          "type": "Object",
          "description": "<p>Object containing all the optional following parameters as key value pairs:</p>"
        },
        {
          "name": "cycles",
          "type": "integer",
          "description": "<p>number of cycles to be displayed at the same time - defaults to 4</p>"
        },
        {
          "name": "playhead",
          "type": "number",
          "description": "<p>location of the active notes on the time axis - 0 to 1, defaults to 0.5</p>"
        },
        {
          "name": "vertical",
          "type": "boolean",
          "description": "<p>displays the roll vertically - 0 by default</p>"
        },
        {
          "name": "labels",
          "type": "boolean",
          "description": "<p>displays labels on individual notes (see the label function) - 0 by default</p>"
        },
        {
          "name": "flipTime",
          "type": "boolean",
          "description": "<p>reverse the direction of the roll - 0 by default</p>"
        },
        {
          "name": "flipValues",
          "type": "boolean",
          "description": "<p>reverse the relative location of notes on the value axis - 0 by default</p>"
        },
        {
          "name": "overscan",
          "type": "number",
          "description": "<p>lookup X cycles outside of the cycles window to display notes in advance - 1 by default</p>"
        },
        {
          "name": "hideNegative",
          "type": "boolean",
          "description": "<p>hide notes with negative time (before starting playing the pattern) - 0 by default</p>"
        },
        {
          "name": "smear",
          "type": "boolean",
          "description": "<p>notes leave a solid trace - 0 by default</p>"
        },
        {
          "name": "fold",
          "type": "boolean",
          "description": "<p>notes takes the full value axis width - 0 by default</p>"
        },
        {
          "name": "active",
          "type": "string",
          "description": "<p>hexadecimal or CSS color of the active notes - defaults to #FFCA28</p>"
        },
        {
          "name": "inactive",
          "type": "string",
          "description": "<p>hexadecimal or CSS color of the inactive notes - defaults to #7491D2</p>"
        },
        {
          "name": "background",
          "type": "string",
          "description": "<p>hexadecimal or CSS color of the background - defaults to transparent</p>"
        },
        {
          "name": "playheadColor",
          "type": "string",
          "description": "<p>hexadecimal or CSS color of the line representing the play head - defaults to white</p>"
        },
        {
          "name": "fill",
          "type": "boolean",
          "description": "<p>notes are filled with color (otherwise only the label is displayed) - 0 by default</p>"
        },
        {
          "name": "fillActive",
          "type": "boolean",
          "description": "<p>active notes are filled with color - 0 by default</p>"
        },
        {
          "name": "stroke",
          "type": "boolean",
          "description": "<p>notes are shown with colored borders - 0 by default</p>"
        },
        {
          "name": "strokeActive",
          "type": "boolean",
          "description": "<p>active notes are shown with colored borders - 0 by default</p>"
        },
        {
          "name": "hideInactive",
          "type": "boolean",
          "description": "<p>only active notes are shown - 0 by default</p>"
        },
        {
          "name": "colorizeInactive",
          "type": "boolean",
          "description": "<p>use note color for inactive notes - 1 by default</p>"
        },
        {
          "name": "fontFamily",
          "type": "string",
          "description": "<p>define the font used by notes labels - defaults to 'monospace'</p>"
        },
        {
          "name": "minMidi",
          "type": "integer",
          "description": "<p>minimum note value to display on the value axis - defaults to 10</p>"
        },
        {
          "name": "maxMidi",
          "type": "integer",
          "description": "<p>maximum note value to display on the value axis - defaults to 90</p>"
        },
        {
          "name": "autorange",
          "type": "boolean",
          "description": "<p>automatically calculate the minMidi and maxMidi parameters - 0 by default</p>"
        }
      ],
      "examples": [
        "note(\"c2 a2 eb2\")\r.euclid(5,8)\r.s('sawtooth')\r.lpenv(4).lpf(300)\r.pianoroll({ labels: 1 })"
      ],
      "synonyms": [
        "punchcard"
      ],
      "originalName": "pianoroll"
    },
    {
      "name": "pick",
      "description": "<p>Picks patterns (or plain values) either from a list (by index) or a lookup table (by name).\nSimilar to <code>inhabit</code>, but maintains the structure of the original patterns.</p>",
      "params": [
        {
          "name": "pat",
          "type": "Pattern",
          "description": ""
        },
        {
          "name": "xs",
          "type": "*",
          "description": ""
        }
      ],
      "examples": [
        "note(\"<0 1 2!2 3>\".pick([\"g a\", \"e f\", \"f g f g\" , \"g c d\"]))",
        "sound(\"<0 1 [2,0]>\".pick([\"bd sd\", \"cp cp\", \"hh hh\"]))",
        "sound(\"<0!2 [0,1] 1>\".pick([\"bd(3,8)\", \"sd sd\"]))",
        "s(\"<a!2 [a,b] b>\".pick({a: \"bd(3,8)\", b: \"sd sd\"}))"
      ],
      "synonyms": [],
      "originalName": "pick"
    },
    {
      "name": "pickF",
      "description": "<p>pickF lets you use a pattern of numbers to pick which function to apply to another pattern.</p>",
      "params": [
        {
          "name": "pat",
          "type": "Pattern",
          "description": ""
        },
        {
          "name": "lookup",
          "type": "Pattern",
          "description": "<p>a pattern of indices</p>"
        },
        {
          "name": "funcs",
          "type": "Array.<function()>",
          "description": "<p>the array of functions from which to pull</p>"
        }
      ],
      "examples": [
        "s(\"bd [rim hh]\").pickF(\"<0 1 2>\", [rev,jux(rev),fast(2)])",
        "note(\"<c2 d2>(3,8)\").s(\"square\")\r    .pickF(\"<0 2> 1\", [jux(rev),fast(2),x=>x.lpf(800)])"
      ],
      "synonyms": [],
      "originalName": "pickF"
    },
    {
      "name": "pickmod",
      "description": "<p>The same as <code>pick</code>, but if you pick a number greater than the size of the list,\nit wraps around, rather than sticking at the maximum value.\nFor example, if you pick the fifth pattern of a list of three, you'll get the\nsecond one.</p>",
      "params": [
        {
          "name": "pat",
          "type": "Pattern",
          "description": ""
        },
        {
          "name": "xs",
          "type": "*",
          "description": ""
        }
      ],
      "examples": [],
      "synonyms": [],
      "originalName": "pickmod"
    },
    {
      "name": "pickmodF",
      "description": "<p>The same as <code>pickF</code>, but if you pick a number greater than the size of the functions list,\nit wraps around, rather than sticking at the maximum value.</p>",
      "params": [
        {
          "name": "pat",
          "type": "Pattern",
          "description": ""
        },
        {
          "name": "lookup",
          "type": "Pattern",
          "description": "<p>a pattern of indices</p>"
        },
        {
          "name": "funcs",
          "type": "Array.<function()>",
          "description": "<p>the array of functions from which to pull</p>"
        }
      ],
      "examples": [],
      "synonyms": [],
      "originalName": "pickmodF"
    },
    {
      "name": "pickmodOut",
      "description": "<p>The same as <code>pickOut</code>, but if you pick a number greater than the size of the list,\nit wraps around, rather than sticking at the maximum value.</p>",
      "params": [
        {
          "name": "pat",
          "type": "Pattern",
          "description": ""
        },
        {
          "name": "xs",
          "type": "*",
          "description": ""
        }
      ],
      "examples": [],
      "synonyms": [],
      "originalName": "pickmodOut"
    },
    {
      "name": "pickmodReset",
      "description": "<p>The same as <code>pickReset</code>, but if you pick a number greater than the size of the list,\nit wraps around, rather than sticking at the maximum value.</p>",
      "params": [
        {
          "name": "pat",
          "type": "Pattern",
          "description": ""
        },
        {
          "name": "xs",
          "type": "*",
          "description": ""
        }
      ],
      "examples": [],
      "synonyms": [],
      "originalName": "pickmodReset"
    },
    {
      "name": "pickmodRestart",
      "description": "<p>The same as <code>pickRestart</code>, but if you pick a number greater than the size of the list,\nit wraps around, rather than sticking at the maximum value.</p>",
      "params": [
        {
          "name": "pat",
          "type": "Pattern",
          "description": ""
        },
        {
          "name": "xs",
          "type": "*",
          "description": ""
        }
      ],
      "examples": [
        "\"<a@2 b@2 c@2 d@2>\".pickRestart({\r\n        a: n(\"0 1 2 0\"),\r\n        b: n(\"2 3 4 ~\"),\r\n        c: n(\"[4 5] [4 3] 2 0\"),\r\n        d: n(\"0 -3 0 ~\")\r\n      }).scale(\"C:major\").s(\"piano\")"
      ],
      "synonyms": [],
      "originalName": "pickmodRestart"
    },
    {
      "name": "pickmodSqueeze",
      "description": "<p>The same as <code>inhabit</code>, but if you pick a number greater than the size of the list,\nit wraps around, rather than sticking at the maximum value.\nFor example, if you pick the fifth pattern of a list of three, you'll get the\nsecond one.</p>",
      "params": [
        {
          "name": "pat",
          "type": "Pattern",
          "description": ""
        },
        {
          "name": "xs",
          "type": "*",
          "description": ""
        }
      ],
      "examples": [],
      "synonyms": [
        "pickmodSqueeze"
      ],
      "originalName": "inhabitmod"
    },
    {
      "name": "pickOut",
      "description": "<p>Similar to <code>pick</code>, but it applies an outerJoin instead of an innerJoin.</p>",
      "params": [
        {
          "name": "pat",
          "type": "Pattern",
          "description": ""
        },
        {
          "name": "xs",
          "type": "*",
          "description": ""
        }
      ],
      "examples": [],
      "synonyms": [],
      "originalName": "pickOut"
    },
    {
      "name": "pickReset",
      "description": "<p>Similar to <code>pick</code>, but the choosen pattern is reset when its index is triggered.</p>",
      "params": [
        {
          "name": "pat",
          "type": "Pattern",
          "description": ""
        },
        {
          "name": "xs",
          "type": "*",
          "description": ""
        }
      ],
      "examples": [],
      "synonyms": [],
      "originalName": "pickReset"
    },
    {
      "name": "pickRestart",
      "description": "<p>Similar to <code>pick</code>, but the choosen pattern is restarted when its index is triggered.</p>",
      "params": [
        {
          "name": "pat",
          "type": "Pattern",
          "description": ""
        },
        {
          "name": "xs",
          "type": "*",
          "description": ""
        }
      ],
      "examples": [],
      "synonyms": [],
      "originalName": "pickRestart"
    },
    {
      "name": "pickSqueeze",
      "description": "<p>Picks patterns (or plain values) either from a list (by index) or a lookup table (by name).\nSimilar to <code>pick</code>, but cycles are squeezed into the target ('inhabited') pattern.</p>",
      "params": [
        {
          "name": "pat",
          "type": "Pattern",
          "description": ""
        },
        {
          "name": "xs",
          "type": "*",
          "description": ""
        }
      ],
      "examples": [
        "\"<a b [a,b]>\".inhabit({a: s(\"bd(3,8)\"),\r\n                            b: s(\"cp sd\")\r\n                           })",
        "s(\"a@2 [a b] a\".inhabit({a: \"bd(3,8)\", b: \"sd sd\"})).slow(4)"
      ],
      "synonyms": [
        "pickSqueeze"
      ],
      "originalName": "inhabit"
    },
    {
      "name": "pitchwheel",
      "description": "<p>Renders a pitch circle to visualize frequencies within one octave</p>",
      "params": [
        {
          "name": "hapcircles",
          "type": "number",
          "description": ""
        },
        {
          "name": "circle",
          "type": "number",
          "description": ""
        },
        {
          "name": "edo",
          "type": "number",
          "description": ""
        },
        {
          "name": "root",
          "type": "string",
          "description": ""
        },
        {
          "name": "thickness",
          "type": "number",
          "description": ""
        },
        {
          "name": "hapRadius",
          "type": "number",
          "description": ""
        },
        {
          "name": "mode",
          "type": "string",
          "description": ""
        },
        {
          "name": "margin",
          "type": "number",
          "description": ""
        }
      ],
      "examples": [
        "n(\"0 .. 12\").scale(\"C:chromatic\")\r.s(\"sawtooth\")\r.lpf(500)\r._pitchwheel()"
      ],
      "synonyms": [],
      "originalName": "pitchwheel"
    },
    {
      "name": "ply",
      "description": "<p>The ply function repeats each event the given number of times.</p>",
      "params": [],
      "examples": [
        "s(\"bd ~ sd cp\").ply(\"<1 2 3>\")"
      ],
      "synonyms": [],
      "originalName": "ply"
    },
    {
      "name": "plyforeach",
      "description": "<p>The plyForEach function repeats each event the given number of times, applying the given function to each event.\nThis version of ply uses the iteration index as an argument to the function, similar to echoWith.</p>",
      "params": [
        {
          "name": "factor",
          "type": "number",
          "description": "<p>how many times to repeat</p>"
        },
        {
          "name": "func",
          "type": "function",
          "description": "<p>function to apply, given the pattern and the iteration index</p>"
        }
      ],
      "examples": [
        "\"<0 [2 4]>\"\r.plyForEach(4, (p,n) => p.add(n*2))\r.scale(\"C:minor\").note()"
      ],
      "synonyms": [
        "plyforeach"
      ],
      "originalName": "plyForEach"
    },
    {
      "name": "plyForEach",
      "description": "<p>The plyForEach function repeats each event the given number of times, applying the given function to each event.\nThis version of ply uses the iteration index as an argument to the function, similar to echoWith.</p>",
      "params": [
        {
          "name": "factor",
          "type": "number",
          "description": "<p>how many times to repeat</p>"
        },
        {
          "name": "func",
          "type": "function",
          "description": "<p>function to apply, given the pattern and the iteration index</p>"
        }
      ],
      "examples": [
        "\"<0 [2 4]>\"\r.plyForEach(4, (p,n) => p.add(n*2))\r.scale(\"C:minor\").note()"
      ],
      "synonyms": [
        "plyforeach"
      ],
      "originalName": "plyForEach"
    },
    {
      "name": "plywith",
      "description": "<p>The plyWith function repeats each event the given number of times, applying the given function to each event.\\n</p>",
      "params": [
        {
          "name": "factor",
          "type": "number",
          "description": "<p>how many times to repeat</p>"
        },
        {
          "name": "func",
          "type": "function",
          "description": "<p>function to apply, given the pattern</p>"
        }
      ],
      "examples": [
        "\"<0 [2 4]>\"\r.plyWith(4, (p) => p.add(2))\r.scale(\"C:minor\").note()"
      ],
      "synonyms": [
        "plywith"
      ],
      "originalName": "plyWith"
    },
    {
      "name": "plyWith",
      "description": "<p>The plyWith function repeats each event the given number of times, applying the given function to each event.\\n</p>",
      "params": [
        {
          "name": "factor",
          "type": "number",
          "description": "<p>how many times to repeat</p>"
        },
        {
          "name": "func",
          "type": "function",
          "description": "<p>function to apply, given the pattern</p>"
        }
      ],
      "examples": [
        "\"<0 [2 4]>\"\r.plyWith(4, (p) => p.add(2))\r.scale(\"C:minor\").note()"
      ],
      "synonyms": [
        "plywith"
      ],
      "originalName": "plyWith"
    },
    {
      "name": "pm",
      "description": "<p><em>Experimental</em></p>\n<p>Aligns the steps of the patterns, creating polymeters. The patterns are repeated until they all fit the cycle. For example, in the below the first pattern is repeated twice, and the second is repeated three times, to fit the lowest common multiple of six steps.</p>",
      "params": [],
      "examples": [
        "// The same as note(\"{c eb g, c2 g2}%6\")\rpolymeter(\"c eb g\", \"c2 g2\").note()"
      ],
      "synonyms": [
        "pm"
      ],
      "originalName": "polymeter"
    },
    {
      "name": "polymeter",
      "description": "<p><em>Experimental</em></p>\n<p>Aligns the steps of the patterns, creating polymeters. The patterns are repeated until they all fit the cycle. For example, in the below the first pattern is repeated twice, and the second is repeated three times, to fit the lowest common multiple of six steps.</p>",
      "params": [],
      "examples": [
        "// The same as note(\"{c eb g, c2 g2}%6\")\rpolymeter(\"c eb g\", \"c2 g2\").note()"
      ],
      "synonyms": [
        "pm"
      ],
      "originalName": "polymeter"
    },
    {
      "name": "polyrhythm",
      "description": "<p>The given items are played at the same time at the same length.</p>",
      "params": [],
      "examples": [
        "stack(\"g3\", \"b3\", [\"e4\", \"d4\"]).note()\r// \"g3,b3,[e4 d4]\".note()",
        "// As a chained function:\rs(\"hh*4\").stack(\r  note(\"c4(5,8)\")\r)"
      ],
      "synonyms": [
        "polyrhythm",
        "pr"
      ],
      "originalName": "stack"
    },
    {
      "name": "postgain",
      "description": "<p>Gain applied after all effects have been processed.</p>",
      "params": [],
      "examples": [
        "s(\"bd sd [~ bd] sd,hh*8\")\r.compressor(\"-20:20:10:.002:.02\").postgain(1.5)"
      ],
      "synonyms": [],
      "originalName": "postgain"
    },
    {
      "name": "pr",
      "description": "<p>The given items are played at the same time at the same length.</p>",
      "params": [],
      "examples": [
        "stack(\"g3\", \"b3\", [\"e4\", \"d4\"]).note()\r// \"g3,b3,[e4 d4]\".note()",
        "// As a chained function:\rs(\"hh*4\").stack(\r  note(\"c4(5,8)\")\r)"
      ],
      "synonyms": [
        "polyrhythm",
        "pr"
      ],
      "originalName": "stack"
    },
    {
      "name": "prel",
      "description": "<p>Release time of pitch envelope</p>",
      "params": [
        {
          "name": "time",
          "type": "number | Pattern",
          "description": "<p>time in seconds</p>"
        }
      ],
      "examples": [
        "note(\"<c eb g bb> ~\")\r.release(.5) // to hear the pitch release\r.prelease(\"<0 .1 .25 .5>\")"
      ],
      "synonyms": [
        "prel"
      ],
      "originalName": "prelease"
    },
    {
      "name": "prelease",
      "description": "<p>Release time of pitch envelope</p>",
      "params": [
        {
          "name": "time",
          "type": "number | Pattern",
          "description": "<p>time in seconds</p>"
        }
      ],
      "examples": [
        "note(\"<c eb g bb> ~\")\r.release(.5) // to hear the pitch release\r.prelease(\"<0 .1 .25 .5>\")"
      ],
      "synonyms": [
        "prel"
      ],
      "originalName": "prelease"
    },
    {
      "name": "prepareInputBuffersToSend",
      "description": "<p>Copy contents of input buffers to buffer actually sent to process</p>",
      "params": [],
      "examples": [],
      "synonyms": [],
      "originalName": "prepareInputBuffersToSend"
    },
    {
      "name": "press",
      "description": "<p>Syncopates a rhythm, by shifting each event halfway into its timespan.</p>",
      "params": [],
      "examples": [
        "stack(s(\"hh*4\"),\r      s(\"bd mt sd ht\").every(4, press)\r     ).slow(2)"
      ],
      "synonyms": [],
      "originalName": "press"
    },
    {
      "name": "pressBy",
      "description": "<p>Like press, but allows you to specify the amount by which each\nevent is shifted. pressBy(0.5) is the same as press, while\npressBy(1/3) shifts each event by a third of its timespan.</p>",
      "params": [],
      "examples": [
        "stack(s(\"hh*4\"),\r      s(\"bd mt sd ht\").pressBy(\"<0 0.5 0.25>\")\r     ).slow(2)"
      ],
      "synonyms": [],
      "originalName": "pressBy"
    },
    {
      "name": "progNum",
      "description": "<p>MIDI program number: Sends a MIDI program change message.</p>",
      "params": [
        {
          "name": "program",
          "type": "number | Pattern",
          "description": "<p>MIDI program number (0-127)</p>"
        }
      ],
      "examples": [
        "note(\"c4\").progNum(10).midichan(1).midi()"
      ],
      "synonyms": [],
      "originalName": "progNum"
    },
    {
      "name": "psustain",
      "description": "",
      "params": [],
      "examples": [],
      "synonyms": [],
      "originalName": "psustain"
    },
    {
      "name": "punchcard",
      "description": "<p>Visualises a pattern as a scrolling 'pianoroll', displayed in the background of the editor. To show a pianoroll for all running patterns, use <code>all(pianoroll)</code>. To have a pianoroll appear below\na pattern instead, prefix with <code>_</code>, e.g.: <code>sound(&quot;bd sd&quot;)._pianoroll()</code>.</p>",
      "params": [
        {
          "name": "options",
          "type": "Object",
          "description": "<p>Object containing all the optional following parameters as key value pairs:</p>"
        },
        {
          "name": "cycles",
          "type": "integer",
          "description": "<p>number of cycles to be displayed at the same time - defaults to 4</p>"
        },
        {
          "name": "playhead",
          "type": "number",
          "description": "<p>location of the active notes on the time axis - 0 to 1, defaults to 0.5</p>"
        },
        {
          "name": "vertical",
          "type": "boolean",
          "description": "<p>displays the roll vertically - 0 by default</p>"
        },
        {
          "name": "labels",
          "type": "boolean",
          "description": "<p>displays labels on individual notes (see the label function) - 0 by default</p>"
        },
        {
          "name": "flipTime",
          "type": "boolean",
          "description": "<p>reverse the direction of the roll - 0 by default</p>"
        },
        {
          "name": "flipValues",
          "type": "boolean",
          "description": "<p>reverse the relative location of notes on the value axis - 0 by default</p>"
        },
        {
          "name": "overscan",
          "type": "number",
          "description": "<p>lookup X cycles outside of the cycles window to display notes in advance - 1 by default</p>"
        },
        {
          "name": "hideNegative",
          "type": "boolean",
          "description": "<p>hide notes with negative time (before starting playing the pattern) - 0 by default</p>"
        },
        {
          "name": "smear",
          "type": "boolean",
          "description": "<p>notes leave a solid trace - 0 by default</p>"
        },
        {
          "name": "fold",
          "type": "boolean",
          "description": "<p>notes takes the full value axis width - 0 by default</p>"
        },
        {
          "name": "active",
          "type": "string",
          "description": "<p>hexadecimal or CSS color of the active notes - defaults to #FFCA28</p>"
        },
        {
          "name": "inactive",
          "type": "string",
          "description": "<p>hexadecimal or CSS color of the inactive notes - defaults to #7491D2</p>"
        },
        {
          "name": "background",
          "type": "string",
          "description": "<p>hexadecimal or CSS color of the background - defaults to transparent</p>"
        },
        {
          "name": "playheadColor",
          "type": "string",
          "description": "<p>hexadecimal or CSS color of the line representing the play head - defaults to white</p>"
        },
        {
          "name": "fill",
          "type": "boolean",
          "description": "<p>notes are filled with color (otherwise only the label is displayed) - 0 by default</p>"
        },
        {
          "name": "fillActive",
          "type": "boolean",
          "description": "<p>active notes are filled with color - 0 by default</p>"
        },
        {
          "name": "stroke",
          "type": "boolean",
          "description": "<p>notes are shown with colored borders - 0 by default</p>"
        },
        {
          "name": "strokeActive",
          "type": "boolean",
          "description": "<p>active notes are shown with colored borders - 0 by default</p>"
        },
        {
          "name": "hideInactive",
          "type": "boolean",
          "description": "<p>only active notes are shown - 0 by default</p>"
        },
        {
          "name": "colorizeInactive",
          "type": "boolean",
          "description": "<p>use note color for inactive notes - 1 by default</p>"
        },
        {
          "name": "fontFamily",
          "type": "string",
          "description": "<p>define the font used by notes labels - defaults to 'monospace'</p>"
        },
        {
          "name": "minMidi",
          "type": "integer",
          "description": "<p>minimum note value to display on the value axis - defaults to 10</p>"
        },
        {
          "name": "maxMidi",
          "type": "integer",
          "description": "<p>maximum note value to display on the value axis - defaults to 90</p>"
        },
        {
          "name": "autorange",
          "type": "boolean",
          "description": "<p>automatically calculate the minMidi and maxMidi parameters - 0 by default</p>"
        }
      ],
      "examples": [
        "note(\"c2 a2 eb2\")\r.euclid(5,8)\r.s('sawtooth')\r.lpenv(4).lpf(300)\r.pianoroll({ labels: 1 })"
      ],
      "synonyms": [
        "punchcard"
      ],
      "originalName": "pianoroll"
    },
    {
      "name": "pure",
      "description": "<p>A discrete value that repeats once per cycle.</p>",
      "params": [],
      "examples": [
        "pure('e4') // \"e4\""
      ],
      "synonyms": [],
      "originalName": "pure"
    },
    {
      "name": "pw",
      "description": "<p>Controls the pulsewidth of the pulse oscillator</p>",
      "params": [
        {
          "name": "pulsewidth",
          "type": "number | Pattern",
          "description": ""
        }
      ],
      "examples": [
        "note(\"{f a c e}%16\").s(\"pulse\").pw(\".8:1:.2\")",
        "n(run(8)).scale(\"D:pentatonic\").s(\"pulse\").pw(\"0 .75 .5 1\")"
      ],
      "synonyms": [],
      "originalName": "pw"
    },
    {
      "name": "pwrate",
      "description": "<p>Controls the lfo rate for the pulsewidth of the pulse oscillator</p>",
      "params": [
        {
          "name": "rate",
          "type": "number | Pattern",
          "description": ""
        }
      ],
      "examples": [
        "n(run(8)).scale(\"D:pentatonic\").s(\"pulse\").pw(\"0.5\").pwrate(\"<5 .1 25>\").pwsweep(\"<0.3 .8>\")"
      ],
      "synonyms": [],
      "originalName": "pwrate"
    },
    {
      "name": "pwsweep",
      "description": "<p>Controls the lfo sweep for the pulsewidth of the pulse oscillator</p>",
      "params": [
        {
          "name": "sweep",
          "type": "number | Pattern",
          "description": ""
        }
      ],
      "examples": [
        "n(run(8)).scale(\"D:pentatonic\").s(\"pulse\").pw(\"0.5\").pwrate(\"<5 .1 25>\").pwsweep(\"<0.3 .8>\")"
      ],
      "synonyms": [],
      "originalName": "pwsweep"
    },
    {
      "name": "queryArc",
      "description": "<p>Query haps inside the given time span.</p>",
      "params": [
        {
          "name": "begin",
          "type": "Fraction | number",
          "description": "<p>from time</p>"
        },
        {
          "name": "end",
          "type": "Fraction | number",
          "description": "<p>to time</p>"
        }
      ],
      "examples": [
        "const pattern = sequence('a', ['b', 'c'])\rconst haps = pattern.queryArc(0, 1)\rconsole.log(haps)\rsilence"
      ],
      "synonyms": [],
      "originalName": "queryArc"
    },
    {
      "name": "rand",
      "description": "<p>A continuous pattern of random numbers, between 0 and 1.</p>",
      "params": [],
      "examples": [
        "// randomly change the cutoff\rs(\"bd*4,hh*8\").cutoff(rand.range(500,8000))"
      ],
      "synonyms": [],
      "originalName": "rand"
    },
    {
      "name": "rand2",
      "description": "<p>A continuous pattern of random numbers, between -1 and 1</p>",
      "params": [],
      "examples": [],
      "synonyms": [],
      "originalName": "rand2"
    },
    {
      "name": "randcat",
      "description": "<p>Picks one of the elements at random each cycle.</p>",
      "params": [],
      "examples": [
        "chooseCycles(\"bd\", \"hh\", \"sd\").s().fast(8)",
        "s(\"bd | hh | sd\").fast(8)"
      ],
      "synonyms": [
        "randcat"
      ],
      "originalName": "chooseCycles"
    },
    {
      "name": "randomSample",
      "description": "",
      "params": [],
      "examples": [],
      "synonyms": [],
      "originalName": "randomSample"
    },
    {
      "name": "range",
      "description": "<p>Assumes a numerical pattern, containing unipolar values in the range 0 .. 1.\nReturns a new pattern with values scaled to the given min/max range.\nMost useful in combination with continuous patterns.</p>",
      "params": [],
      "examples": [
        "s(\"[bd sd]*2,hh*8\")\r.cutoff(sine.range(500,4000))"
      ],
      "synonyms": [],
      "originalName": "range"
    },
    {
      "name": "range2",
      "description": "<p>Assumes a numerical pattern, containing bipolar values in the range -1 .. 1\nReturns a new pattern with values scaled to the given min/max range.</p>",
      "params": [],
      "examples": [
        "s(\"[bd sd]*2,hh*8\")\r.cutoff(sine2.range2(500,4000))"
      ],
      "synonyms": [],
      "originalName": "range2"
    },
    {
      "name": "rangex",
      "description": "<p>Assumes a numerical pattern, containing unipolar values in the range 0 .. 1\nReturns a new pattern with values scaled to the given min/max range,\nfollowing an exponential curve.</p>",
      "params": [],
      "examples": [
        "s(\"[bd sd]*2,hh*8\")\r.cutoff(sine.rangex(500,4000))"
      ],
      "synonyms": [],
      "originalName": "rangex"
    },
    {
      "name": "rarely",
      "description": "<p>Shorthand for <code>.sometimesBy(0.25, fn)</code></p>",
      "params": [],
      "examples": [
        "s(\"hh*8\").rarely(x=>x.speed(\"0.5\"))"
      ],
      "synonyms": [],
      "originalName": "rarely"
    },
    {
      "name": "ratio",
      "description": "<p>Allows dividing numbers via list notation using &quot;:&quot;.\nReturns a new pattern with just numbers.</p>",
      "params": [],
      "examples": [
        "ratio(\"1, 5:4, 3:2\").mul(110)\r.freq().s(\"piano\")"
      ],
      "synonyms": [],
      "originalName": "ratio"
    },
    {
      "name": "rdim",
      "description": "<p>Reverb lowpass frequency at -60dB (in hertz).\nWhen this property is changed, the reverb will be recaculated, so only change this sparsely..</p>",
      "params": [
        {
          "name": "frequency",
          "type": "number",
          "description": "<p>between 0 and 20000hz</p>"
        }
      ],
      "examples": [
        "s(\"bd sd [~ bd] sd\").room(0.5).rlp(10000).rdim(8000)",
        "s(\"bd sd [~ bd] sd\").room(0.5).rlp(5000).rdim(400)"
      ],
      "synonyms": [
        "rdim"
      ],
      "originalName": "roomdim"
    },
    {
      "name": "readInputs",
      "description": "<p>Read next web audio block to input buffers</p>",
      "params": [],
      "examples": [],
      "synonyms": [],
      "originalName": "readInputs"
    },
    {
      "name": "reallocateChannelsIfNeeded",
      "description": "<p>Handles dynamic reallocation of input/output channels buffer\n(channel numbers may lety during lifecycle)</p>",
      "params": [],
      "examples": [],
      "synonyms": [],
      "originalName": "reallocateChannelsIfNeeded"
    },
    {
      "name": "ref",
      "description": "<p>exposes a custom value at query time. basically allows mutating state without evaluation</p>",
      "params": [],
      "examples": [],
      "synonyms": [],
      "originalName": "ref"
    },
    {
      "name": "register",
      "description": "<p>Registers a new pattern method. The method is added to the Pattern class + the standalone function is returned from register.</p>",
      "params": [
        {
          "name": "name",
          "type": "string | Array.<string>",
          "description": "<p>name of the function, or an array of names to be used as synonyms</p>"
        },
        {
          "name": "func",
          "type": "function",
          "description": "<p>function with 1 or more params, where last is the current pattern</p>"
        }
      ],
      "examples": [],
      "synonyms": [],
      "originalName": "register"
    },
    {
      "name": "rel",
      "description": "<p>Amplitude envelope release time: The time it takes after the offset to go from sustain level to zero.</p>",
      "params": [
        {
          "name": "time",
          "type": "number | Pattern",
          "description": "<p>release time in seconds</p>"
        }
      ],
      "examples": [
        "note(\"c3 e3 g3 c4\").release(\"<0 .1 .4 .6 1>/2\")"
      ],
      "synonyms": [
        "rel"
      ],
      "originalName": "release"
    },
    {
      "name": "release",
      "description": "<p>Amplitude envelope release time: The time it takes after the offset to go from sustain level to zero.</p>",
      "params": [
        {
          "name": "time",
          "type": "number | Pattern",
          "description": "<p>release time in seconds</p>"
        }
      ],
      "examples": [
        "note(\"c3 e3 g3 c4\").release(\"<0 .1 .4 .6 1>/2\")"
      ],
      "synonyms": [
        "rel"
      ],
      "originalName": "release"
    },
    {
      "name": "removeUndefineds",
      "description": "<p>Returns a new pattern, with haps containing undefined values removed from\nquery results.</p>",
      "params": [],
      "examples": [],
      "synonyms": [],
      "originalName": "removeUndefineds"
    },
    {
      "name": "repeatCycles",
      "description": "<p>Repeats each cycle the given number of times.</p>",
      "params": [],
      "examples": [
        "note(irand(12).add(34)).segment(4).repeatCycles(2).s(\"gm_acoustic_guitar_nylon\")"
      ],
      "synonyms": [],
      "originalName": "repeatCycles"
    },
    {
      "name": "replicate",
      "description": "<p><em>Experimental</em></p>\n<p><code>replicate</code> is similar to <code>fast</code> in that it increases its density, but it also increases the step count\naccordingly. So <code>stepcat(&quot;a b&quot;.replicate(2), &quot;c d&quot;)</code> would be the same as <code>&quot;a b a b c d&quot;</code>, whereas\n<code>stepcat(&quot;a b&quot;.fast(2), &quot;c d&quot;)</code> would be the same as <code>&quot;[a b] [a b] c d&quot;</code>.</p>\n<p>TODO: find out how this function differs from extend</p>",
      "params": [],
      "examples": [
        "stepcat(\r  sound(\"bd bd - cp\").replicate(2),\r  sound(\"bd - sd -\")\r).pace(8)"
      ],
      "synonyms": [],
      "originalName": "replicate"
    },
    {
      "name": "reset",
      "description": "<p>Resets the pattern to the start of the cycle for each onset of the reset pattern.</p>",
      "params": [],
      "examples": [
        "s(\"[<bd lt> sd]*2, hh*8\").reset(\"<x@3 x(5,8)>\")"
      ],
      "synonyms": [],
      "originalName": "reset"
    },
    {
      "name": "resonance",
      "description": "<p>Controls the <strong>l</strong>ow-<strong>p</strong>ass <strong>q</strong>-value.</p>",
      "params": [
        {
          "name": "q",
          "type": "number | Pattern",
          "description": "<p>resonance factor between 0 and 50</p>"
        }
      ],
      "examples": [
        "s(\"bd sd [~ bd] sd,hh*8\").lpf(2000).lpq(\"<0 10 20 30>\")"
      ],
      "synonyms": [
        "resonance"
      ],
      "originalName": "lpq"
    },
    {
      "name": "restart",
      "description": "<p>Restarts the pattern for each onset of the restart pattern.\nWhile reset will only reset the current cycle, restart will start from cycle 0.</p>",
      "params": [],
      "examples": [
        "s(\"[<bd lt> sd]*2, hh*8\").restart(\"<x@3 x(5,8)>\")"
      ],
      "synonyms": [],
      "originalName": "restart"
    },
    {
      "name": "rev",
      "description": "<p>Reverse all haps in a pattern</p>",
      "params": [],
      "examples": [
        "note(\"c d e g\").rev()"
      ],
      "synonyms": [],
      "originalName": "rev"
    },
    {
      "name": "rfade",
      "description": "<p>Reverb fade time (in seconds).\nWhen this property is changed, the reverb will be recaculated, so only change this sparsely..</p>",
      "params": [
        {
          "name": "seconds",
          "type": "number",
          "description": "<p>for the reverb to fade</p>"
        }
      ],
      "examples": [
        "s(\"bd sd [~ bd] sd\").room(0.5).rlp(10000).rfade(0.5)",
        "s(\"bd sd [~ bd] sd\").room(0.5).rlp(5000).rfade(4)"
      ],
      "synonyms": [
        "rfade"
      ],
      "originalName": "roomfade"
    },
    {
      "name": "rib",
      "description": "<p>Loops the pattern inside an <code>offset</code> for <code>cycles</code>.\nIf you think of the entire span of time in cycles as a ribbon, you can cut a single piece and loop it.</p>",
      "params": [
        {
          "name": "offset",
          "type": "number",
          "description": "<p>start point of loop in cycles</p>"
        },
        {
          "name": "cycles",
          "type": "number",
          "description": "<p>loop length in cycles</p>"
        }
      ],
      "examples": [
        "note(\"<c d e f>\").ribbon(1, 2)",
        "// Looping a portion of randomness\rn(irand(8).segment(4)).scale(\"c:pentatonic\").ribbon(1337, 2)",
        "// rhythm generator\rs(\"bd!16?\").ribbon(29,.5)"
      ],
      "synonyms": [
        "rib"
      ],
      "originalName": "ribbon"
    },
    {
      "name": "ribbon",
      "description": "<p>Loops the pattern inside an <code>offset</code> for <code>cycles</code>.\nIf you think of the entire span of time in cycles as a ribbon, you can cut a single piece and loop it.</p>",
      "params": [
        {
          "name": "offset",
          "type": "number",
          "description": "<p>start point of loop in cycles</p>"
        },
        {
          "name": "cycles",
          "type": "number",
          "description": "<p>loop length in cycles</p>"
        }
      ],
      "examples": [
        "note(\"<c d e f>\").ribbon(1, 2)",
        "// Looping a portion of randomness\rn(irand(8).segment(4)).scale(\"c:pentatonic\").ribbon(1337, 2)",
        "// rhythm generator\rs(\"bd!16?\").ribbon(29,.5)"
      ],
      "synonyms": [
        "rib"
      ],
      "originalName": "ribbon"
    },
    {
      "name": "rlp",
      "description": "<p>Reverb lowpass starting frequency (in hertz).\nWhen this property is changed, the reverb will be recaculated, so only change this sparsely..</p>",
      "params": [
        {
          "name": "frequency",
          "type": "number",
          "description": "<p>between 0 and 20000hz</p>"
        }
      ],
      "examples": [
        "s(\"bd sd [~ bd] sd\").room(0.5).rlp(10000)",
        "s(\"bd sd [~ bd] sd\").room(0.5).rlp(5000)"
      ],
      "synonyms": [
        "rlp"
      ],
      "originalName": "roomlp"
    },
    {
      "name": "room",
      "description": "<p>Sets the level of reverb.</p>\n<p>When using mininotation, you can also optionally add the 'size' parameter, separated by ':'.</p>",
      "params": [
        {
          "name": "level",
          "type": "number | Pattern",
          "description": "<p>between 0 and 1</p>"
        }
      ],
      "examples": [
        "s(\"bd sd [~ bd] sd\").room(\"<0 .2 .4 .6 .8 1>\")",
        "s(\"bd sd [~ bd] sd\").room(\"<0.9:1 0.9:4>\")"
      ],
      "synonyms": [],
      "originalName": "room"
    },
    {
      "name": "roomdim",
      "description": "<p>Reverb lowpass frequency at -60dB (in hertz).\nWhen this property is changed, the reverb will be recaculated, so only change this sparsely..</p>",
      "params": [
        {
          "name": "frequency",
          "type": "number",
          "description": "<p>between 0 and 20000hz</p>"
        }
      ],
      "examples": [
        "s(\"bd sd [~ bd] sd\").room(0.5).rlp(10000).rdim(8000)",
        "s(\"bd sd [~ bd] sd\").room(0.5).rlp(5000).rdim(400)"
      ],
      "synonyms": [
        "rdim"
      ],
      "originalName": "roomdim"
    },
    {
      "name": "roomfade",
      "description": "<p>Reverb fade time (in seconds).\nWhen this property is changed, the reverb will be recaculated, so only change this sparsely..</p>",
      "params": [
        {
          "name": "seconds",
          "type": "number",
          "description": "<p>for the reverb to fade</p>"
        }
      ],
      "examples": [
        "s(\"bd sd [~ bd] sd\").room(0.5).rlp(10000).rfade(0.5)",
        "s(\"bd sd [~ bd] sd\").room(0.5).rlp(5000).rfade(4)"
      ],
      "synonyms": [
        "rfade"
      ],
      "originalName": "roomfade"
    },
    {
      "name": "roomlp",
      "description": "<p>Reverb lowpass starting frequency (in hertz).\nWhen this property is changed, the reverb will be recaculated, so only change this sparsely..</p>",
      "params": [
        {
          "name": "frequency",
          "type": "number",
          "description": "<p>between 0 and 20000hz</p>"
        }
      ],
      "examples": [
        "s(\"bd sd [~ bd] sd\").room(0.5).rlp(10000)",
        "s(\"bd sd [~ bd] sd\").room(0.5).rlp(5000)"
      ],
      "synonyms": [
        "rlp"
      ],
      "originalName": "roomlp"
    },
    {
      "name": "roomsize",
      "description": "<p>Sets the room size of the reverb, see <code>room</code>.\nWhen this property is changed, the reverb will be recaculated, so only change this sparsely..</p>",
      "params": [
        {
          "name": "size",
          "type": "number | Pattern",
          "description": "<p>between 0 and 10</p>"
        }
      ],
      "examples": [
        "s(\"bd sd [~ bd] sd\").room(.8).rsize(1)",
        "s(\"bd sd [~ bd] sd\").room(.8).rsize(4)"
      ],
      "synonyms": [
        "rsize",
        "sz",
        "size"
      ],
      "originalName": "roomsize"
    },
    {
      "name": "rootNotes",
      "description": "<p>Maps the chords of the incoming pattern to root notes in the given octave.</p>",
      "params": [
        {
          "name": "octave",
          "type": "octave",
          "description": "<p>octave to use</p>"
        }
      ],
      "examples": [
        "\"<C^7 A7 Dm7 G7>\".rootNotes(2).note()"
      ],
      "synonyms": [],
      "originalName": "rootNotes"
    },
    {
      "name": "rotA",
      "description": "<p>The device's rotation around the alpha-axis value ranges from 0 to 1.</p>",
      "params": [],
      "examples": [
        "n(rotationAlpha.segment(4).range(0,7)).scale(\"C:minor\")"
      ],
      "synonyms": [
        "rotA",
        "rotZ",
        "rotationZ"
      ],
      "originalName": "rotationAlpha"
    },
    {
      "name": "rotationAlpha",
      "description": "<p>The device's rotation around the alpha-axis value ranges from 0 to 1.</p>",
      "params": [],
      "examples": [
        "n(rotationAlpha.segment(4).range(0,7)).scale(\"C:minor\")"
      ],
      "synonyms": [
        "rotA",
        "rotZ",
        "rotationZ"
      ],
      "originalName": "rotationAlpha"
    },
    {
      "name": "rotationBeta",
      "description": "<p>The device's rotation around the beta-axis value ranges from 0 to 1.</p>",
      "params": [],
      "examples": [
        "n(rotationBeta.segment(4).range(0,7)).scale(\"C:minor\")"
      ],
      "synonyms": [
        "rotB",
        "rotX",
        "rotationX"
      ],
      "originalName": "rotationBeta"
    },
    {
      "name": "rotationGamma",
      "description": "<p>The device's rotation around the gamma-axis value ranges from 0 to 1.</p>",
      "params": [],
      "examples": [
        "n(rotationGamma.segment(4).range(0,7)).scale(\"C:minor\")"
      ],
      "synonyms": [
        "rotG",
        "rotY",
        "rotationY"
      ],
      "originalName": "rotationGamma"
    },
    {
      "name": "rotationX",
      "description": "<p>The device's rotation around the beta-axis value ranges from 0 to 1.</p>",
      "params": [],
      "examples": [
        "n(rotationBeta.segment(4).range(0,7)).scale(\"C:minor\")"
      ],
      "synonyms": [
        "rotB",
        "rotX",
        "rotationX"
      ],
      "originalName": "rotationBeta"
    },
    {
      "name": "rotationY",
      "description": "<p>The device's rotation around the gamma-axis value ranges from 0 to 1.</p>",
      "params": [],
      "examples": [
        "n(rotationGamma.segment(4).range(0,7)).scale(\"C:minor\")"
      ],
      "synonyms": [
        "rotG",
        "rotY",
        "rotationY"
      ],
      "originalName": "rotationGamma"
    },
    {
      "name": "rotationZ",
      "description": "<p>The device's rotation around the alpha-axis value ranges from 0 to 1.</p>",
      "params": [],
      "examples": [
        "n(rotationAlpha.segment(4).range(0,7)).scale(\"C:minor\")"
      ],
      "synonyms": [
        "rotA",
        "rotZ",
        "rotationZ"
      ],
      "originalName": "rotationAlpha"
    },
    {
      "name": "rotB",
      "description": "<p>The device's rotation around the beta-axis value ranges from 0 to 1.</p>",
      "params": [],
      "examples": [
        "n(rotationBeta.segment(4).range(0,7)).scale(\"C:minor\")"
      ],
      "synonyms": [
        "rotB",
        "rotX",
        "rotationX"
      ],
      "originalName": "rotationBeta"
    },
    {
      "name": "rotG",
      "description": "<p>The device's rotation around the gamma-axis value ranges from 0 to 1.</p>",
      "params": [],
      "examples": [
        "n(rotationGamma.segment(4).range(0,7)).scale(\"C:minor\")"
      ],
      "synonyms": [
        "rotG",
        "rotY",
        "rotationY"
      ],
      "originalName": "rotationGamma"
    },
    {
      "name": "rotX",
      "description": "<p>The device's rotation around the beta-axis value ranges from 0 to 1.</p>",
      "params": [],
      "examples": [
        "n(rotationBeta.segment(4).range(0,7)).scale(\"C:minor\")"
      ],
      "synonyms": [
        "rotB",
        "rotX",
        "rotationX"
      ],
      "originalName": "rotationBeta"
    },
    {
      "name": "rotY",
      "description": "<p>The device's rotation around the gamma-axis value ranges from 0 to 1.</p>",
      "params": [],
      "examples": [
        "n(rotationGamma.segment(4).range(0,7)).scale(\"C:minor\")"
      ],
      "synonyms": [
        "rotG",
        "rotY",
        "rotationY"
      ],
      "originalName": "rotationGamma"
    },
    {
      "name": "rotZ",
      "description": "<p>The device's rotation around the alpha-axis value ranges from 0 to 1.</p>",
      "params": [],
      "examples": [
        "n(rotationAlpha.segment(4).range(0,7)).scale(\"C:minor\")"
      ],
      "synonyms": [
        "rotA",
        "rotZ",
        "rotationZ"
      ],
      "originalName": "rotationAlpha"
    },
    {
      "name": "round",
      "description": "<p>Assumes a numerical pattern. Returns a new pattern with all values rounded\nto the nearest integer.</p>",
      "params": [],
      "examples": [
        "n(\"0.5 1.5 2.5\".round()).scale(\"C:major\")"
      ],
      "synonyms": [],
      "originalName": "round"
    },
    {
      "name": "rsize",
      "description": "<p>Sets the room size of the reverb, see <code>room</code>.\nWhen this property is changed, the reverb will be recaculated, so only change this sparsely..</p>",
      "params": [
        {
          "name": "size",
          "type": "number | Pattern",
          "description": "<p>between 0 and 10</p>"
        }
      ],
      "examples": [
        "s(\"bd sd [~ bd] sd\").room(.8).rsize(1)",
        "s(\"bd sd [~ bd] sd\").room(.8).rsize(4)"
      ],
      "synonyms": [
        "rsize",
        "sz",
        "size"
      ],
      "originalName": "roomsize"
    },
    {
      "name": "run",
      "description": "<p>A discrete pattern of numbers from 0 to n-1</p>",
      "params": [],
      "examples": [
        "n(run(4)).scale(\"C4:pentatonic\")\r// n(\"0 1 2 3\").scale(\"C4:pentatonic\")"
      ],
      "synonyms": [],
      "originalName": "run"
    },
    {
      "name": "s",
      "description": "<p>Select a sound / sample by name. When using mininotation, you can also optionally supply 'n' and 'gain' parameters\nseparated by ':'.</p>",
      "params": [
        {
          "name": "sound",
          "type": "string | Pattern",
          "description": "<p>The sound / pattern of sounds to pick</p>"
        }
      ],
      "examples": [
        "s(\"bd hh\")",
        "s(\"bd:0 bd:1 bd:0:0.3 bd:1:1.4\")"
      ],
      "synonyms": [
        "sound"
      ],
      "originalName": "s"
    },
    {
      "name": "samples",
      "description": "<p>Loads a collection of samples to use with <code>s</code></p>",
      "params": [],
      "examples": [
        "samples('github:tidalcycles/dirt-samples');\rs(\"[bd ~]*2, [~ hh]*2, ~ sd\")",
        "samples({\r bd: '808bd/BD0000.WAV',\r sd: '808sd/SD0010.WAV'\r }, 'https://raw.githubusercontent.com/tidalcycles/Dirt-Samples/master/');\rs(\"[bd ~]*2, [~ hh]*2, ~ sd\")",
        "samples('shabda:noise,chimp:2')\rs(\"noise <chimp:0*2 chimp:1>\")",
        "samples('shabda/speech/fr-FR/f:chocolat')\rs(\"chocolat*4\")"
      ],
      "synonyms": [],
      "originalName": "samples"
    },
    {
      "name": "saw",
      "description": "<p>A sawtooth signal between 0 and 1.</p>",
      "params": [],
      "examples": [
        "note(\"<c3 [eb3,g3] g2 [g3,bb3]>*8\")\r.clip(saw.slow(2))",
        "n(saw.range(0,8).segment(8))\r.scale('C major')"
      ],
      "synonyms": [],
      "originalName": "saw"
    },
    {
      "name": "saw2",
      "description": "<p>A sawtooth signal between -1 and 1 (like <code>saw</code>, but bipolar).</p>",
      "params": [],
      "examples": [],
      "synonyms": [],
      "originalName": "saw2"
    },
    {
      "name": "scale",
      "description": "<p>Turns numbers into notes in the scale (zero indexed) or quantizes notes to a scale.</p>\n<p>When describing notes via numbers, note that negative numbers can be used to wrap backwards\nin the scale as well as sharps or flats to produce notes outside of the scale.</p>\n<p>Also sets scale for other scale operations, like {@link Pattern#scaleTranspose}.</p>\n<p>A scale consists of a root note (e.g. <code>c4</code>, <code>c</code>, <code>f#</code>, <code>bb4</code>) followed by semicolon (':') and then a <a href=\"https://github.com/tonaljs/tonal/blob/main/packages/scale-type/data.ts\">scale type</a>.</p>\n<p>The root note defaults to octave 3, if no octave number is given.</p>",
      "params": [
        {
          "name": "scale",
          "type": "string",
          "description": "<p>Name of scale</p>"
        }
      ],
      "examples": [
        "n(\"0 2 4 6 4 2\").scale(\"C:major\")",
        "n(\"[0,7] 4 [2,7] 4\")\r.scale(\"C:<major minor>/2\")\r.s(\"piano\")",
        "n(rand.range(0,12).segment(8))\r.scale(\"C:ritusen\")\r.s(\"piano\")",
        "n(\"<[0,7b] [-4# -4] [-2,7##] 4 [0,7] [-4# -4b] [-2,7###] 4b>*4\")\r.scale(\"C:<major minor>/2\")\r.s(\"piano\")",
        "note(\"C1*16\").transpose(irand(36)).scale('Cb2 major').scaleTranspose(3)"
      ],
      "synonyms": [],
      "originalName": "scale"
    },
    {
      "name": "scaleTrans",
      "description": "<p>Transposes notes inside the scale by the number of steps.\nExpected to be called on a Pattern which already has a {@link Pattern#scale}</p>",
      "params": [
        {
          "name": "offset",
          "type": "offset",
          "description": "<p>number of steps inside the scale</p>"
        }
      ],
      "examples": [
        "\"-8 [2,4,6]\"\r.scale('C4 bebop major')\r.scaleTranspose(\"<0 -1 -2 -3 -4 -5 -6 -4>\")\r.note()"
      ],
      "synonyms": [
        "scaleTrans",
        "strans"
      ],
      "originalName": "scaleTranspose"
    },
    {
      "name": "scaleTranspose",
      "description": "<p>Transposes notes inside the scale by the number of steps.\nExpected to be called on a Pattern which already has a {@link Pattern#scale}</p>",
      "params": [
        {
          "name": "offset",
          "type": "offset",
          "description": "<p>number of steps inside the scale</p>"
        }
      ],
      "examples": [
        "\"-8 [2,4,6]\"\r.scale('C4 bebop major')\r.scaleTranspose(\"<0 -1 -2 -3 -4 -5 -6 -4>\")\r.note()"
      ],
      "synonyms": [
        "scaleTrans",
        "strans"
      ],
      "originalName": "scaleTranspose"
    },
    {
      "name": "scope",
      "description": "<p>Renders an oscilloscope for the time domain of the audio signal.</p>",
      "params": [
        {
          "name": "config",
          "type": "object",
          "description": "<p>optional config with options:</p>"
        },
        {
          "name": "align",
          "type": "boolean",
          "description": "<p>if 1, the scope will be aligned to the first zero crossing. defaults to 1</p>"
        },
        {
          "name": "color",
          "type": "string",
          "description": "<p>line color as hex or color name. defaults to white.</p>"
        },
        {
          "name": "thickness",
          "type": "number",
          "description": "<p>line thickness. defaults to 3</p>"
        },
        {
          "name": "scale",
          "type": "number",
          "description": "<p>scales the y-axis. Defaults to 0.25</p>"
        },
        {
          "name": "pos",
          "type": "number",
          "description": "<p>y-position relative to screen height. 0 = top, 1 = bottom of screen</p>"
        },
        {
          "name": "trigger",
          "type": "number",
          "description": "<p>amplitude value that is used to align the scope. defaults to 0.</p>"
        }
      ],
      "examples": [
        "s(\"sawtooth\")._scope()"
      ],
      "synonyms": [
        "tscope"
      ],
      "originalName": "scope"
    },
    {
      "name": "scramble",
      "description": "<p>Slices a pattern into the given number of parts, then plays those parts at random. Similar to <code>shuffle</code>,\nbut parts might be played more than once, or not at all, per cycle.</p>",
      "params": [],
      "examples": [
        "note(\"c d e f\").sound(\"piano\").scramble(4)",
        "seq(\"c d e f\".scramble(4), \"g\").note().sound(\"piano\")"
      ],
      "synonyms": [],
      "originalName": "scramble"
    },
    {
      "name": "scrub",
      "description": "<p>Allows you to scrub an audio file like a tape loop by passing values that represents the position in the audio file\nin the optional array syntax ex: &quot;0.5:2&quot;, the second value controls the speed of playback</p>",
      "params": [],
      "examples": [
        "samples('github:switchangel/pad')\rs(\"swpad:0\").scrub(\"{0.1!2 .25@3 0.7!2 <0.8:1.5>}%8\")",
        "samples('github:yaxu/clean-breaks/main');\rs(\"amen/4\").fit().scrub(\"{0@3 0@2 4@3}%8\".div(16))"
      ],
      "synonyms": [],
      "originalName": "scrub"
    },
    {
      "name": "seg",
      "description": "<p>Samples the pattern at a rate of n events per cycle. Useful for turning a continuous pattern into a discrete one.</p>",
      "params": [
        {
          "name": "segments",
          "type": "number",
          "description": "<p>number of segments per cycle</p>"
        }
      ],
      "examples": [
        "note(saw.range(40,52).segment(24))"
      ],
      "synonyms": [
        "seg"
      ],
      "originalName": "segment"
    },
    {
      "name": "segment",
      "description": "<p>Samples the pattern at a rate of n events per cycle. Useful for turning a continuous pattern into a discrete one.</p>",
      "params": [
        {
          "name": "segments",
          "type": "number",
          "description": "<p>number of segments per cycle</p>"
        }
      ],
      "examples": [
        "note(saw.range(40,52).segment(24))"
      ],
      "synonyms": [
        "seg"
      ],
      "originalName": "segment"
    },
    {
      "name": "seq",
      "description": "<p>Like <strong>cat</strong>, but the items are crammed into one cycle.</p>",
      "params": [],
      "examples": [
        "seq(\"e5\", \"b4\", [\"d5\", \"c5\"]).note()\r// \"e5 b4 [d5 c5]\".note()",
        "// As a chained function:\rs(\"hh*4\").seq(\r  note(\"c4(5,8)\")\r)"
      ],
      "synonyms": [
        "sequence",
        "fastcat"
      ],
      "originalName": "seq"
    },
    {
      "name": "seqPLoop",
      "description": "<p>Similarly to <code>arrange</code>, allows you to arrange multiple patterns together over multiple cycles.\nUnlike <code>arrange</code>, you specify a start and stop time for each pattern rather than duration, which\nmeans that patterns can overlap.</p>",
      "params": [],
      "examples": [
        "seqPLoop([0, 2, \"bd(3,8)\"],\r\n         [1, 3, \"cp(3,8)\"]\r\n        )\r\n  .sound()"
      ],
      "synonyms": [],
      "originalName": "seqPLoop"
    },
    {
      "name": "sequence",
      "description": "<p>See <code>fastcat</code></p>",
      "params": [],
      "examples": [],
      "synonyms": [],
      "originalName": "sequence"
    },
    {
      "name": "sequenceP",
      "description": "<p>Takes a list of patterns, and returns a pattern of lists.</p>",
      "params": [],
      "examples": [],
      "synonyms": [],
      "originalName": "sequenceP"
    },
    {
      "name": "setContext",
      "description": "<p>Returns a new pattern with the context field set to every hap set to the given value.</p>",
      "params": [
        {
          "name": "context",
          "type": "*",
          "description": ""
        }
      ],
      "examples": [],
      "synonyms": [],
      "originalName": "setContext"
    },
    {
      "name": "setcpm",
      "description": "<p>Changes the global tempo to the given cycles per minute</p>",
      "params": [
        {
          "name": "cpm",
          "type": "number",
          "description": "<p>cycles per minute</p>"
        }
      ],
      "examples": [
        "setcpm(140/4) // =140 bpm in 4/4\r$: s(\"bd*4,[- sd]*2\").bank('tr707')"
      ],
      "synonyms": [],
      "originalName": "setcpm"
    },
    {
      "name": "shape",
      "description": "<p>(Deprecated) Wave shaping distortion. WARNING: can suddenly get unpredictably loud.\nPlease use distort instead, which has a more predictable response curve\nsecond option in optional array syntax (ex: &quot;.9:.5&quot;) applies a postgain to the output</p>",
      "params": [
        {
          "name": "distortion",
          "type": "number | Pattern",
          "description": "<p>between 0 and 1</p>"
        }
      ],
      "examples": [
        "s(\"bd sd [~ bd] sd,hh*8\").shape(\"<0 .2 .4 .6 .8>\")"
      ],
      "synonyms": [],
      "originalName": "shape"
    },
    {
      "name": "shiftInputBuffers",
      "description": "<p>Shift left content of input buffers to receive new web audio block</p>",
      "params": [],
      "examples": [],
      "synonyms": [],
      "originalName": "shiftInputBuffers"
    },
    {
      "name": "shiftOutputBuffers",
      "description": "<p>Shift left content of output buffers to receive new web audio block</p>",
      "params": [],
      "examples": [],
      "synonyms": [],
      "originalName": "shiftOutputBuffers"
    },
    {
      "name": "shiftPeaks",
      "description": "<p>Shift peaks and regions of influence by pitchFactor into new specturm</p>",
      "params": [],
      "examples": [],
      "synonyms": [],
      "originalName": "shiftPeaks"
    },
    {
      "name": "showFirstCycle",
      "description": "<p>More human-readable version of the <code>firstCycleValues</code> accessor.</p>",
      "params": [],
      "examples": [],
      "synonyms": [],
      "originalName": "showFirstCycle"
    },
    {
      "name": "shrink",
      "description": "<p><em>Experimental</em></p>\n<p>Progressively shrinks the pattern by 'n' steps until there's nothing left, or if a second value is given (using mininotation list syntax with <code>:</code>),\nthat number of times.\nA positive number will progressively drop steps from the start of a pattern, and a negative number from the end.</p>",
      "params": [],
      "examples": [
        "\"tha dhi thom nam\".shrink(\"1\").sound()\r.bank(\"mridangam\")",
        "\"tha dhi thom nam\".shrink(\"-1\").sound()\r.bank(\"mridangam\")",
        "\"tha dhi thom nam\".shrink(\"1 -1\").sound().bank(\"mridangam\").pace(4)",
        "note(\"0 1 2 3 4 5 6 7\".scale(\"C:ritusen\")).sound(\"folkharp\")\r\n   .shrink(\"1 -1\").pace(8)"
      ],
      "synonyms": [],
      "originalName": "shrink"
    },
    {
      "name": "shuffle",
      "description": "<p>Slices a pattern into the given number of parts, then plays those parts in random order.\nEach part will be played exactly once per cycle.</p>",
      "params": [],
      "examples": [
        "note(\"c d e f\").sound(\"piano\").shuffle(4)",
        "seq(\"c d e f\".shuffle(4), \"g\").note().sound(\"piano\")"
      ],
      "synonyms": [],
      "originalName": "shuffle"
    },
    {
      "name": "silence",
      "description": "<p>Does absolutely nothing..</p>",
      "params": [],
      "examples": [
        "silence // \"~\""
      ],
      "synonyms": [],
      "originalName": "silence"
    },
    {
      "name": "sine",
      "description": "<p>A sine signal between 0 and 1.</p>",
      "params": [],
      "examples": [
        "n(sine.segment(16).range(0,15))\r.scale(\"C:minor\")"
      ],
      "synonyms": [],
      "originalName": "sine"
    },
    {
      "name": "sine2",
      "description": "<p>A sine signal between -1 and 1 (like <code>sine</code>, but bipolar).</p>",
      "params": [],
      "examples": [],
      "synonyms": [],
      "originalName": "sine2"
    },
    {
      "name": "sinefold",
      "description": "<p>Wavefolding distortion composed with sinusoid</p>",
      "params": [
        {
          "name": "distortion",
          "type": "number | Pattern",
          "description": "<p>amount of distortion to apply</p>"
        },
        {
          "name": "volume",
          "type": "number | Pattern",
          "description": "<p>linear postgain of the distortion</p>"
        }
      ],
      "examples": [],
      "synonyms": [],
      "originalName": "sinefold"
    },
    {
      "name": "size",
      "description": "<p>Sets the room size of the reverb, see <code>room</code>.\nWhen this property is changed, the reverb will be recaculated, so only change this sparsely..</p>",
      "params": [
        {
          "name": "size",
          "type": "number | Pattern",
          "description": "<p>between 0 and 10</p>"
        }
      ],
      "examples": [
        "s(\"bd sd [~ bd] sd\").room(.8).rsize(1)",
        "s(\"bd sd [~ bd] sd\").room(.8).rsize(4)"
      ],
      "synonyms": [
        "rsize",
        "sz",
        "size"
      ],
      "originalName": "roomsize"
    },
    {
      "name": "slice",
      "description": "<p>Chops samples into the given number of slices, triggering those slices with a given pattern of slice numbers.\nInstead of a number, it also accepts a list of numbers from 0 to 1 to slice at specific points.</p>",
      "params": [],
      "examples": [
        "samples('github:tidalcycles/dirt-samples')\rs(\"breaks165\").slice(8, \"0 1 <2 2*2> 3 [4 0] 5 6 7\".every(3, rev)).slow(0.75)",
        "samples('github:tidalcycles/dirt-samples')\rs(\"breaks125\").fit().slice([0,.25,.5,.75], \"0 1 1 <2 3>\")"
      ],
      "synonyms": [],
      "originalName": "slice"
    },
    {
      "name": "slider",
      "description": "<p>Displays a slider widget to allow the user manipulate a value</p>",
      "params": [
        {
          "name": "value",
          "type": "number",
          "description": "<p>Initial value</p>"
        },
        {
          "name": "min",
          "type": "number",
          "description": "<p>Minimum value - optional, defaults to 0</p>"
        },
        {
          "name": "max",
          "type": "number",
          "description": "<p>Maximum value - optional, defaults to 1</p>"
        },
        {
          "name": "step",
          "type": "number",
          "description": "<p>Step size - optional</p>"
        }
      ],
      "examples": [],
      "synonyms": [],
      "originalName": "slider"
    },
    {
      "name": "slow",
      "description": "<p>Slow down a pattern over the given number of cycles. Like the &quot;/&quot; operator in mini notation.</p>",
      "params": [
        {
          "name": "factor",
          "type": "number | Pattern",
          "description": "<p>slow down factor</p>"
        }
      ],
      "examples": [
        "s(\"bd hh sd hh\").slow(2) // s(\"[bd hh sd hh]/2\")"
      ],
      "synonyms": [
        "sparsity"
      ],
      "originalName": "slow"
    },
    {
      "name": "slowcat",
      "description": "<p>Concatenation: combines a list of patterns, switching between them successively, one per cycle.</p>",
      "params": [],
      "examples": [
        "slowcat(\"e5\", \"b4\", [\"d5\", \"c5\"])"
      ],
      "synonyms": [
        "cat"
      ],
      "originalName": "slowcat"
    },
    {
      "name": "slowcatPrime",
      "description": "<p>Concatenation: combines a list of patterns, switching between them successively, one per cycle. Unlike slowcat, this version will skip cycles.</p>",
      "params": [
        {
          "name": "items",
          "type": "any",
          "description": "<p>The items to concatenate</p>"
        }
      ],
      "examples": [],
      "synonyms": [],
      "originalName": "slowcatPrime"
    },
    {
      "name": "slowchunk",
      "description": "<p>Divides a pattern into a given number of parts, then cycles through those parts in turn, applying the given function to each part in turn (one part per cycle).</p>",
      "params": [],
      "examples": [
        "\"0 1 2 3\".chunk(4, x=>x.add(7))\r.scale(\"A:minor\").note()"
      ],
      "synonyms": [
        "slowChunk",
        "slowchunk"
      ],
      "originalName": "chunk"
    },
    {
      "name": "slowChunk",
      "description": "<p>Divides a pattern into a given number of parts, then cycles through those parts in turn, applying the given function to each part in turn (one part per cycle).</p>",
      "params": [],
      "examples": [
        "\"0 1 2 3\".chunk(4, x=>x.add(7))\r.scale(\"A:minor\").note()"
      ],
      "synonyms": [
        "slowChunk",
        "slowchunk"
      ],
      "originalName": "chunk"
    },
    {
      "name": "soft",
      "description": "<p>Soft-clipping distortion</p>",
      "params": [
        {
          "name": "distortion",
          "type": "number | Pattern",
          "description": "<p>amount of distortion to apply</p>"
        },
        {
          "name": "volume",
          "type": "number | Pattern",
          "description": "<p>linear postgain of the distortion</p>"
        }
      ],
      "examples": [],
      "synonyms": [],
      "originalName": "soft"
    },
    {
      "name": "someCycles",
      "description": "<p>Shorthand for <code>.someCyclesBy(0.5, fn)</code></p>",
      "params": [],
      "examples": [
        "s(\"bd,hh*8\").someCycles(x=>x.speed(\"0.5\"))"
      ],
      "synonyms": [],
      "originalName": "someCycles"
    },
    {
      "name": "someCyclesBy",
      "description": "<p>Randomly applies the given function by the given probability on a cycle by cycle basis.\nSimilar to <code>sometimesBy</code></p>",
      "params": [
        {
          "name": "probability",
          "type": "number | Pattern",
          "description": "<p>a number between 0 and 1</p>"
        },
        {
          "name": "function",
          "type": "function",
          "description": "<p>the transformation to apply</p>"
        }
      ],
      "examples": [
        "s(\"bd,hh*8\").someCyclesBy(.3, x=>x.speed(\"0.5\"))"
      ],
      "synonyms": [],
      "originalName": "someCyclesBy"
    },
    {
      "name": "sometimes",
      "description": "<p>Applies the given function with a 50% chance</p>",
      "params": [
        {
          "name": "function",
          "type": "function",
          "description": "<p>the transformation to apply</p>"
        }
      ],
      "examples": [
        "s(\"hh*8\").sometimes(x=>x.speed(\"0.5\"))"
      ],
      "synonyms": [],
      "originalName": "sometimes"
    },
    {
      "name": "sometimesBy",
      "description": "<p>Randomly applies the given function by the given probability.\nSimilar to <code>someCyclesBy</code></p>",
      "params": [
        {
          "name": "probability",
          "type": "number | Pattern",
          "description": "<p>a number between 0 and 1</p>"
        },
        {
          "name": "function",
          "type": "function",
          "description": "<p>the transformation to apply</p>"
        }
      ],
      "examples": [
        "s(\"hh*8\").sometimesBy(.4, x=>x.speed(\"0.5\"))"
      ],
      "synonyms": [],
      "originalName": "sometimesBy"
    },
    {
      "name": "sortHapsByPart",
      "description": "<p>Returns a new pattern, which returns haps sorted in temporal order. Mainly\nof use when comparing two patterns for equality, in tests.</p>",
      "params": [],
      "examples": [],
      "synonyms": [],
      "originalName": "sortHapsByPart"
    },
    {
      "name": "sound",
      "description": "<p>Select a sound / sample by name. When using mininotation, you can also optionally supply 'n' and 'gain' parameters\nseparated by ':'.</p>",
      "params": [
        {
          "name": "sound",
          "type": "string | Pattern",
          "description": "<p>The sound / pattern of sounds to pick</p>"
        }
      ],
      "examples": [
        "s(\"bd hh\")",
        "s(\"bd:0 bd:1 bd:0:0.3 bd:1:1.4\")"
      ],
      "synonyms": [
        "sound"
      ],
      "originalName": "s"
    },
    {
      "name": "soundAlias",
      "description": "<p>Register an alias for a sound.</p>",
      "params": [
        {
          "name": "original",
          "type": "string",
          "description": "<p>The original sound name</p>"
        },
        {
          "name": "alias",
          "type": "string",
          "description": "<p>The alias to use for the sound</p>"
        }
      ],
      "examples": [],
      "synonyms": [],
      "originalName": "soundAlias"
    },
    {
      "name": "source",
      "description": "<p>Define a custom webaudio node to use as a sound source.</p>",
      "params": [
        {
          "name": "getSource",
          "type": "function",
          "description": ""
        }
      ],
      "examples": [],
      "synonyms": [
        "src"
      ],
      "originalName": "source"
    },
    {
      "name": "sparsity",
      "description": "<p>Slow down a pattern over the given number of cycles. Like the &quot;/&quot; operator in mini notation.</p>",
      "params": [
        {
          "name": "factor",
          "type": "number | Pattern",
          "description": "<p>slow down factor</p>"
        }
      ],
      "examples": [
        "s(\"bd hh sd hh\").slow(2) // s(\"[bd hh sd hh]/2\")"
      ],
      "synonyms": [
        "sparsity"
      ],
      "originalName": "slow"
    },
    {
      "name": "spectrum",
      "description": "<p>Renders a spectrum analyzer for the incoming audio signal.</p>",
      "params": [
        {
          "name": "config",
          "type": "object",
          "description": "<p>optional config with options:</p>"
        },
        {
          "name": "thickness",
          "type": "integer",
          "description": "<p>line thickness in px (default 3)</p>"
        },
        {
          "name": "speed",
          "type": "integer",
          "description": "<p>scroll speed (default 1)</p>"
        },
        {
          "name": "min",
          "type": "integer",
          "description": "<p>min db (default -80)</p>"
        },
        {
          "name": "max",
          "type": "integer",
          "description": "<p>max db (default 0)</p>"
        }
      ],
      "examples": [
        "n(\"<0 4 <2 3> 1>*3\")\r.off(1/8, add(n(5)))\r.off(1/5, add(n(7)))\r.scale(\"d3:minor:pentatonic\")\r.s('sine')\r.dec(.3).room(.5)\r._spectrum()"
      ],
      "synonyms": [],
      "originalName": "spectrum"
    },
    {
      "name": "speed",
      "description": "<p>Changes the speed of sample playback, i.e. a cheap way of changing pitch.</p>",
      "params": [
        {
          "name": "speed",
          "type": "number | Pattern",
          "description": "<p>inf to inf, negative numbers play the sample backwards.</p>"
        }
      ],
      "examples": [
        "s(\"bd*6\").speed(\"1 2 4 1 -2 -4\")",
        "speed(\"1 1.5*2 [2 1.1]\").s(\"piano\").clip(1)"
      ],
      "synonyms": [],
      "originalName": "speed"
    },
    {
      "name": "spiral",
      "description": "<p>Displays a spiral visual.</p>",
      "params": [
        {
          "name": "options",
          "type": "Object",
          "description": "<p>Object containing all the optional following parameters as key value pairs:</p>"
        },
        {
          "name": "stretch",
          "type": "number",
          "description": "<p>controls the rotations per cycle ratio, where 1 = 1 cycle / 360 degrees</p>"
        },
        {
          "name": "size",
          "type": "number",
          "description": "<p>the diameter of the spiral</p>"
        },
        {
          "name": "thickness",
          "type": "number",
          "description": "<p>line thickness</p>"
        },
        {
          "name": "cap",
          "type": "string",
          "description": "<p>style of line ends: butt (default), round, square</p>"
        },
        {
          "name": "inset",
          "type": "string",
          "description": "<p>number of rotations before spiral starts (default 3)</p>"
        },
        {
          "name": "playheadColor",
          "type": "string",
          "description": "<p>color of playhead, defaults to white</p>"
        },
        {
          "name": "playheadLength",
          "type": "number",
          "description": "<p>length of playhead in rotations, defaults to 0.02</p>"
        },
        {
          "name": "playheadThickness",
          "type": "number",
          "description": "<p>thickness of playheadrotations, defaults to thickness</p>"
        },
        {
          "name": "padding",
          "type": "number",
          "description": "<p>space around spiral</p>"
        },
        {
          "name": "steady",
          "type": "number",
          "description": "<p>steadyness of spiral vs playhead. 1 = spiral doesn't move, playhead does.</p>"
        },
        {
          "name": "activeColor",
          "type": "number",
          "description": "<p>color of active segment. defaults to foreground of theme</p>"
        },
        {
          "name": "inactiveColor",
          "type": "number",
          "description": "<p>color of inactive segments. defaults to gutterForeground of theme</p>"
        },
        {
          "name": "colorizeInactive",
          "type": "boolean",
          "description": "<p>wether or not to colorize inactive segments, defaults to 0</p>"
        },
        {
          "name": "fade",
          "type": "boolean",
          "description": "<p>wether or not past and future should fade out. defaults to 1</p>"
        },
        {
          "name": "logSpiral",
          "type": "boolean",
          "description": "<p>wether or not the spiral should be logarithmic. defaults to 0</p>"
        }
      ],
      "examples": [
        "note(\"c2 a2 eb2\")\r.euclid(5,8)\r.s('sawtooth')\r.lpenv(4).lpf(300)\r._spiral({ steady: .96 })"
      ],
      "synonyms": [],
      "originalName": "spiral"
    },
    {
      "name": "splice",
      "description": "<p>Works the same as slice, but changes the playback speed of each slice to match the duration of its step.</p>",
      "params": [],
      "examples": [
        "samples('github:tidalcycles/dirt-samples')\rs(\"breaks165\")\r.splice(8,  \"0 1 [2 3 0]@2 3 0@2 7\")"
      ],
      "synonyms": [],
      "originalName": "splice"
    },
    {
      "name": "splitQueries",
      "description": "<p>Returns a new pattern, with queries split at cycle boundaries. This makes\nsome calculations easier to express, as all haps are then constrained to\nhappen within a cycle.</p>",
      "params": [],
      "examples": [],
      "synonyms": [],
      "originalName": "splitQueries"
    },
    {
      "name": "spread",
      "description": "<p>Set the stereo pan spread for supported oscillators</p>",
      "params": [
        {
          "name": "spread",
          "type": "number | Pattern",
          "description": "<p>between 0 and 1</p>"
        }
      ],
      "examples": [
        "note(\"d f a a# a d3\").fast(2).s(\"supersaw\").spread(\"<0 .3 1>\")"
      ],
      "synonyms": [],
      "originalName": "spread"
    },
    {
      "name": "square",
      "description": "<p>A square signal between 0 and 1.</p>",
      "params": [],
      "examples": [
        "n(square.segment(4).range(0,7)).scale(\"C:minor\")"
      ],
      "synonyms": [],
      "originalName": "square"
    },
    {
      "name": "square2",
      "description": "<p>A square signal between -1 and 1 (like <code>square</code>, but bipolar).</p>",
      "params": [],
      "examples": [],
      "synonyms": [],
      "originalName": "square2"
    },
    {
      "name": "squeeze",
      "description": "<p>Pick from the list of values (or patterns of values) via the index using the given\npattern of integers. The selected pattern will be compressed to fit the duration of the selecting event</p>",
      "params": [
        {
          "name": "pat",
          "type": "Pattern",
          "description": ""
        },
        {
          "name": "xs",
          "type": "*",
          "description": ""
        }
      ],
      "examples": [
        "note(squeeze(\"<0@2 [1!2] 2>\", [\"g a\", \"f g f g\" , \"g a c d\"]))"
      ],
      "synonyms": [],
      "originalName": "squeeze"
    },
    {
      "name": "squiz",
      "description": "<p>Made by Calum Gunn. Reminiscent of some weird mixture of filter, ring-modulator and pitch-shifter. The SuperCollider manual defines Squiz as:</p>\n<p>&quot;A simplistic pitch-raising algorithm. It's not meant to sound natural; its sound is reminiscent of some weird mixture of filter, ring-modulator and pitch-shifter, depending on the input. The algorithm works by cutting the signal into fragments (delimited by upwards-going zero-crossings) and squeezing those fragments in the time domain (i.e. simply playing them back faster than they came in), leaving silences inbetween. All the parameters apart from memlen can be modulated.&quot;</p>",
      "params": [
        {
          "name": "squiz",
          "type": "number | Pattern",
          "description": "<p>Try passing multiples of 2 to it - 2, 4, 8 etc.</p>"
        }
      ],
      "examples": [
        "squiz(\"2 4/2 6 [8 16]\").s(\"bd\").osc()"
      ],
      "synonyms": [],
      "originalName": "squiz"
    },
    {
      "name": "src",
      "description": "<p>Define a custom webaudio node to use as a sound source.</p>",
      "params": [
        {
          "name": "getSource",
          "type": "function",
          "description": ""
        }
      ],
      "examples": [],
      "synonyms": [
        "src"
      ],
      "originalName": "source"
    },
    {
      "name": "stack",
      "description": "<p>The given items are played at the same time at the same length.</p>",
      "params": [],
      "examples": [
        "stack(\"g3\", \"b3\", [\"e4\", \"d4\"]).note()\r// \"g3,b3,[e4 d4]\".note()",
        "// As a chained function:\rs(\"hh*4\").stack(\r  note(\"c4(5,8)\")\r)"
      ],
      "synonyms": [
        "polyrhythm",
        "pr"
      ],
      "originalName": "stack"
    },
    {
      "name": "stepalt",
      "description": "<p><em>Experimental</em></p>\n<p>Concatenates patterns stepwise, according to an inferred 'steps per cycle'.\nSimilar to <code>stepcat</code>, but if an argument is a list, the whole pattern will alternate between the elements in the list.</p>",
      "params": [],
      "examples": [
        "stepalt([\"bd cp\", \"mt\"], \"bd\").sound()\r// The same as \"bd cp bd mt bd\".sound()"
      ],
      "synonyms": [],
      "originalName": "stepalt"
    },
    {
      "name": "stepcat",
      "description": "<p>'Concatenates' patterns like <code>fastcat</code>, but proportional to a number of steps per cycle.\nThe steps can either be inferred from the pattern, or provided as a [length, pattern] pair.\nHas the alias <code>timecat</code>.</p>",
      "params": [],
      "examples": [
        "stepcat([3,\"e3\"],[1, \"g3\"]).note()\r// the same as \"e3@3 g3\".note()",
        "stepcat(\"bd sd cp\",\"hh hh\").sound()\r// the same as \"bd sd cp hh hh\".sound()"
      ],
      "synonyms": [
        "timeCat",
        "timecat"
      ],
      "originalName": "stepcat"
    },
    {
      "name": "strans",
      "description": "<p>Transposes notes inside the scale by the number of steps.\nExpected to be called on a Pattern which already has a {@link Pattern#scale}</p>",
      "params": [
        {
          "name": "offset",
          "type": "offset",
          "description": "<p>number of steps inside the scale</p>"
        }
      ],
      "examples": [
        "\"-8 [2,4,6]\"\r.scale('C4 bebop major')\r.scaleTranspose(\"<0 -1 -2 -3 -4 -5 -6 -4>\")\r.note()"
      ],
      "synonyms": [
        "scaleTrans",
        "strans"
      ],
      "originalName": "scaleTranspose"
    },
    {
      "name": "stretch",
      "description": "<p>Changes the speed of sample playback, i.e. a cheap way of changing pitch.</p>",
      "params": [
        {
          "name": "factor",
          "type": "number | Pattern",
          "description": "<p>inf to inf, negative numbers play the sample backwards.</p>"
        }
      ],
      "examples": [
        "s(\"gm_flute\").stretch(\"1 2 .5\")"
      ],
      "synonyms": [],
      "originalName": "stretch"
    },
    {
      "name": "striate",
      "description": "<p>Cuts each sample into the given number of parts, triggering progressive portions of each sample at each loop.</p>",
      "params": [],
      "examples": [
        "s(\"numbers:0 numbers:1 numbers:2\").striate(6).slow(3)"
      ],
      "synonyms": [],
      "originalName": "striate"
    },
    {
      "name": "stripContext",
      "description": "<p>Returns a new pattern with the context field of every hap set to an empty object.</p>",
      "params": [],
      "examples": [],
      "synonyms": [],
      "originalName": "stripContext"
    },
    {
      "name": "struct",
      "description": "<p>Applies the given structure to the pattern:</p>",
      "params": [],
      "examples": [
        "note(\"c,eb,g\")\r  .struct(\"x ~ x ~ ~ x ~ x ~ ~ ~ x ~ x ~ ~\")\r  .slow(2)"
      ],
      "synonyms": [],
      "originalName": "struct"
    },
    {
      "name": "stut",
      "description": "<p>Deprecated. Like echo, but the last 2 parameters are flipped.</p>",
      "params": [
        {
          "name": "times",
          "type": "number",
          "description": "<p>how many times to repeat</p>"
        },
        {
          "name": "feedback",
          "type": "number",
          "description": "<p>velocity multiplicator for each iteration</p>"
        },
        {
          "name": "time",
          "type": "number",
          "description": "<p>cycle offset between iterations</p>"
        }
      ],
      "examples": [
        "s(\"bd sd\").stut(3, .8, 1/6)"
      ],
      "synonyms": [],
      "originalName": "stut"
    },
    {
      "name": "stutwith",
      "description": "<p>Superimpose and offset multiple times, applying the given function each time.</p>",
      "params": [
        {
          "name": "times",
          "type": "number",
          "description": "<p>how many times to repeat</p>"
        },
        {
          "name": "time",
          "type": "number",
          "description": "<p>cycle offset between iterations</p>"
        },
        {
          "name": "func",
          "type": "function",
          "description": "<p>function to apply, given the pattern and the iteration index</p>"
        }
      ],
      "examples": [
        "\"<0 [2 4]>\"\r.echoWith(4, 1/8, (p,n) => p.add(n*2))\r.scale(\"C:minor\").note()"
      ],
      "synonyms": [
        "echowith",
        "stutWith",
        "stutwith"
      ],
      "originalName": "echoWith"
    },
    {
      "name": "stutWith",
      "description": "<p>Superimpose and offset multiple times, applying the given function each time.</p>",
      "params": [
        {
          "name": "times",
          "type": "number",
          "description": "<p>how many times to repeat</p>"
        },
        {
          "name": "time",
          "type": "number",
          "description": "<p>cycle offset between iterations</p>"
        },
        {
          "name": "func",
          "type": "function",
          "description": "<p>function to apply, given the pattern and the iteration index</p>"
        }
      ],
      "examples": [
        "\"<0 [2 4]>\"\r.echoWith(4, 1/8, (p,n) => p.add(n*2))\r.scale(\"C:minor\").note()"
      ],
      "synonyms": [
        "echowith",
        "stutWith",
        "stutwith"
      ],
      "originalName": "echoWith"
    },
    {
      "name": "sub",
      "description": "<p>Like add, but the given numbers are subtracted.</p>",
      "params": [],
      "examples": [
        "n(\"0 2 4\".sub(\"<0 1 2 3>\")).scale(\"C4:minor\")\r// See add for more information."
      ],
      "synonyms": [],
      "originalName": "sub"
    },
    {
      "name": "superimpose",
      "description": "<p>Superimposes the result of the given function(s) on top of the original pattern:</p>",
      "params": [],
      "examples": [
        "\"<0 2 4 6 ~ 4 ~ 2 0!3 ~!5>*8\"\r  .superimpose(x=>x.add(2))\r  .scale('C minor').note()"
      ],
      "synonyms": [],
      "originalName": "superimpose"
    },
    {
      "name": "sus",
      "description": "<p>Amplitude envelope sustain level: The level which is reached after attack / decay, being sustained until the offset.</p>",
      "params": [
        {
          "name": "gain",
          "type": "number | Pattern",
          "description": "<p>sustain level between 0 and 1</p>"
        }
      ],
      "examples": [
        "note(\"c3 e3 f3 g3\").decay(.2).sustain(\"<0 .1 .4 .6 1>\")"
      ],
      "synonyms": [
        "sus"
      ],
      "originalName": "sustain"
    },
    {
      "name": "sustain",
      "description": "<p>Amplitude envelope sustain level: The level which is reached after attack / decay, being sustained until the offset.</p>",
      "params": [
        {
          "name": "gain",
          "type": "number | Pattern",
          "description": "<p>sustain level between 0 and 1</p>"
        }
      ],
      "examples": [
        "note(\"c3 e3 f3 g3\").decay(.2).sustain(\"<0 .1 .4 .6 1>\")"
      ],
      "synonyms": [
        "sus"
      ],
      "originalName": "sustain"
    },
    {
      "name": "swing",
      "description": "<p>Shorthand for swingBy with 1/3:</p>",
      "params": [
        {
          "name": "subdivision",
          "type": "number",
          "description": ""
        }
      ],
      "examples": [
        "s(\"hh*8\").swing(4)\r// s(\"hh*8\").swingBy(1/3, 4)"
      ],
      "synonyms": [],
      "originalName": "swing"
    },
    {
      "name": "swingBy",
      "description": "<p>The function <code>swingBy x n</code> breaks each cycle into <code>n</code> slices, and then delays events in the second half of each slice by the amount <code>x</code>, which is relative to the size of the (half) slice. So if <code>x</code> is 0 it does nothing, <code>0.5</code> delays for half the note duration, and 1 will wrap around to doing nothing again. The end result is a shuffle or swing-like rhythm</p>",
      "params": [
        {
          "name": "subdivision",
          "type": "number",
          "description": ""
        },
        {
          "name": "offset",
          "type": "number",
          "description": ""
        }
      ],
      "examples": [
        "s(\"hh*8\").swingBy(1/3, 4)"
      ],
      "synonyms": [],
      "originalName": "swingBy"
    },
    {
      "name": "sysex",
      "description": "<p>MIDI sysex: Sends a MIDI sysex message.</p>",
      "params": [
        {
          "name": "id",
          "type": "number | Pattern",
          "description": "<p>Sysex ID</p>"
        },
        {
          "name": "data",
          "type": "number | Pattern",
          "description": "<p>Sysex data</p>"
        }
      ],
      "examples": [
        "note(\"c4\").sysex([\"0x77\", \"0x01:0x02:0x03:0x04\"]).midichan(1).midi()"
      ],
      "synonyms": [],
      "originalName": "sysex"
    },
    {
      "name": "sysexdata",
      "description": "<p>MIDI sysex data: Sends a MIDI sysex message.</p>",
      "params": [
        {
          "name": "data",
          "type": "number | Pattern",
          "description": "<p>Sysex data</p>"
        }
      ],
      "examples": [
        "note(\"c4\").sysexid(\"0x77\").sysexdata(\"0x01:0x02:0x03:0x04\").midichan(1).midi()"
      ],
      "synonyms": [],
      "originalName": "sysexdata"
    },
    {
      "name": "sysexid",
      "description": "<p>MIDI sysex ID: Sends a MIDI sysex identifier message.</p>",
      "params": [
        {
          "name": "id",
          "type": "number | Pattern",
          "description": "<p>Sysex ID</p>"
        }
      ],
      "examples": [
        "note(\"c4\").sysexid(\"0x77\").sysexdata(\"0x01:0x02:0x03:0x04\").midichan(1).midi()"
      ],
      "synonyms": [],
      "originalName": "sysexid"
    },
    {
      "name": "sz",
      "description": "<p>Sets the room size of the reverb, see <code>room</code>.\nWhen this property is changed, the reverb will be recaculated, so only change this sparsely..</p>",
      "params": [
        {
          "name": "size",
          "type": "number | Pattern",
          "description": "<p>between 0 and 10</p>"
        }
      ],
      "examples": [
        "s(\"bd sd [~ bd] sd\").room(.8).rsize(1)",
        "s(\"bd sd [~ bd] sd\").room(.8).rsize(4)"
      ],
      "synonyms": [
        "rsize",
        "sz",
        "size"
      ],
      "originalName": "roomsize"
    },
    {
      "name": "tables",
      "description": "<p>Loads a collection of wavetables to use with <code>s</code></p>",
      "params": [],
      "examples": [],
      "synonyms": [],
      "originalName": "tables"
    },
    {
      "name": "tag",
      "description": "<p>Tags each Hap with an identifier. Good for filtering. The function populates Hap.context.tags (Array).</p>",
      "params": [
        {
          "name": "tag",
          "type": "string",
          "description": "<p>anything unique</p>"
        }
      ],
      "examples": [],
      "synonyms": [],
      "originalName": "tag"
    },
    {
      "name": "take",
      "description": "<p><em>Experimental</em></p>\n<p>Takes the given number of steps from a pattern (dropping the rest).\nA positive number will take steps from the start of a pattern, and a negative number from the end.</p>",
      "params": [],
      "examples": [
        "\"bd cp ht mt\".take(\"2\").sound()\r// The same as \"bd cp\".sound()",
        "\"bd cp ht mt\".take(\"1 2 3\").sound()\r// The same as \"bd bd cp bd cp ht\".sound()",
        "\"bd cp ht mt\".take(\"-1 -2 -3\").sound()\r// The same as \"mt ht mt cp ht mt\".sound()"
      ],
      "synonyms": [],
      "originalName": "take"
    },
    {
      "name": "time",
      "description": "<p>A signal representing the cycle time.</p>",
      "params": [],
      "examples": [],
      "synonyms": [],
      "originalName": "time"
    },
    {
      "name": "timecat",
      "description": "<p>'Concatenates' patterns like <code>fastcat</code>, but proportional to a number of steps per cycle.\nThe steps can either be inferred from the pattern, or provided as a [length, pattern] pair.\nHas the alias <code>timecat</code>.</p>",
      "params": [],
      "examples": [
        "stepcat([3,\"e3\"],[1, \"g3\"]).note()\r// the same as \"e3@3 g3\".note()",
        "stepcat(\"bd sd cp\",\"hh hh\").sound()\r// the same as \"bd sd cp hh hh\".sound()"
      ],
      "synonyms": [
        "timeCat",
        "timecat"
      ],
      "originalName": "stepcat"
    },
    {
      "name": "timeCat",
      "description": "<p>'Concatenates' patterns like <code>fastcat</code>, but proportional to a number of steps per cycle.\nThe steps can either be inferred from the pattern, or provided as a [length, pattern] pair.\nHas the alias <code>timecat</code>.</p>",
      "params": [],
      "examples": [
        "stepcat([3,\"e3\"],[1, \"g3\"]).note()\r// the same as \"e3@3 g3\".note()",
        "stepcat(\"bd sd cp\",\"hh hh\").sound()\r// the same as \"bd sd cp hh hh\".sound()"
      ],
      "synonyms": [
        "timeCat",
        "timecat"
      ],
      "originalName": "stepcat"
    },
    {
      "name": "toBipolar",
      "description": "<p>Assumes a numerical pattern, containing unipolar values in the range 0 ..</p>\n<ol>\n<li>Returns a new pattern with values scaled to the bipolar range -1 .. 1</li>\n</ol>",
      "params": [],
      "examples": [],
      "synonyms": [],
      "originalName": "toBipolar"
    },
    {
      "name": "tour",
      "description": "<p><em>Experimental</em></p>\n<p>Inserts a pattern into a list of patterns. On the first repetition it will be inserted at the end of the list, then moved backwards through the list\non successive repetitions. The patterns are added together stepwise, with all repetitions taking place over a single cycle. Using <code>pace</code> to set the\nnumber of steps per cycle is therefore usually recommended.</p>",
      "params": [],
      "examples": [
        "\"[c g]\".tour(\"e f\", \"e f g\", \"g f e c\").note()\r\n   .sound(\"folkharp\")\r\n   .pace(8)"
      ],
      "synonyms": [],
      "originalName": "tour"
    },
    {
      "name": "trans",
      "description": "<p>Change the pitch of each value by the given amount. Expects numbers or note strings as values.\nThe amount can be given as a number of semitones or as a string in interval short notation.\nIf you don't care about enharmonic correctness, just use numbers. Otherwise, pass the interval of\nthe form: ST where S is the degree number and T the type of interval with</p>\n<ul>\n<li>M = major</li>\n<li>m = minor</li>\n<li>P = perfect</li>\n<li>A = augmented</li>\n<li>d = diminished</li>\n</ul>\n<p>Examples intervals:</p>\n<ul>\n<li>1P = unison</li>\n<li>3M = major third</li>\n<li>3m = minor third</li>\n<li>4P = perfect fourth</li>\n<li>4A = augmented fourth</li>\n<li>5P = perfect fifth</li>\n<li>5d = diminished fifth</li>\n</ul>",
      "params": [
        {
          "name": "amount",
          "type": "string | number",
          "description": "<p>Either number of semitones or interval string.</p>"
        }
      ],
      "examples": [
        "\"c2 c3\".fast(2).transpose(\"<0 -2 5 3>\".slow(2)).note()",
        "\"c2 c3\".fast(2).transpose(\"<1P -2M 4P 3m>\".slow(2)).note()"
      ],
      "synonyms": [
        "trans"
      ],
      "originalName": "transpose"
    },
    {
      "name": "transpose",
      "description": "<p>Change the pitch of each value by the given amount. Expects numbers or note strings as values.\nThe amount can be given as a number of semitones or as a string in interval short notation.\nIf you don't care about enharmonic correctness, just use numbers. Otherwise, pass the interval of\nthe form: ST where S is the degree number and T the type of interval with</p>\n<ul>\n<li>M = major</li>\n<li>m = minor</li>\n<li>P = perfect</li>\n<li>A = augmented</li>\n<li>d = diminished</li>\n</ul>\n<p>Examples intervals:</p>\n<ul>\n<li>1P = unison</li>\n<li>3M = major third</li>\n<li>3m = minor third</li>\n<li>4P = perfect fourth</li>\n<li>4A = augmented fourth</li>\n<li>5P = perfect fifth</li>\n<li>5d = diminished fifth</li>\n</ul>",
      "params": [
        {
          "name": "amount",
          "type": "string | number",
          "description": "<p>Either number of semitones or interval string.</p>"
        }
      ],
      "examples": [
        "\"c2 c3\".fast(2).transpose(\"<0 -2 5 3>\".slow(2)).note()",
        "\"c2 c3\".fast(2).transpose(\"<1P -2M 4P 3m>\".slow(2)).note()"
      ],
      "synonyms": [
        "trans"
      ],
      "originalName": "transpose"
    },
    {
      "name": "trem",
      "description": "<p>Modulate the amplitude of a sound with a continuous waveform</p>",
      "params": [
        {
          "name": "speed",
          "type": "number | Pattern",
          "description": "<p>modulation speed in HZ</p>"
        }
      ],
      "examples": [
        "note(\"d d d# d\".fast(4)).s(\"supersaw\").tremolo(\"<3 2 100> \").tremoloskew(\"<.5>\")"
      ],
      "synonyms": [
        "trem"
      ],
      "originalName": "tremolo"
    },
    {
      "name": "tremdepth",
      "description": "<p>Depth of amplitude modulation</p>",
      "params": [
        {
          "name": "depth",
          "type": "number | Pattern",
          "description": ""
        }
      ],
      "examples": [
        "note(\"a1 a1 a#1 a1\".fast(4)).s(\"pulse\").tremsync(4).tremolodepth(\"<1 2 .7>\")"
      ],
      "synonyms": [
        "tremdepth"
      ],
      "originalName": "tremolodepth"
    },
    {
      "name": "tremolo",
      "description": "<p>Modulate the amplitude of a sound with a continuous waveform</p>",
      "params": [
        {
          "name": "speed",
          "type": "number | Pattern",
          "description": "<p>modulation speed in HZ</p>"
        }
      ],
      "examples": [
        "note(\"d d d# d\".fast(4)).s(\"supersaw\").tremolo(\"<3 2 100> \").tremoloskew(\"<.5>\")"
      ],
      "synonyms": [
        "trem"
      ],
      "originalName": "tremolo"
    },
    {
      "name": "tremolodepth",
      "description": "<p>Depth of amplitude modulation</p>",
      "params": [
        {
          "name": "depth",
          "type": "number | Pattern",
          "description": ""
        }
      ],
      "examples": [
        "note(\"a1 a1 a#1 a1\".fast(4)).s(\"pulse\").tremsync(4).tremolodepth(\"<1 2 .7>\")"
      ],
      "synonyms": [
        "tremdepth"
      ],
      "originalName": "tremolodepth"
    },
    {
      "name": "tremolophase",
      "description": "<p>Alter the phase of the modulation waveform</p>",
      "params": [
        {
          "name": "offset",
          "type": "number | Pattern",
          "description": "<p>the offset in cycles of the modulation</p>"
        }
      ],
      "examples": [
        "note(\"{f a c e}%16\").s(\"sawtooth\").tremsync(4).tremolophase(\"<0 .25 .66>\")"
      ],
      "synonyms": [
        "tremphase"
      ],
      "originalName": "tremolophase"
    },
    {
      "name": "tremoloshape",
      "description": "<p>Shape of amplitude modulation</p>",
      "params": [
        {
          "name": "shape",
          "type": "number | Pattern",
          "description": "<p>tri | square | sine | saw | ramp</p>"
        }
      ],
      "examples": [
        "note(\"{f g c d}%16\").tremsync(4).tremoloshape(\"<sine tri square>\").s(\"sawtooth\")"
      ],
      "synonyms": [
        "tremshape"
      ],
      "originalName": "tremoloshape"
    },
    {
      "name": "tremoloskew",
      "description": "<p>Alter the shape of the modulation waveform</p>",
      "params": [
        {
          "name": "amount",
          "type": "number | Pattern",
          "description": "<p>between 0 &amp; 1, the shape of the waveform</p>"
        }
      ],
      "examples": [
        "note(\"{f a c e}%16\").s(\"sawtooth\").tremsync(4).tremoloskew(\"<.5 0 1>\")"
      ],
      "synonyms": [
        "tremskew"
      ],
      "originalName": "tremoloskew"
    },
    {
      "name": "tremolosync",
      "description": "<p>Modulate the amplitude of a sound with a continuous waveform</p>",
      "params": [
        {
          "name": "cycles",
          "type": "number | Pattern",
          "description": "<p>modulation speed in cycles</p>"
        }
      ],
      "examples": [
        "note(\"d d d# d\".fast(4)).s(\"supersaw\").tremolosync(\"4\").tremoloskew(\"<1 .5 0>\")"
      ],
      "synonyms": [
        "tremsync"
      ],
      "originalName": "tremolosync"
    },
    {
      "name": "tremphase",
      "description": "<p>Alter the phase of the modulation waveform</p>",
      "params": [
        {
          "name": "offset",
          "type": "number | Pattern",
          "description": "<p>the offset in cycles of the modulation</p>"
        }
      ],
      "examples": [
        "note(\"{f a c e}%16\").s(\"sawtooth\").tremsync(4).tremolophase(\"<0 .25 .66>\")"
      ],
      "synonyms": [
        "tremphase"
      ],
      "originalName": "tremolophase"
    },
    {
      "name": "tremshape",
      "description": "<p>Shape of amplitude modulation</p>",
      "params": [
        {
          "name": "shape",
          "type": "number | Pattern",
          "description": "<p>tri | square | sine | saw | ramp</p>"
        }
      ],
      "examples": [
        "note(\"{f g c d}%16\").tremsync(4).tremoloshape(\"<sine tri square>\").s(\"sawtooth\")"
      ],
      "synonyms": [
        "tremshape"
      ],
      "originalName": "tremoloshape"
    },
    {
      "name": "tremskew",
      "description": "<p>Alter the shape of the modulation waveform</p>",
      "params": [
        {
          "name": "amount",
          "type": "number | Pattern",
          "description": "<p>between 0 &amp; 1, the shape of the waveform</p>"
        }
      ],
      "examples": [
        "note(\"{f a c e}%16\").s(\"sawtooth\").tremsync(4).tremoloskew(\"<.5 0 1>\")"
      ],
      "synonyms": [
        "tremskew"
      ],
      "originalName": "tremoloskew"
    },
    {
      "name": "tremsync",
      "description": "<p>Modulate the amplitude of a sound with a continuous waveform</p>",
      "params": [
        {
          "name": "cycles",
          "type": "number | Pattern",
          "description": "<p>modulation speed in cycles</p>"
        }
      ],
      "examples": [
        "note(\"d d d# d\".fast(4)).s(\"supersaw\").tremolosync(\"4\").tremoloskew(\"<1 .5 0>\")"
      ],
      "synonyms": [
        "tremsync"
      ],
      "originalName": "tremolosync"
    },
    {
      "name": "tri",
      "description": "<p>A triangle signal between 0 and 1.</p>",
      "params": [],
      "examples": [
        "n(tri.segment(8).range(0,7)).scale(\"C:minor\")"
      ],
      "synonyms": [],
      "originalName": "tri"
    },
    {
      "name": "tri2",
      "description": "<p>A triangle signal between -1 and 1 (like <code>tri</code>, but bipolar).</p>",
      "params": [],
      "examples": [],
      "synonyms": [],
      "originalName": "tri2"
    },
    {
      "name": "tscope",
      "description": "<p>Renders an oscilloscope for the time domain of the audio signal.</p>",
      "params": [
        {
          "name": "config",
          "type": "object",
          "description": "<p>optional config with options:</p>"
        },
        {
          "name": "align",
          "type": "boolean",
          "description": "<p>if 1, the scope will be aligned to the first zero crossing. defaults to 1</p>"
        },
        {
          "name": "color",
          "type": "string",
          "description": "<p>line color as hex or color name. defaults to white.</p>"
        },
        {
          "name": "thickness",
          "type": "number",
          "description": "<p>line thickness. defaults to 3</p>"
        },
        {
          "name": "scale",
          "type": "number",
          "description": "<p>scales the y-axis. Defaults to 0.25</p>"
        },
        {
          "name": "pos",
          "type": "number",
          "description": "<p>y-position relative to screen height. 0 = top, 1 = bottom of screen</p>"
        },
        {
          "name": "trigger",
          "type": "number",
          "description": "<p>amplitude value that is used to align the scope. defaults to 0.</p>"
        }
      ],
      "examples": [
        "s(\"sawtooth\")._scope()"
      ],
      "synonyms": [
        "tscope"
      ],
      "originalName": "scope"
    },
    {
      "name": "undegrade",
      "description": "<p>Inverse of <code>degrade</code>: Randomly removes 50% of events from the pattern. Shorthand for <code>.undegradeBy(0.5)</code>\nEvents that would be removed by degrade are let through by undegrade and vice versa (see second example).</p>",
      "params": [],
      "examples": [
        "s(\"hh*8\").undegrade()",
        "s(\"hh*10\").layer(\r  x => x.degrade().pan(0),\r  x => x.undegrade().pan(1)\r)"
      ],
      "synonyms": [],
      "originalName": "undegrade"
    },
    {
      "name": "undegradeBy",
      "description": "<p>Inverse of <code>degradeBy</code>: Randomly removes events from the pattern by a given amount.\n0 = 100% chance of removal\n1 = 0% chance of removal\nEvents that would be removed by degradeBy are let through by undegradeBy and vice versa (see second example).</p>",
      "params": [
        {
          "name": "amount",
          "type": "number",
          "description": "<p>a number between 0 and 1</p>"
        }
      ],
      "examples": [
        "s(\"hh*8\").undegradeBy(0.2)",
        "s(\"hh*10\").layer(\r  x => x.degradeBy(0.2).pan(0),\r  x => x.undegradeBy(0.8).pan(1)\r)"
      ],
      "synonyms": [],
      "originalName": "undegradeBy"
    },
    {
      "name": "unison",
      "description": "<p>Set number of stacked voices for supported oscillators</p>",
      "params": [
        {
          "name": "numvoices",
          "type": "number | Pattern",
          "description": ""
        }
      ],
      "examples": [
        "note(\"d f a a# a d3\").fast(2).s(\"supersaw\").unison(\"<1 2 7>\")"
      ],
      "synonyms": [],
      "originalName": "unison"
    },
    {
      "name": "unit",
      "description": "<p>Used in conjunction with <code>speed</code>, accepts values of &quot;r&quot; (rate, default behavior), &quot;c&quot; (cycles), or &quot;s&quot; (seconds). Using <code>unit &quot;c&quot;</code> means <code>speed</code> will be interpreted in units of cycles, e.g. <code>speed &quot;1&quot;</code> means samples will be stretched to fill a cycle. Using <code>unit &quot;s&quot;</code> means the playback speed will be adjusted so that the duration is the number of seconds specified by <code>speed</code>.</p>",
      "params": [
        {
          "name": "unit",
          "type": "number | string | Pattern",
          "description": "<p>see description above</p>"
        }
      ],
      "examples": [
        "speed(\"1 2 .5 3\").s(\"bd\").unit(\"c\").osc()"
      ],
      "synonyms": [],
      "originalName": "unit"
    },
    {
      "name": "v",
      "description": "<p>Applies a vibrato to the frequency of the oscillator.</p>",
      "params": [
        {
          "name": "frequency",
          "type": "number | Pattern",
          "description": "<p>of the vibrato in hertz</p>"
        }
      ],
      "examples": [
        "note(\"a e\")\r.vib(\"<.5 1 2 4 8 16>\")\r._scope()",
        "// change the modulation depth with \":\"\rnote(\"a e\")\r.vib(\"<.5 1 2 4 8 16>:12\")\r._scope()"
      ],
      "synonyms": [
        "vibrato",
        "v"
      ],
      "originalName": "vib"
    },
    {
      "name": "velocity",
      "description": "<p>Sets the velocity from 0 to 1. Is multiplied together with gain.</p>",
      "params": [],
      "examples": [
        "s(\"hh*8\")\r.gain(\".4!2 1 .4!2 1 .4 1\")\r.velocity(\".4 1\")"
      ],
      "synonyms": [],
      "originalName": "velocity"
    },
    {
      "name": "vib",
      "description": "<p>Applies a vibrato to the frequency of the oscillator.</p>",
      "params": [
        {
          "name": "frequency",
          "type": "number | Pattern",
          "description": "<p>of the vibrato in hertz</p>"
        }
      ],
      "examples": [
        "note(\"a e\")\r.vib(\"<.5 1 2 4 8 16>\")\r._scope()",
        "// change the modulation depth with \":\"\rnote(\"a e\")\r.vib(\"<.5 1 2 4 8 16>:12\")\r._scope()"
      ],
      "synonyms": [
        "vibrato",
        "v"
      ],
      "originalName": "vib"
    },
    {
      "name": "vibmod",
      "description": "<p>Sets the vibrato depth in semitones. Only has an effect if <code>vibrato</code> | <code>vib</code> | <code>v</code> is is also set</p>",
      "params": [
        {
          "name": "depth",
          "type": "number | Pattern",
          "description": "<p>of vibrato (in semitones)</p>"
        }
      ],
      "examples": [
        "note(\"a e\").vib(4)\r.vibmod(\"<.25 .5 1 2 12>\")\r._scope()",
        "// change the vibrato frequency with \":\"\rnote(\"a e\")\r.vibmod(\"<.25 .5 1 2 12>:8\")\r._scope()"
      ],
      "synonyms": [
        "vmod"
      ],
      "originalName": "vibmod"
    },
    {
      "name": "vibrato",
      "description": "<p>Applies a vibrato to the frequency of the oscillator.</p>",
      "params": [
        {
          "name": "frequency",
          "type": "number | Pattern",
          "description": "<p>of the vibrato in hertz</p>"
        }
      ],
      "examples": [
        "note(\"a e\")\r.vib(\"<.5 1 2 4 8 16>\")\r._scope()",
        "// change the modulation depth with \":\"\rnote(\"a e\")\r.vib(\"<.5 1 2 4 8 16>:12\")\r._scope()"
      ],
      "synonyms": [
        "vibrato",
        "v"
      ],
      "originalName": "vib"
    },
    {
      "name": "vmod",
      "description": "<p>Sets the vibrato depth in semitones. Only has an effect if <code>vibrato</code> | <code>vib</code> | <code>v</code> is is also set</p>",
      "params": [
        {
          "name": "depth",
          "type": "number | Pattern",
          "description": "<p>of vibrato (in semitones)</p>"
        }
      ],
      "examples": [
        "note(\"a e\").vib(4)\r.vibmod(\"<.25 .5 1 2 12>\")\r._scope()",
        "// change the vibrato frequency with \":\"\rnote(\"a e\")\r.vibmod(\"<.25 .5 1 2 12>:8\")\r._scope()"
      ],
      "synonyms": [
        "vmod"
      ],
      "originalName": "vibmod"
    },
    {
      "name": "voicing",
      "description": "<p>Turns chord symbols into voicings. You can use the following control params:</p>\n<ul>\n<li><code>chord</code>: Note, followed by chord symbol, e.g. C Am G7 Bb^7</li>\n<li><code>dict</code>: voicing dictionary to use, falls back to default dictionary</li>\n<li><code>anchor</code>: the note that is used to align the chord</li>\n<li><code>mode</code>: how the voicing is aligned to the anchor\n<ul>\n<li><code>below</code>: top note &lt;= anchor</li>\n<li><code>duck</code>: top note &lt;= anchor, anchor excluded</li>\n<li><code>above</code>: bottom note &gt;= anchor</li>\n</ul>\n</li>\n<li><code>offset</code>: whole number that shifts the voicing up or down to the next voicing</li>\n<li><code>n</code>: if set, the voicing is played like a scale. Overshooting numbers will be octaved</li>\n</ul>\n<p>All of the above controls are optional, except <code>chord</code>.\nIf you pass a pattern of strings to voicing, they will be interpreted as chords.</p>",
      "params": [],
      "examples": [
        "n(\"0 1 2 3\").chord(\"<C Am F G>\").voicing()"
      ],
      "synonyms": [],
      "originalName": "voicing"
    },
    {
      "name": "voicings",
      "description": "<p>DEPRECATED: still works, but it is recommended you use .voicing instead (without s).\nTurns chord symbols into voicings, using the smoothest voice leading possible.\nUses <a href=\"https://github.com/felixroos/chord-voicings#chord-voicings\">chord-voicings package</a>.</p>",
      "params": [
        {
          "name": "dictionary",
          "type": "string",
          "description": "<p>which voicing dictionary to use.</p>"
        }
      ],
      "examples": [
        "stack(\"<C^7 A7 Dm7 G7>\".voicings('lefthand'), \"<C3 A2 D3 G2>\").note()"
      ],
      "synonyms": [],
      "originalName": "voicings"
    },
    {
      "name": "vowel",
      "description": "<p>Formant filter to make things sound like vowels.</p>",
      "params": [
        {
          "name": "vowel",
          "type": "string | Pattern",
          "description": "<p>You can use a e i o u ae aa oe ue y uh un en an on, corresponding to [a] [e] [i] [o] [u] [] [] [] [y] [] [] [] [] [] []. Aliases: aa =  = , oe =  = , y = , ae = .</p>"
        }
      ],
      "examples": [
        "note(\"[c2 <eb2 <g2 g1>>]*2\").s('sawtooth')\r.vowel(\"<a e i <o u>>\")",
        "s(\"bd sd mt ht bd [~ cp] ht lt\").vowel(\"[a|e|i|o|u]\")"
      ],
      "synonyms": [],
      "originalName": "vowel"
    },
    {
      "name": "warp",
      "description": "<p>Amount of warp (alteration of the waveform) to apply to the wavetable oscillator</p>",
      "params": [
        {
          "name": "amount",
          "type": "number | Pattern",
          "description": "<p>Warp of the wavetable from 0 to 1</p>"
        }
      ],
      "examples": [
        "s(\"basique\").bank(\"wt_digital\").seg(8).note(\"F1\").warp(\"0 0.25 0.5 0.75 1\")\r  .warpmode(\"spin\")"
      ],
      "synonyms": [
        "wavetableWarp"
      ],
      "originalName": "warp"
    },
    {
      "name": "warpatt",
      "description": "<p>Attack time of the wavetable oscillator's warp envelope</p>",
      "params": [
        {
          "name": "time",
          "type": "number | Pattern",
          "description": "<p>attack time in seconds</p>"
        }
      ],
      "examples": [],
      "synonyms": [
        "warpatt"
      ],
      "originalName": "warpattack"
    },
    {
      "name": "warpattack",
      "description": "<p>Attack time of the wavetable oscillator's warp envelope</p>",
      "params": [
        {
          "name": "time",
          "type": "number | Pattern",
          "description": "<p>attack time in seconds</p>"
        }
      ],
      "examples": [],
      "synonyms": [
        "warpatt"
      ],
      "originalName": "warpattack"
    },
    {
      "name": "warpdc",
      "description": "<p>DC offset of the LFO for the wavetable oscillator's warp</p>",
      "params": [
        {
          "name": "dcoffset",
          "type": "number | Pattern",
          "description": "<p>dc offset. set to 0 for unipolar</p>"
        }
      ],
      "examples": [],
      "synonyms": [],
      "originalName": "warpdc"
    },
    {
      "name": "warpdec",
      "description": "<p>Decay time of the wavetable oscillator's warp envelope</p>",
      "params": [
        {
          "name": "time",
          "type": "number | Pattern",
          "description": "<p>decay time in seconds</p>"
        }
      ],
      "examples": [],
      "synonyms": [
        "warpdec"
      ],
      "originalName": "warpdecay"
    },
    {
      "name": "warpdecay",
      "description": "<p>Decay time of the wavetable oscillator's warp envelope</p>",
      "params": [
        {
          "name": "time",
          "type": "number | Pattern",
          "description": "<p>decay time in seconds</p>"
        }
      ],
      "examples": [],
      "synonyms": [
        "warpdec"
      ],
      "originalName": "warpdecay"
    },
    {
      "name": "warpdepth",
      "description": "<p>Depth of the LFO for the wavetable oscillator's warp</p>",
      "params": [
        {
          "name": "depth",
          "type": "number | Pattern",
          "description": "<p>depth of modulation</p>"
        }
      ],
      "examples": [],
      "synonyms": [],
      "originalName": "warpdepth"
    },
    {
      "name": "warpenv",
      "description": "<p>Amount of envelope applied wavetable oscillator's position envelope</p>",
      "params": [
        {
          "name": "amount",
          "type": "number | Pattern",
          "description": "<p>between 0 and 1</p>"
        }
      ],
      "examples": [],
      "synonyms": [],
      "originalName": "warpenv"
    },
    {
      "name": "warpmode",
      "description": "<p>Type of warp (alteration of the waveform) to apply to the wavetable oscillator.</p>\n<p>The current options are: none, asym, bendp, bendm, bendmp, sync, quant, fold, pwm, orbit,\nspin, chaos, primes, binary, brownian, reciprocal, wormhole, logistic, sigmoid, fractal, flip</p>",
      "params": [
        {
          "name": "mode",
          "type": "number | string | Pattern",
          "description": "<p>Warp mode</p>"
        }
      ],
      "examples": [
        "s(\"morgana\").bank(\"wt_digital\").seg(8).note(\"F1\").warp(\"0 0.25 0.5 0.75 1\")\r  .warpmode(\"<asym bendp spin logistic sync wormhole brownian>*2\")"
      ],
      "synonyms": [
        "wavetableWarpMode"
      ],
      "originalName": "warpmode"
    },
    {
      "name": "warprate",
      "description": "<p>Rate of the LFO for the wavetable oscillator's warp</p>",
      "params": [
        {
          "name": "rate",
          "type": "number | Pattern",
          "description": "<p>rate in hertz</p>"
        }
      ],
      "examples": [],
      "synonyms": [],
      "originalName": "warprate"
    },
    {
      "name": "warprel",
      "description": "<p>Release time of the wavetable oscillator's warp envelope</p>",
      "params": [
        {
          "name": "time",
          "type": "number | Pattern",
          "description": "<p>release time in seconds</p>"
        }
      ],
      "examples": [],
      "synonyms": [
        "warprel"
      ],
      "originalName": "warprelease"
    },
    {
      "name": "warprelease",
      "description": "<p>Release time of the wavetable oscillator's warp envelope</p>",
      "params": [
        {
          "name": "time",
          "type": "number | Pattern",
          "description": "<p>release time in seconds</p>"
        }
      ],
      "examples": [],
      "synonyms": [
        "warprel"
      ],
      "originalName": "warprelease"
    },
    {
      "name": "warpshape",
      "description": "<p>Shape of the LFO for the wavetable oscillator's warp</p>",
      "params": [
        {
          "name": "shape",
          "type": "number | Pattern",
          "description": "<p>Shape of the lfo (0, 1, 2, ..)</p>"
        }
      ],
      "examples": [],
      "synonyms": [],
      "originalName": "warpshape"
    },
    {
      "name": "warpskew",
      "description": "<p>Skew of the LFO for the wavetable oscillator's warp</p>",
      "params": [
        {
          "name": "skew",
          "type": "number | Pattern",
          "description": "<p>How much to bend the LFO shape</p>"
        }
      ],
      "examples": [],
      "synonyms": [],
      "originalName": "warpskew"
    },
    {
      "name": "warpsus",
      "description": "<p>Sustain time of the wavetable oscillator's warp envelope</p>",
      "params": [
        {
          "name": "gain",
          "type": "number | Pattern",
          "description": "<p>sustain level (0 to 1)</p>"
        }
      ],
      "examples": [],
      "synonyms": [
        "warpsus"
      ],
      "originalName": "warpsustain"
    },
    {
      "name": "warpsustain",
      "description": "<p>Sustain time of the wavetable oscillator's warp envelope</p>",
      "params": [
        {
          "name": "gain",
          "type": "number | Pattern",
          "description": "<p>sustain level (0 to 1)</p>"
        }
      ],
      "examples": [],
      "synonyms": [
        "warpsus"
      ],
      "originalName": "warpsustain"
    },
    {
      "name": "warpsync",
      "description": "<p>cycle synced rate of the LFO for the wavetable warp position</p>",
      "params": [
        {
          "name": "rate",
          "type": "number | Pattern",
          "description": "<p>rate in cycles</p>"
        }
      ],
      "examples": [],
      "synonyms": [],
      "originalName": "warpsync"
    },
    {
      "name": "wavetablePhaseRand",
      "description": "<p>Amount of randomness of the initial phase of the wavetable oscillator.</p>",
      "params": [
        {
          "name": "amount",
          "type": "number | Pattern",
          "description": "<p>Randomness of the initial phase. Between 0 (not random) and 1 (fully random)</p>"
        }
      ],
      "examples": [
        "s(\"basique\").bank(\"wt_digital\").seg(16).wtphaserand(\"<0 1>\")"
      ],
      "synonyms": [
        "wavetablePhaseRand"
      ],
      "originalName": "wtphaserand"
    },
    {
      "name": "wavetablePosition",
      "description": "<p>Position in the wavetable of the wavetable oscillator</p>",
      "params": [
        {
          "name": "position",
          "type": "number | Pattern",
          "description": "<p>Position in the wavetable from 0 to 1</p>"
        }
      ],
      "examples": [
        "s(\"squelch\").bank(\"wt_digital\").seg(8).note(\"F1\").wt(\"0 0.25 0.5 0.75 1\")"
      ],
      "synonyms": [
        "wavetablePosition"
      ],
      "originalName": "wt"
    },
    {
      "name": "wavetableWarp",
      "description": "<p>Amount of warp (alteration of the waveform) to apply to the wavetable oscillator</p>",
      "params": [
        {
          "name": "amount",
          "type": "number | Pattern",
          "description": "<p>Warp of the wavetable from 0 to 1</p>"
        }
      ],
      "examples": [
        "s(\"basique\").bank(\"wt_digital\").seg(8).note(\"F1\").warp(\"0 0.25 0.5 0.75 1\")\r  .warpmode(\"spin\")"
      ],
      "synonyms": [
        "wavetableWarp"
      ],
      "originalName": "warp"
    },
    {
      "name": "wavetableWarpMode",
      "description": "<p>Type of warp (alteration of the waveform) to apply to the wavetable oscillator.</p>\n<p>The current options are: none, asym, bendp, bendm, bendmp, sync, quant, fold, pwm, orbit,\nspin, chaos, primes, binary, brownian, reciprocal, wormhole, logistic, sigmoid, fractal, flip</p>",
      "params": [
        {
          "name": "mode",
          "type": "number | string | Pattern",
          "description": "<p>Warp mode</p>"
        }
      ],
      "examples": [
        "s(\"morgana\").bank(\"wt_digital\").seg(8).note(\"F1\").warp(\"0 0.25 0.5 0.75 1\")\r  .warpmode(\"<asym bendp spin logistic sync wormhole brownian>*2\")"
      ],
      "synonyms": [
        "wavetableWarpMode"
      ],
      "originalName": "warpmode"
    },
    {
      "name": "wchoose",
      "description": "<p>Chooses randomly from the given list of elements by giving a probability to each element</p>",
      "params": [
        {
          "name": "pairs",
          "type": "any",
          "description": "<p>arrays of value and weight</p>"
        }
      ],
      "examples": [
        "note(\"c2 g2!2 d2 f1\").s(wchoose([\"sine\",10], [\"triangle\",1], [\"bd:6\",1]))"
      ],
      "synonyms": [],
      "originalName": "wchoose"
    },
    {
      "name": "wchooseCycles",
      "description": "<p>Picks one of the elements at random each cycle by giving a probability to each element</p>",
      "params": [],
      "examples": [
        "wchooseCycles([\"bd\",10], [\"hh\",1], [\"sd\",1]).s().fast(8)",
        "wchooseCycles([\"bd bd bd\",5], [\"hh hh hh\",3], [\"sd sd sd\",1]).fast(4).s()",
        "// The probability can itself be a pattern\rwchooseCycles([\"bd(3,8)\",\"<5 0>\"], [\"hh hh hh\",3]).fast(4).s()"
      ],
      "synonyms": [
        "wrandcat"
      ],
      "originalName": "wchooseCycles"
    },
    {
      "name": "when",
      "description": "<p>Applies the given function whenever the given pattern is in a true state.</p>",
      "params": [
        {
          "name": "binary_pat",
          "type": "Pattern",
          "description": ""
        },
        {
          "name": "func",
          "type": "function",
          "description": ""
        }
      ],
      "examples": [
        "\"c3 eb3 g3\".when(\"<0 1>/2\", x=>x.sub(\"5\")).note()"
      ],
      "synonyms": [],
      "originalName": "when"
    },
    {
      "name": "whenKey",
      "description": "<p>Do something on a keypress, or array of keypresses\n<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/UI_Events/Keyboard_event_key_values\">Key name reference</a></p>",
      "params": [],
      "examples": [
        "s(\"bd(5,8)\").whenKey(\"Control:j\", x => x.segment(16).color(\"red\")).whenKey(\"Control:i\", x => x.fast(2).color(\"blue\"))"
      ],
      "synonyms": [],
      "originalName": "whenKey"
    },
    {
      "name": "withContext",
      "description": "<p>Returns a new pattern with the given function applied to the context field of every hap.</p>",
      "params": [
        {
          "name": "func",
          "type": "function",
          "description": ""
        }
      ],
      "examples": [],
      "synonyms": [],
      "originalName": "withContext"
    },
    {
      "name": "withHap",
      "description": "<p>As with <code>withHaps</code>, but applies the function to every hap, rather than every list of haps.</p>",
      "params": [
        {
          "name": "func",
          "type": "function",
          "description": ""
        }
      ],
      "examples": [],
      "synonyms": [],
      "originalName": "withHap"
    },
    {
      "name": "withHaps",
      "description": "<p>Returns a new pattern with the given function applied to the list of haps returned by every query.</p>",
      "params": [
        {
          "name": "func",
          "type": "function",
          "description": ""
        }
      ],
      "examples": [],
      "synonyms": [],
      "originalName": "withHaps"
    },
    {
      "name": "withHapSpan",
      "description": "<p>Similar to <code>withQuerySpan</code>, but the function is applied to the timespans\nof all haps returned by pattern queries (both <code>part</code> timespans, and where\npresent, <code>whole</code> timespans).</p>",
      "params": [
        {
          "name": "func",
          "type": "function",
          "description": ""
        }
      ],
      "examples": [],
      "synonyms": [],
      "originalName": "withHapSpan"
    },
    {
      "name": "withHapTime",
      "description": "<p>As with <code>withHapSpan</code>, but the function is applied to both the\nbegin and end time of the hap timespans.</p>",
      "params": [
        {
          "name": "func",
          "type": "function",
          "description": "<p>the function to apply</p>"
        }
      ],
      "examples": [],
      "synonyms": [],
      "originalName": "withHapTime"
    },
    {
      "name": "within",
      "description": "<p>Use within to apply a function to only a part of a pattern.</p>",
      "params": [
        {
          "name": "start",
          "type": "number",
          "description": "<p>start within cycle (0 - 1)</p>"
        },
        {
          "name": "end",
          "type": "number",
          "description": "<p>end within cycle (0 - 1). Must be &gt; start</p>"
        },
        {
          "name": "func",
          "type": "function",
          "description": "<p>function to be applied to the sub-pattern</p>"
        }
      ],
      "examples": [],
      "synonyms": [],
      "originalName": "within"
    },
    {
      "name": "withLoc",
      "description": "<p>Returns a new pattern with the given location information added to the\ncontext of every hap.</p>",
      "params": [
        {
          "name": "start",
          "type": "Number",
          "description": "<p>start offset</p>"
        },
        {
          "name": "end",
          "type": "Number",
          "description": "<p>end offset</p>"
        }
      ],
      "examples": [],
      "synonyms": [],
      "originalName": "withLoc"
    },
    {
      "name": "withQuerySpan",
      "description": "<p>Returns a new pattern, where the given function is applied to the query\ntimespan before passing it to the original pattern.</p>",
      "params": [
        {
          "name": "func",
          "type": "function",
          "description": "<p>the function to apply</p>"
        }
      ],
      "examples": [],
      "synonyms": [],
      "originalName": "withQuerySpan"
    },
    {
      "name": "withQueryTime",
      "description": "<p>As with <code>withQuerySpan</code>, but the function is applied to both the\nbegin and end time of the query timespan.</p>",
      "params": [
        {
          "name": "func",
          "type": "function",
          "description": "<p>the function to apply</p>"
        }
      ],
      "examples": [],
      "synonyms": [],
      "originalName": "withQueryTime"
    },
    {
      "name": "withValue",
      "description": "<p>Returns a new pattern, with the function applied to the value of\neach hap. It has the alias <code>fmap</code>.</p>",
      "params": [
        {
          "name": "func",
          "type": "function",
          "description": "<p>to to apply to the value</p>"
        }
      ],
      "examples": [
        "\"0 1 2\".withValue(v => v + 10).log()"
      ],
      "synonyms": [
        "fmap"
      ],
      "originalName": "withValue"
    },
    {
      "name": "wordfall",
      "description": "<p>Displays a vertical pianoroll with event labels.\nSupports all the same options as pianoroll.</p>",
      "params": [],
      "examples": [],
      "synonyms": [],
      "originalName": "wordfall"
    },
    {
      "name": "wrandcat",
      "description": "<p>Picks one of the elements at random each cycle by giving a probability to each element</p>",
      "params": [],
      "examples": [
        "wchooseCycles([\"bd\",10], [\"hh\",1], [\"sd\",1]).s().fast(8)",
        "wchooseCycles([\"bd bd bd\",5], [\"hh hh hh\",3], [\"sd sd sd\",1]).fast(4).s()",
        "// The probability can itself be a pattern\rwchooseCycles([\"bd(3,8)\",\"<5 0>\"], [\"hh hh hh\",3]).fast(4).s()"
      ],
      "synonyms": [
        "wrandcat"
      ],
      "originalName": "wchooseCycles"
    },
    {
      "name": "writeOutputs",
      "description": "<p>Write next web audio block from output buffers</p>",
      "params": [],
      "examples": [],
      "synonyms": [],
      "originalName": "writeOutputs"
    },
    {
      "name": "wt",
      "description": "<p>Position in the wavetable of the wavetable oscillator</p>",
      "params": [
        {
          "name": "position",
          "type": "number | Pattern",
          "description": "<p>Position in the wavetable from 0 to 1</p>"
        }
      ],
      "examples": [
        "s(\"squelch\").bank(\"wt_digital\").seg(8).note(\"F1\").wt(\"0 0.25 0.5 0.75 1\")"
      ],
      "synonyms": [
        "wavetablePosition"
      ],
      "originalName": "wt"
    },
    {
      "name": "wtatt",
      "description": "<p>Attack time of the wavetable oscillator's position envelope</p>",
      "params": [
        {
          "name": "time",
          "type": "number | Pattern",
          "description": "<p>attack time in seconds</p>"
        }
      ],
      "examples": [],
      "synonyms": [
        "wtatt"
      ],
      "originalName": "wtattack"
    },
    {
      "name": "wtattack",
      "description": "<p>Attack time of the wavetable oscillator's position envelope</p>",
      "params": [
        {
          "name": "time",
          "type": "number | Pattern",
          "description": "<p>attack time in seconds</p>"
        }
      ],
      "examples": [],
      "synonyms": [
        "wtatt"
      ],
      "originalName": "wtattack"
    },
    {
      "name": "wtdc",
      "description": "<p>DC offset of the LFO for the wavetable oscillator's position</p>",
      "params": [
        {
          "name": "dcoffset",
          "type": "number | Pattern",
          "description": "<p>dc offset. set to 0 for unipolar</p>"
        }
      ],
      "examples": [],
      "synonyms": [],
      "originalName": "wtdc"
    },
    {
      "name": "wtdec",
      "description": "<p>Decay time of the wavetable oscillator's position envelope</p>",
      "params": [
        {
          "name": "time",
          "type": "number | Pattern",
          "description": "<p>decay time in seconds</p>"
        }
      ],
      "examples": [],
      "synonyms": [
        "wtdec"
      ],
      "originalName": "wtdecay"
    },
    {
      "name": "wtdecay",
      "description": "<p>Decay time of the wavetable oscillator's position envelope</p>",
      "params": [
        {
          "name": "time",
          "type": "number | Pattern",
          "description": "<p>decay time in seconds</p>"
        }
      ],
      "examples": [],
      "synonyms": [
        "wtdec"
      ],
      "originalName": "wtdecay"
    },
    {
      "name": "wtdepth",
      "description": "<p>Depth of the LFO for the wavetable oscillator's position</p>",
      "params": [
        {
          "name": "depth",
          "type": "number | Pattern",
          "description": "<p>depth of modulation</p>"
        }
      ],
      "examples": [],
      "synonyms": [],
      "originalName": "wtdepth"
    },
    {
      "name": "wtenv",
      "description": "<p>Amount of envelope applied wavetable oscillator's position envelope</p>",
      "params": [
        {
          "name": "amount",
          "type": "number | Pattern",
          "description": "<p>between 0 and 1</p>"
        }
      ],
      "examples": [],
      "synonyms": [],
      "originalName": "wtenv"
    },
    {
      "name": "wtphaserand",
      "description": "<p>Amount of randomness of the initial phase of the wavetable oscillator.</p>",
      "params": [
        {
          "name": "amount",
          "type": "number | Pattern",
          "description": "<p>Randomness of the initial phase. Between 0 (not random) and 1 (fully random)</p>"
        }
      ],
      "examples": [
        "s(\"basique\").bank(\"wt_digital\").seg(16).wtphaserand(\"<0 1>\")"
      ],
      "synonyms": [
        "wavetablePhaseRand"
      ],
      "originalName": "wtphaserand"
    },
    {
      "name": "wtrate",
      "description": "<p>Rate of the LFO for the wavetable oscillator's position</p>",
      "params": [
        {
          "name": "rate",
          "type": "number | Pattern",
          "description": "<p>rate in hertz</p>"
        }
      ],
      "examples": [],
      "synonyms": [],
      "originalName": "wtrate"
    },
    {
      "name": "wtrel",
      "description": "<p>Release time of the wavetable oscillator's position envelope</p>",
      "params": [
        {
          "name": "time",
          "type": "number | Pattern",
          "description": "<p>release time in seconds</p>"
        }
      ],
      "examples": [],
      "synonyms": [
        "wtrel"
      ],
      "originalName": "wtrelease"
    },
    {
      "name": "wtrelease",
      "description": "<p>Release time of the wavetable oscillator's position envelope</p>",
      "params": [
        {
          "name": "time",
          "type": "number | Pattern",
          "description": "<p>release time in seconds</p>"
        }
      ],
      "examples": [],
      "synonyms": [
        "wtrel"
      ],
      "originalName": "wtrelease"
    },
    {
      "name": "wtshape",
      "description": "<p>Shape of the LFO for the wavetable oscillator's position</p>",
      "params": [
        {
          "name": "shape",
          "type": "number | Pattern",
          "description": "<p>Shape of the lfo (0, 1, 2, ..)</p>"
        }
      ],
      "examples": [],
      "synonyms": [],
      "originalName": "wtshape"
    },
    {
      "name": "wtskew",
      "description": "<p>Skew of the LFO for the wavetable oscillator's position</p>",
      "params": [
        {
          "name": "skew",
          "type": "number | Pattern",
          "description": "<p>How much to bend the LFO shape</p>"
        }
      ],
      "examples": [],
      "synonyms": [],
      "originalName": "wtskew"
    },
    {
      "name": "wtsus",
      "description": "<p>Sustain time of the wavetable oscillator's position envelope</p>",
      "params": [
        {
          "name": "gain",
          "type": "number | Pattern",
          "description": "<p>sustain level (0 to 1)</p>"
        }
      ],
      "examples": [],
      "synonyms": [
        "wtsus"
      ],
      "originalName": "wtsustain"
    },
    {
      "name": "wtsustain",
      "description": "<p>Sustain time of the wavetable oscillator's position envelope</p>",
      "params": [
        {
          "name": "gain",
          "type": "number | Pattern",
          "description": "<p>sustain level (0 to 1)</p>"
        }
      ],
      "examples": [],
      "synonyms": [
        "wtsus"
      ],
      "originalName": "wtsustain"
    },
    {
      "name": "wtsync",
      "description": "<p>cycle synced rate of the LFO for the wavetable oscillator's position</p>",
      "params": [
        {
          "name": "rate",
          "type": "number | Pattern",
          "description": "<p>rate in cycles</p>"
        }
      ],
      "examples": [],
      "synonyms": [],
      "originalName": "wtsync"
    },
    {
      "name": "xfade",
      "description": "<p>Cross-fades between left and right from 0 to 1:</p>\n<ul>\n<li>0 = (full left, no right)</li>\n<li>.5 = (both equal)</li>\n<li>1 = (no left, full right)</li>\n</ul>",
      "params": [],
      "examples": [
        "xfade(s(\"bd*2\"), \"<0 .25 .5 .75 1>\", s(\"hh*8\"))"
      ],
      "synonyms": [],
      "originalName": "xfade"
    },
    {
      "name": "zip",
      "description": "<p><em>Experimental</em></p>\n<p>'zips' together the steps of the provided patterns. This can create a long repetition, taking place over a single, dense cycle.\nUsing <code>pace</code> to set the number of steps per cycle is therefore usually recommended.</p>",
      "params": [],
      "examples": [
        "zip(\"e f\", \"e f g\", \"g [f e] a f4 c\").note()\r\n   .sound(\"folkharp\")\r\n   .pace(8)"
      ],
      "synonyms": [],
      "originalName": "zip"
    },
    {
      "name": "zoom",
      "description": "<p>Plays a portion of a pattern, specified by the beginning and end of a time span. The new resulting pattern is played over the time period of the original pattern:</p>",
      "params": [],
      "examples": [
        "s(\"bd*2 hh*3 [sd bd]*2 perc\").zoom(0.25, 0.75)\r// s(\"hh*3 [sd bd]*2\") // equivalent"
      ],
      "synonyms": [],
      "originalName": "zoom"
    }
  ],
  "lastGenerated": "2025-11-09T20:30:00.562Z"
}